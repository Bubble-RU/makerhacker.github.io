<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>1299 high scalability-2012-08-06-Paper: High-Performance Concurrency Control Mechanisms for Main-Memory Databases</title>
</head>

<body>
<p><a title="high_scalability" href="../high_scalability_home.html">high_scalability</a> <a title="high_scalability-2012" href="../home/high_scalability-2012_home.html">high_scalability-2012</a> <a title="high_scalability-2012-1299" href="#">high_scalability-2012-1299</a> knowledge-graph by maker-knowledge-mining</p><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- maker adsense -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-5027806277543591"
     data-ad-slot="4192012269"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>1299 high scalability-2012-08-06-Paper: High-Performance Concurrency Control Mechanisms for Main-Memory Databases</h1>
<br/><h2>meta infos for this blog</h2><p>Source: <a title="high_scalability-2012-1299-html" href="http://highscalability.com//blog/2012/8/6/paper-high-performance-concurrency-control-mechanisms-for-ma.html">html</a></p><p>Introduction: If you stayed up all night watching the life reaffirmingCuriosity landing on
Mars, then this paper,High-Performance Concurrency Control Mechanisms for
Main-Memory Databases, has nothing to do with that at all, but it is an
excellent look at how to use optimistic MVCC schemes to reduce lock overhead
on in-memory datastructures:A database system optimized for in-memory storage
can support much higher transaction rates than current systems. However,
standard concurrency control methods used today do not scale to the high
transaction rates achievable by such systems. In this paper we introduce two
efficient concurrency control methods specifically designed for main-memory
databases. Both use multiversioning to isolate read-only transactions from
updates but differ in how atomicity is ensured: one is optimistic and one is
pessimistic. To avoid expensive context switching, transactions never block
during normal processing but they may have to wait before commit to ensure
correct serializatio</p><br/><h2>Summary: the most important sentenses genereted by tfidf model</h2><p>sentIndex sentText sentNum sentScore</p><p>1 However, standard concurrency control methods used today do not scale to the high transaction rates achievable by such systems. [sent-2, score-0.987]
</p><p>2 In this paper we introduce two efficient concurrency control methods specifically designed for main-memory databases. [sent-3, score-0.701]
</p><p>3 Both use multiversioning to isolate read-only transactions from updates but differ in how atomicity is ensured: one is optimistic and one is pessimistic. [sent-4, score-0.826]
</p><p>4 To avoid expensive context switching, transactions never block during normal processing but they may have to wait before commit to ensure correct serialization ordering. [sent-5, score-0.834]
</p><p>5 We also implemented a main-memory optimized version of single-version locking. [sent-6, score-0.24]
</p><p>6 Experimental results show that while single-version locking works well when transactions are short and contention is low performance degrades under more demanding conditions. [sent-7, score-0.591]
</p><p>7 The multiversion schemes have higher overhead but are much less sensitive to hotspots and the presence of long-running transactions. [sent-8, score-1.019]
</p><p>8 Many applications have huge in-memory datastructures that are also accessed concurrently and can benefit from some of these ideas. [sent-10, score-0.614]
</p>
<br/>
<h2>similar blogs computed by tfidf model</h2><h3>tfidf for this blog:</h3><p>wordName wordTfidf (topN-words)</p>
<p>[('datastructures', 0.331), ('schemes', 0.24), ('concurrency', 0.209), ('optimistic', 0.206), ('landing', 0.185), ('methods', 0.184), ('multiversion', 0.174), ('optimized', 0.168), ('rates', 0.166), ('hotspots', 0.166), ('transactions', 0.158), ('mars', 0.155), ('overhead', 0.151), ('achievable', 0.15), ('transaction', 0.144), ('differ', 0.143), ('mvcc', 0.141), ('atomicity', 0.136), ('control', 0.134), ('degrades', 0.131), ('stayed', 0.124), ('demanding', 0.121), ('serialization', 0.12), ('concurrently', 0.119), ('isolate', 0.116), ('experimental', 0.114), ('higher', 0.111), ('watching', 0.105), ('commit', 0.1), ('presence', 0.098), ('switching', 0.098), ('night', 0.092), ('mechanisms', 0.092), ('locking', 0.092), ('correct', 0.09), ('introduce', 0.089), ('contention', 0.089), ('specifically', 0.085), ('accessed', 0.083), ('normal', 0.081), ('benefit', 0.081), ('lock', 0.081), ('block', 0.08), ('sensitive', 0.079), ('implemented', 0.072), ('wait', 0.072), ('context', 0.069), ('updates', 0.067), ('life', 0.065), ('avoid', 0.064)]</p>
<h3>similar blogs list:</h3><p>simIndex simValue blogId blogTitle</p>
<p>same-blog 1 0.99999988 <a title="1299-tfidf-1" href="../high_scalability-2012/high_scalability-2012-08-06-Paper%3A_High-Performance_Concurrency_Control_Mechanisms_for_Main-Memory_Databases.html">1299 high scalability-2012-08-06-Paper: High-Performance Concurrency Control Mechanisms for Main-Memory Databases</a></p>
<p>Introduction: If you stayed up all night watching the life reaffirmingCuriosity landing on
Mars, then this paper,High-Performance Concurrency Control Mechanisms for
Main-Memory Databases, has nothing to do with that at all, but it is an
excellent look at how to use optimistic MVCC schemes to reduce lock overhead
on in-memory datastructures:A database system optimized for in-memory storage
can support much higher transaction rates than current systems. However,
standard concurrency control methods used today do not scale to the high
transaction rates achievable by such systems. In this paper we introduce two
efficient concurrency control methods specifically designed for main-memory
databases. Both use multiversioning to isolate read-only transactions from
updates but differ in how atomicity is ensured: one is optimistic and one is
pessimistic. To avoid expensive context switching, transactions never block
during normal processing but they may have to wait before commit to ensure
correct serializatio</p><p>2 0.11897235 <a title="1299-tfidf-2" href="../high_scalability-2012/high_scalability-2012-10-22-Spanner_-_It%27s_About_Programmers_Building_Apps_Using_SQL_Semantics_at_NoSQL_Scale.html">1345 high scalability-2012-10-22-Spanner - It's About Programmers Building Apps Using SQL Semantics at NoSQL Scale</a></p>
<p>Introduction: A lot of people seem to passionately dislike the termNewSQL, or pretty much
any newly coined term for that matter, but after watching Alex Lloyd, Senior
Staff Software Engineer Google, give a great talkon Building Spanner, that's
the term that fits Spanner best.Spanner wraps the SQL + transaction model of
OldSQL around the reworked bones of a globally distributed NoSQL system. That
seems NewSQL to me.As Spanner is a not so distant cousin of BigTable, the
NoSQL component should be no surprise. Spanner is charged with spanning
millions of machines inside any number of geographically distributed
datacenters. What is surprising is how OldSQL has been embraced. In anearlier
2011 talkgiven by Alex at the HotStorage conference, the reason for embracing
OldSQL was the desire to make it easier and faster for programmers to build
applications. The main ideas will seem quite familiar:There's a false
dichotomy between little complicated databases and huge, scalable, simple
ones. We can have featur</p><p>3 0.11040417 <a title="1299-tfidf-3" href="../high_scalability-2012/high_scalability-2012-06-05-Thesis%3A_Concurrent_Programming_for_Scalable_Web_Architectures.html">1258 high scalability-2012-06-05-Thesis: Concurrent Programming for Scalable Web Architectures</a></p>
<p>Introduction: Benjamin Erb (@b_erb) from Ulm University recently published his diploma
thesis on"Concurrent Programming for Scalable Web Architectures". The thesis
provides a comprehensive survey on different concepts and techniques of
concurrency inside web architectures, including web servers, application logic
and storage backends. It incorporates research publications, hands-on reports
and also regards popular programming languages, frameworks and
databases.Abstract:Web architectures are an important asset for various large-
scale web applications, such as social networks or e-commerce sites. Being
able to handle huge numbers of users concurrently is essential, thus
scalability is one of the most important features of these architectures.
Multi-core processors, highly distributed backend architectures and new web
technologies force us to reconsider approaches for concurrent programming in
order to implement web applications and fulfil scalability demands. While
focusing on different stages of sc</p><p>4 0.1096165 <a title="1299-tfidf-4" href="../high_scalability-2008/high_scalability-2008-06-28-ID_generation_schemes.html">346 high scalability-2008-06-28-ID generation schemes</a></p>
<p>Introduction: Hi,Generating unique ids is a common requirements in many projects. Generally,
this responsibility is given to Database layer. By using sequences or some
other technique. This is a problem for horizontal scalability.What are the
Guid generation schemes used in high scalable web sites generally? I have seen
use java's SecureRandom class to generate Guid. What are the other methods
generally used?ThanksUnmesh</p><p>5 0.10783742 <a title="1299-tfidf-5" href="../high_scalability-2009/high_scalability-2009-09-16-Paper%3A_A_practical_scalable_distributed_B-tree.html">705 high scalability-2009-09-16-Paper: A practical scalable distributed B-tree</a></p>
<p>Introduction: We've seen a lot ofNoSQLaction lately built around distributed hash tables.
Btrees are getting jealous. Btrees, once the king of the database world, want
their throne back.Paul Buchheitsurfaced a paper:A practical scalable
distributed B-treeby Marcos K. Aguilera and Wojciech Golab, that might help
spark a revolution.From the Abstract:We propose a new algorithm for a
practical, fault tolerant, and scalable B-tree distributed over a set of
servers. Our algorithm supports practical features not present in prior work:
transactions that allow atomic execution of multiple operations over multiple
B-trees, online migration of B-tree nodes between servers, and dynamic
addition and removal of servers. Moreover, our algorithm is conceptually
simple: we use transactions to manipulate B-tree nodes so that clients need
not use complicated concurrency and locking protocols used in prior work. To
execute these transactions quickly, we rely on three techniques: (1) We use
optimistic concurrency contro</p><p>6 0.098848827 <a title="1299-tfidf-6" href="../high_scalability-2009/high_scalability-2009-03-16-Are_Cloud_Based_Memory_Architectures_the_Next_Big_Thing%3F.html">538 high scalability-2009-03-16-Are Cloud Based Memory Architectures the Next Big Thing?</a></p>
<p>7 0.093105376 <a title="1299-tfidf-7" href="../high_scalability-2014/high_scalability-2014-04-10-Paper%3A_Scalable_Atomic_Visibility_with_RAMP_Transactions_-_Scale_Linearly_to_100_Servers.html">1629 high scalability-2014-04-10-Paper: Scalable Atomic Visibility with RAMP Transactions - Scale Linearly to 100 Servers</a></p>
<p>8 0.092589177 <a title="1299-tfidf-8" href="../high_scalability-2010/high_scalability-2010-02-05-High_Availability_Principle_%3A_Concurrency_Control.html">772 high scalability-2010-02-05-High Availability Principle : Concurrency Control</a></p>
<p>9 0.091100849 <a title="1299-tfidf-9" href="../high_scalability-2009/high_scalability-2009-02-03-Paper%3A_Optimistic_Replication.html">507 high scalability-2009-02-03-Paper: Optimistic Replication</a></p>
<p>10 0.089101672 <a title="1299-tfidf-10" href="../high_scalability-2010/high_scalability-2010-09-01-Paper%3A_The_Case_for_Determinism_in_Database_Systems__.html">890 high scalability-2010-09-01-Paper: The Case for Determinism in Database Systems  </a></p>
<p>11 0.085364804 <a title="1299-tfidf-11" href="../high_scalability-2010/high_scalability-2010-11-09-Facebook_Uses_Non-Stored_Procedures_to_Update_Social_Graphs.html">936 high scalability-2010-11-09-Facebook Uses Non-Stored Procedures to Update Social Graphs</a></p>
<p>12 0.084538929 <a title="1299-tfidf-12" href="../high_scalability-2010/high_scalability-2010-06-28-VoltDB_Decapitates_Six_SQL_Urban_Myths_and_Delivers_Internet_Scale_OLTP_in_the_Process.html">849 high scalability-2010-06-28-VoltDB Decapitates Six SQL Urban Myths and Delivers Internet Scale OLTP in the Process</a></p>
<p>13 0.08058618 <a title="1299-tfidf-13" href="../high_scalability-2012/high_scalability-2012-07-04-Top_Features_of_a_Scalable_Database.html">1276 high scalability-2012-07-04-Top Features of a Scalable Database</a></p>
<p>14 0.080224462 <a title="1299-tfidf-14" href="../high_scalability-2014/high_scalability-2014-05-06-The_Quest_for_Database_Scale%3A_the_1_M_TPS_challenge_-_Three_Design_Points_and_Five_common_Bottlenecks_to_avoid.html">1643 high scalability-2014-05-06-The Quest for Database Scale: the 1 M TPS challenge - Three Design Points and Five common Bottlenecks to avoid</a></p>
<p>15 0.079230934 <a title="1299-tfidf-15" href="../high_scalability-2013/high_scalability-2013-10-18-Stuff_The_Internet_Says_On_Scalability_For_October_18th%2C_2013.html">1534 high scalability-2013-10-18-Stuff The Internet Says On Scalability For October 18th, 2013</a></p>
<p>16 0.07899414 <a title="1299-tfidf-16" href="../high_scalability-2009/high_scalability-2009-06-23-Learn_How_to_Exploit_Multiple_Cores_for_Better_Performance_and_Scalability.html">636 high scalability-2009-06-23-Learn How to Exploit Multiple Cores for Better Performance and Scalability</a></p>
<p>17 0.077267617 <a title="1299-tfidf-17" href="../high_scalability-2013/high_scalability-2013-07-19-Stuff_The_Internet_Says_On_Scalability_For_July_19%2C_2013.html">1494 high scalability-2013-07-19-Stuff The Internet Says On Scalability For July 19, 2013</a></p>
<p>18 0.076440245 <a title="1299-tfidf-18" href="../high_scalability-2008/high_scalability-2008-02-03-Ideas_on_how_to_scale_a_shared_inventory_database%3F%3F%3F.html">236 high scalability-2008-02-03-Ideas on how to scale a shared inventory database???</a></p>
<p>19 0.076253369 <a title="1299-tfidf-19" href="../high_scalability-2013/high_scalability-2013-03-11-Low_Level_Scalability_Solutions_-_The_Conditioning_Collection.html">1421 high scalability-2013-03-11-Low Level Scalability Solutions - The Conditioning Collection</a></p>
<p>20 0.075277239 <a title="1299-tfidf-20" href="../high_scalability-2013/high_scalability-2013-05-16-Paper%3A_Warp%3A_Multi-Key_Transactions_for_Key-Value_Stores.html">1459 high scalability-2013-05-16-Paper: Warp: Multi-Key Transactions for Key-Value Stores</a></p>
<br/>
<h2>similar blogs computed by <a title="lsi-model" href="../home/high_scalability_lsi.html">lsi model</a></h2><h3>lsi for this blog:</h3><p>topicId topicWeight</p>
<p>[(0, 0.115), (1, 0.053), (2, 0.014), (3, 0.024), (4, -0.008), (5, 0.08), (6, 0.037), (7, 0.023), (8, -0.055), (9, -0.022), (10, 0.02), (11, 0.015), (12, -0.041), (13, -0.019), (14, 0.0), (15, -0.006), (16, 0.012), (17, 0.014), (18, 0.016), (19, -0.034), (20, 0.039), (21, 0.008), (22, -0.011), (23, 0.004), (24, -0.018), (25, -0.048), (26, -0.006), (27, -0.018), (28, 0.057), (29, -0.029), (30, 0.004), (31, 0.001), (32, -0.05), (33, -0.006), (34, -0.037), (35, -0.012), (36, 0.01), (37, 0.028), (38, 0.02), (39, 0.016), (40, -0.019), (41, -0.009), (42, -0.042), (43, -0.02), (44, -0.034), (45, 0.03), (46, -0.006), (47, 0.001), (48, 0.01), (49, -0.008)]</p>
<h3>similar blogs list:</h3><p>simIndex simValue blogId blogTitle</p>
<p>same-blog 1 0.95773673 <a title="1299-lsi-1" href="../high_scalability-2012/high_scalability-2012-08-06-Paper%3A_High-Performance_Concurrency_Control_Mechanisms_for_Main-Memory_Databases.html">1299 high scalability-2012-08-06-Paper: High-Performance Concurrency Control Mechanisms for Main-Memory Databases</a></p>
<p>Introduction: If you stayed up all night watching the life reaffirmingCuriosity landing on
Mars, then this paper,High-Performance Concurrency Control Mechanisms for
Main-Memory Databases, has nothing to do with that at all, but it is an
excellent look at how to use optimistic MVCC schemes to reduce lock overhead
on in-memory datastructures:A database system optimized for in-memory storage
can support much higher transaction rates than current systems. However,
standard concurrency control methods used today do not scale to the high
transaction rates achievable by such systems. In this paper we introduce two
efficient concurrency control methods specifically designed for main-memory
databases. Both use multiversioning to isolate read-only transactions from
updates but differ in how atomicity is ensured: one is optimistic and one is
pessimistic. To avoid expensive context switching, transactions never block
during normal processing but they may have to wait before commit to ensure
correct serializatio</p><p>2 0.80663717 <a title="1299-lsi-2" href="../high_scalability-2014/high_scalability-2014-04-10-Paper%3A_Scalable_Atomic_Visibility_with_RAMP_Transactions_-_Scale_Linearly_to_100_Servers.html">1629 high scalability-2014-04-10-Paper: Scalable Atomic Visibility with RAMP Transactions - Scale Linearly to 100 Servers</a></p>
<p>Introduction: We are not yet at the End of History for database theory asPeter Bailisand
theDatabase Groupat UC Berkeley continue to prove with a greatcompanion blog
post to their new paper: Scalable Atomic Visibility with RAMP Transactions. I
like the approach of pairing a blog post with a paper. A paper almost by
definition is formal, but a blog post can help put a paper in context and give
it some heart.From the abstract:Databases can provide scalability by
partitioning data across several servers. However, multi-partition, multi-
operation transactional access is often expensive, employing coordination-
intensive locking, validation, or scheduling mechanisms. Accordingly, many
real-world systems avoid mechanisms that provide useful semantics formulti-
partition operations. This leads to incorrect behavior for a large class of
applications including secondary indexing,foreign key enforcement, and
materialized view maintenance. In this work, we identify a new isolation model
--Read Atomic (RA) iso</p><p>3 0.80110705 <a title="1299-lsi-3" href="../high_scalability-2010/high_scalability-2010-09-01-Paper%3A_The_Case_for_Determinism_in_Database_Systems__.html">890 high scalability-2010-09-01-Paper: The Case for Determinism in Database Systems  </a></p>
<p>Introduction: Can you have your ACID cake and eat your distributed database too? Yes
explains Daniel Abadi, Assistant Professor of Computer Science at Yale
University, in an epic post,The problems with ACID, and how to fix them
without going NoSQL, coauthored with Alexander Thomson, on their paperThe Case
for Determinism in Database Systems. We've already seenVoltDBoffer the best of
both worlds, this sounds like a completely different approach.The solution,
they propose, is: ...an architecture and execution model that avoids deadlock,
copes with failures without aborting transactions, and achieves high
concurrency. The paper contains full details, but the basic idea is to use
ordered locking coupled with optimistic lock location prediction, while
exploiting deterministic systems' nice replication properties in the case of
failures.The problem they are trying to solve is:In our opinion, the NoSQL
decision to give up on ACID is the lazy solution to these scalability and
replication issues. Responsibil</p><p>4 0.77223158 <a title="1299-lsi-4" href="../high_scalability-2013/high_scalability-2013-05-16-Paper%3A_Warp%3A_Multi-Key_Transactions_for_Key-Value_Stores.html">1459 high scalability-2013-05-16-Paper: Warp: Multi-Key Transactions for Key-Value Stores</a></p>
<p>Introduction: Looks like an interesting take on "a completely asynchronous, low-latency
transaction management protocol, in line with the fully distributed NoSQL
architecture."Warp: Multi-Key Transactions for Key-Value Stores
overview:Implementing ACID transactions has been a longstanding challenge for
NoSQL systems. Because these systems are based on a sharded architecture,
transactions necessarily require coordination across multiple servers. Past
work in this space has relied either on heavyweight protocols such as Paxos or
clock synchronization for this coordination.This paper presents a novel
protocol for coordinating distributed transactions with ACID semantics on top
of a sharded data store. Called linear transactions, this protocol achieves
scalability by distributing the coordination task to only those servers that
hold relevant data for each transaction. It achieves high performance by
serializing only those transactions whose concurrent execution could
potentially yield a violation of ACI</p><p>5 0.76938385 <a title="1299-lsi-5" href="../high_scalability-2013/high_scalability-2013-10-31-Paper%3A_Everything_You_Always_Wanted_to_Know_About_Synchronization_but_Were_Afraid_to_Ask.html">1541 high scalability-2013-10-31-Paper: Everything You Always Wanted to Know About Synchronization but Were Afraid to Ask</a></p>
<p>Introduction: Awesome paper on how particular synchronization mechanisms scale on multi-core
architectures: Everything You Always Wanted to Know About Synchronization but
Were Afraid to Ask.The goal is to pick a locking approach that doesn't degrade
as the number of cores increase. Like everything else in life, that doesn't
appear to be generically possible:None of the nine locking schemes we consider
consistently outperforms any other one, on all target architectures or
workloads. Strictly speaking, to seek optimality, a lock algorithm should thus
be selected based on the hardware platform and the expected workload.
Abstract:This paper presents the most exhaustive study of synchronization to
date. We span multiple layers, from hardware cache-coherence protocols up to
high-level concurrent software. We do so on different types architectures,
from single-socket - uniform and nonuniform - to multi-socket - directory and
broadcastbased - many-cores. We draw a set of observations that, roughly
speaking,</p><p>6 0.76837772 <a title="1299-lsi-6" href="../high_scalability-2013/high_scalability-2013-05-23-Paper%3A_Calvin%3A_Fast_Distributed_Transactions_for_Partitioned_Database_Systems.html">1463 high scalability-2013-05-23-Paper: Calvin: Fast Distributed Transactions for Partitioned Database Systems</a></p>
<p>7 0.76506823 <a title="1299-lsi-7" href="../high_scalability-2009/high_scalability-2009-09-16-Paper%3A_A_practical_scalable_distributed_B-tree.html">705 high scalability-2009-09-16-Paper: A practical scalable distributed B-tree</a></p>
<p>8 0.74787313 <a title="1299-lsi-8" href="../high_scalability-2010/high_scalability-2010-12-23-Paper%3A_CRDTs%3A_Consistency_without_concurrency_control.html">963 high scalability-2010-12-23-Paper: CRDTs: Consistency without concurrency control</a></p>
<p>9 0.7399264 <a title="1299-lsi-9" href="../high_scalability-2009/high_scalability-2009-02-03-Paper%3A_Optimistic_Replication.html">507 high scalability-2009-02-03-Paper: Optimistic Replication</a></p>
<p>10 0.73790991 <a title="1299-lsi-10" href="../high_scalability-2012/high_scalability-2012-06-27-Paper%3A_Logic_and_Lattices_for_Distributed_Programming.html">1273 high scalability-2012-06-27-Paper: Logic and Lattices for Distributed Programming</a></p>
<p>11 0.73097408 <a title="1299-lsi-11" href="../high_scalability-2009/high_scalability-2009-08-08-Yahoo%21%27s_PNUTS_Database%3A_Too_Hot%2C_Too_Cold_or_Just_Right%3F.html">676 high scalability-2009-08-08-Yahoo!'s PNUTS Database: Too Hot, Too Cold or Just Right?</a></p>
<p>12 0.72355872 <a title="1299-lsi-12" href="../high_scalability-2013/high_scalability-2013-11-25-How_To_Make_an_Infinitely_Scalable_Relational_Database_Management_System_%28RDBMS%29.html">1553 high scalability-2013-11-25-How To Make an Infinitely Scalable Relational Database Management System (RDBMS)</a></p>
<p>13 0.71407831 <a title="1299-lsi-13" href="../high_scalability-2012/high_scalability-2012-04-30-Masstree_-_Much_Faster_than_MongoDB%2C_VoltDB%2C_Redis%2C_and_Competitive_with_Memcached.html">1236 high scalability-2012-04-30-Masstree - Much Faster than MongoDB, VoltDB, Redis, and Competitive with Memcached</a></p>
<p>14 0.71011251 <a title="1299-lsi-14" href="../high_scalability-2011/high_scalability-2011-11-23-Paper%3A_Don%E2%80%99t_Settle_for_Eventual%3A_Scalable_Causal_Consistency_for_Wide-Area_Storage_with_COPS.html">1146 high scalability-2011-11-23-Paper: Don’t Settle for Eventual: Scalable Causal Consistency for Wide-Area Storage with COPS</a></p>
<p>15 0.70484167 <a title="1299-lsi-15" href="../high_scalability-2011/high_scalability-2011-02-02-Piccolo_-_Building_Distributed_Programs_that_are_11x_Faster_than_Hadoop.html">983 high scalability-2011-02-02-Piccolo - Building Distributed Programs that are 11x Faster than Hadoop</a></p>
<p>16 0.69039154 <a title="1299-lsi-16" href="../high_scalability-2012/high_scalability-2012-08-16-Paper%3A_A_Provably_Correct_Scalable_Concurrent_Skip_List.html">1305 high scalability-2012-08-16-Paper: A Provably Correct Scalable Concurrent Skip List</a></p>
<p>17 0.68473595 <a title="1299-lsi-17" href="../high_scalability-2010/high_scalability-2010-12-16-7_Design_Patterns_for_Almost-infinite_Scalability.html">958 high scalability-2010-12-16-7 Design Patterns for Almost-infinite Scalability</a></p>
<p>18 0.67986608 <a title="1299-lsi-18" href="../high_scalability-2008/high_scalability-2008-07-26-Google%27s_Paxos_Made_Live_%E2%80%93_An_Engineering_Perspective.html">357 high scalability-2008-07-26-Google's Paxos Made Live – An Engineering Perspective</a></p>
<p>19 0.67919087 <a title="1299-lsi-19" href="../high_scalability-2011/high_scalability-2011-12-08-Update_on_Scalable_Causal_Consistency_For_Wide-Area_Storage_With_COPS.html">1153 high scalability-2011-12-08-Update on Scalable Causal Consistency For Wide-Area Storage With COPS</a></p>
<p>20 0.67504597 <a title="1299-lsi-20" href="../high_scalability-2010/high_scalability-2010-06-18-Paper%3A_The_Declarative_Imperative%3A_Experiences_and_Conjectures_in_Distributed_Logic.html">844 high scalability-2010-06-18-Paper: The Declarative Imperative: Experiences and Conjectures in Distributed Logic</a></p>
<br/>
<h2>similar blogs computed by <a title="lda-model" href="../home/high_scalability_lda.html">lda model</a></h2><h3>lda for this blog:</h3><p>topicId topicWeight</p>
<p>[(1, 0.065), (2, 0.21), (10, 0.612)]</p>
<h3>similar blogs list:</h3><p>simIndex simValue blogId blogTitle</p>
<p>1 0.96287394 <a title="1299-lda-1" href="../high_scalability-2007/high_scalability-2007-12-10-1_Master%2C_N_Slaves.html">178 high scalability-2007-12-10-1 Master, N Slaves</a></p>
<p>Introduction: Hello all,Reading the site you can note that "1 Master for writes, N Slaves
for reads" scheme is used offen.How is this implemented? Who decides where
writes and reads go? Something in application level or specific database
proxies, like Slony-I?Thanks.</p><p>same-blog 2 0.94757891 <a title="1299-lda-2" href="../high_scalability-2012/high_scalability-2012-08-06-Paper%3A_High-Performance_Concurrency_Control_Mechanisms_for_Main-Memory_Databases.html">1299 high scalability-2012-08-06-Paper: High-Performance Concurrency Control Mechanisms for Main-Memory Databases</a></p>
<p>Introduction: If you stayed up all night watching the life reaffirmingCuriosity landing on
Mars, then this paper,High-Performance Concurrency Control Mechanisms for
Main-Memory Databases, has nothing to do with that at all, but it is an
excellent look at how to use optimistic MVCC schemes to reduce lock overhead
on in-memory datastructures:A database system optimized for in-memory storage
can support much higher transaction rates than current systems. However,
standard concurrency control methods used today do not scale to the high
transaction rates achievable by such systems. In this paper we introduce two
efficient concurrency control methods specifically designed for main-memory
databases. Both use multiversioning to isolate read-only transactions from
updates but differ in how atomicity is ensured: one is optimistic and one is
pessimistic. To avoid expensive context switching, transactions never block
during normal processing but they may have to wait before commit to ensure
correct serializatio</p><p>3 0.92999309 <a title="1299-lda-3" href="../high_scalability-2011/high_scalability-2011-06-22-It%27s_the_Fraking_IOPS_-_1_SSD_is_44%2C000_IOPS%2C_Hard_Drive_is_180.html">1066 high scalability-2011-06-22-It's the Fraking IOPS - 1 SSD is 44,000 IOPS, Hard Drive is 180</a></p>
<p>Introduction: Planning your next buildout and thinking SSDs are still far in the future?
Still too expensive, too low density. Hard disks are cheap, familiar, and
store lots of stuff. In this short and entertaining video Wikia's Artur
Bergmanwants to change your mind about SSDs. SSDs are for today, get with the
math already.Here's Artur's logic:Wikia is all SSD in production. The new
Wikia file servers have a theoretical read rate of ~10GB/sec sequential,
6GB/sec random and 1.2 million IOPs. If you can't do math or love the past,
you love spinning rust. If you are awesome you love SSDs.SSDs are cheaper than
drives using the most relevant metric: $/GB/IOPS. 1 SSD is 44,000 IOPS and one
hard drive is 180 IOPS. Need 1 SSD instead of 50 hard drives.With 8 million
files there's a 9 minute fsck. Full backup in 12 minutes (X-25M based).4
GB/sec random read average latency 1 msec.2.2 GB/sec random write average
latency 1 msec.50TBs of SSDs in one machine for $80,000. With the densities
most products can ski</p><p>4 0.92976272 <a title="1299-lda-4" href="../high_scalability-2010/high_scalability-2010-08-07-ArchCamp%3A_Scalable_Databases_%28NoSQL%29.html">874 high scalability-2010-08-07-ArchCamp: Scalable Databases (NoSQL)</a></p>
<p>Introduction: ArchCamp: Scalable Databasess (NoSQL)The ArchCamp unconference was held this
past Friday at HackerDojo in Mountain View, CA.  There was plenty of pizza,
beer, and great conversation.  This session started out free-form, but shaped
up pretty quickly into a discussion of the popular open source scalable NoSQL
databases and the architectural categories in which they belong.</p><p>5 0.91596115 <a title="1299-lda-5" href="../high_scalability-2008/high_scalability-2008-10-26-Should_you_use_a_SAN_to_scale_your_architecture%3F_.html">430 high scalability-2008-10-26-Should you use a SAN to scale your architecture? </a></p>
<p>Introduction: This is a question everyone must struggle with when building out their
datacenter. Storage choices are always the ones I have the least confidence
in. David Marks in his blogYou Can Change It Later!asks the questionShould I
get a SAN to scale my site architecture?and answers no. A better solution is
to use commodity hardware, directly attach storage on servers, and partition
across servers to scale and for greater availability.David's reasoning is
interesting:A SAN creates a SPOF (single point of failure) that is dependent
on a vendor to fly and fix when there's a problem. This can lead to long down
times during this outage you have no access to your data at all.Using easily
available commodity hardware minimizes risks to your company, it's not just
about saving money. Zooming over to Fry's to buy emergency equipment provides
the kind of agility startups need in order to respond quickly to ever changing
situations.It's hard to beat the power and flexibility (backups, easy to add
storag</p><p>6 0.90577984 <a title="1299-lda-6" href="../high_scalability-2007/high_scalability-2007-12-02-a8cjdbc_-_update_verision_1.3.html">171 high scalability-2007-12-02-a8cjdbc - update verision 1.3</a></p>
<p>7 0.90576398 <a title="1299-lda-7" href="../high_scalability-2007/high_scalability-2007-12-02-Database-Clustering%3A_a8cjdbc_-_update%3A_version_1.3.html">170 high scalability-2007-12-02-Database-Clustering: a8cjdbc - update: version 1.3</a></p>
<p>8 0.89300984 <a title="1299-lda-8" href="../high_scalability-2013/high_scalability-2013-06-24-Update_on_How_29_Cloud_Price_Drops_Changed_the_Bottom_Line_of_TripAdvisor_and_Pinterest_-_Results_Mixed.html">1480 high scalability-2013-06-24-Update on How 29 Cloud Price Drops Changed the Bottom Line of TripAdvisor and Pinterest - Results Mixed</a></p>
<p>9 0.859025 <a title="1299-lda-9" href="../high_scalability-2014/high_scalability-2014-04-21-This_is_why_Microsoft_won._And_why_they_lost..html">1635 high scalability-2014-04-21-This is why Microsoft won. And why they lost.</a></p>
<p>10 0.84268403 <a title="1299-lda-10" href="../high_scalability-2010/high_scalability-2010-01-27-Hot_Scalability_Links_for_January_28_2010.html">767 high scalability-2010-01-27-Hot Scalability Links for January 28 2010</a></p>
<p>11 0.83521366 <a title="1299-lda-11" href="../high_scalability-2014/high_scalability-2014-04-14-How_do_you_even_do_anything_without_using_EBS%3F.html">1631 high scalability-2014-04-14-How do you even do anything without using EBS?</a></p>
<p>12 0.81238317 <a title="1299-lda-12" href="../high_scalability-2011/high_scalability-2011-05-23-Evernote_Architecture_-_9_Million_Users_and_150_Million_Requests_a_Day.html">1046 high scalability-2011-05-23-Evernote Architecture - 9 Million Users and 150 Million Requests a Day</a></p>
<p>13 0.80813062 <a title="1299-lda-13" href="../high_scalability-2010/high_scalability-2010-03-10-How_FarmVille_Scales_-_The_Follow-up.html">792 high scalability-2010-03-10-How FarmVille Scales - The Follow-up</a></p>
<p>14 0.80211896 <a title="1299-lda-14" href="../high_scalability-2009/high_scalability-2009-08-28-Strategy%3A_Solve_Only_80_Percent_of_the_Problem.html">689 high scalability-2009-08-28-Strategy: Solve Only 80 Percent of the Problem</a></p>
<p>15 0.79846758 <a title="1299-lda-15" href="../high_scalability-2009/high_scalability-2009-04-27-Some_Questions_from_a_newbie.html">584 high scalability-2009-04-27-Some Questions from a newbie</a></p>
<p>16 0.76614565 <a title="1299-lda-16" href="../high_scalability-2014/high_scalability-2014-01-24-Stuff_The_Internet_Says_On_Scalability_For_January_24th%2C_2014.html">1585 high scalability-2014-01-24-Stuff The Internet Says On Scalability For January 24th, 2014</a></p>
<p>17 0.7032975 <a title="1299-lda-17" href="../high_scalability-2007/high_scalability-2007-07-16-Paper%3A_The_Clustered_Storage_Revolution.html">20 high scalability-2007-07-16-Paper: The Clustered Storage Revolution</a></p>
<p>18 0.69791913 <a title="1299-lda-18" href="../high_scalability-2012/high_scalability-2012-11-01-Cost_Analysis%3A_TripAdvisor_and_Pinterest_costs_on_the_AWS_cloud.html">1353 high scalability-2012-11-01-Cost Analysis: TripAdvisor and Pinterest costs on the AWS cloud</a></p>
<p>19 0.69668603 <a title="1299-lda-19" href="../high_scalability-2012/high_scalability-2012-10-02-An_Epic_TripAdvisor_Update%3A_Why_Not_Run_on_the_Cloud%3F_The_Grand_Experiment..html">1331 high scalability-2012-10-02-An Epic TripAdvisor Update: Why Not Run on the Cloud? The Grand Experiment.</a></p>
<p>20 0.68940854 <a title="1299-lda-20" href="../high_scalability-2007/high_scalability-2007-11-05-Strategy%3A_Diagonal_Scaling_-_Don%27t_Forget_to_Scale_Out_AND_Up.html">142 high scalability-2007-11-05-Strategy: Diagonal Scaling - Don't Forget to Scale Out AND Up</a></p>
<br/><br/><br/>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-48522588-1', 'makerhacker.github.io');
ga('send', 'pageview');
</script>

</body>
</html>
