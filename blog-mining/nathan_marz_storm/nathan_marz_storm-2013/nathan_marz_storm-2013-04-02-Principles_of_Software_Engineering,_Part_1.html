<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>37 nathan marz storm-2013-04-02-Principles of Software Engineering, Part 1</title>
</head>

<body>
<p><a title="nathan_marz_storm" href="../nathan_marz_storm_home.html">nathan_marz_storm</a> <a title="nathan_marz_storm-2013" href="../home/nathan_marz_storm-2013_home.html">nathan_marz_storm-2013</a> <a title="nathan_marz_storm-2013-37" href="#">nathan_marz_storm-2013-37</a> knowledge-graph by maker-knowledge-mining</p><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- maker adsense -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-5027806277543591"
     data-ad-slot="4192012269"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>37 nathan marz storm-2013-04-02-Principles of Software Engineering, Part 1</h1>
<br/><h2>meta infos for this blog</h2><p>Source: <a title="nathan_marz_storm-2013-37-html" href="http://nathanmarz.com//blog/principles-of-software-engineering-part-1.html">html</a></p><p>Introduction: This is the first in a series of posts on the principles of software
engineering. There's far more to software engineering than just "making
computers do stuff" – while that phrase is accurate, it does not come close to
describing what's involved in making robust, reliable software. I will use my
experience building large scale systems to inform a first principles approach
to defining what it is we do – or should be doing – as software engineers. I'm
not interested in tired debates like dynamic vs. static languages – instead, I
intend to explore the really core aspects of software engineering.The first
order of business is to define what software engineering even is in the first
place. Software engineering is the construction of software that produces some
desired output for some range of inputs. The inputs to software are more than
just method parameters: they include the hardware on which it's running, the
rate at which it receives data, and anything else that influences the
operatio</p><br/>
<h2>similar blogs computed by tfidf model</h2><h3>tfidf for this blog:</h3><p>wordName wordTfidf (topN-words)</p>
<p>[('software', 0.437), ('zookeeper', 0.324), ('uncertainty', 0.281), ('reporterror', 0.151), ('application', 0.147), ('failure', 0.137), ('dependencies', 0.137), ('method', 0.135), ('input', 0.134), ('inputs', 0.129), ('rocket', 0.129), ('worker', 0.129), ('failures', 0.123), ('engineering', 0.122), ('errors', 0.122), ('storm', 0.11), ('traffic', 0.108), ('components', 0.106), ('unexpected', 0.105), ('cascading', 0.098)]</p>
<h3>similar blogs list:</h3><p>simIndex simValue blogId blogTitle</p>
<p>same-blog 1 1.0000008 <a title="37-tfidf-1" href="../nathan_marz_storm-2013/nathan_marz_storm-2013-04-02-Principles_of_Software_Engineering%2C_Part_1.html">37 nathan marz storm-2013-04-02-Principles of Software Engineering, Part 1</a></p>
<p>Introduction: This is the first in a series of posts on the principles of software
engineering. There's far more to software engineering than just "making
computers do stuff" – while that phrase is accurate, it does not come close to
describing what's involved in making robust, reliable software. I will use my
experience building large scale systems to inform a first principles approach
to defining what it is we do – or should be doing – as software engineers. I'm
not interested in tired debates like dynamic vs. static languages – instead, I
intend to explore the really core aspects of software engineering.The first
order of business is to define what software engineering even is in the first
place. Software engineering is the construction of software that produces some
desired output for some range of inputs. The inputs to software are more than
just method parameters: they include the hardware on which it's running, the
rate at which it receives data, and anything else that influences the
operatio</p><p>2 0.17339042 <a title="37-tfidf-2" href="../nathan_marz_storm-2014/nathan_marz_storm-2014-02-12-Interview_with_%22Programmer_Magazine%22.html">39 nathan marz storm-2014-02-12-Interview with "Programmer Magazine"</a></p>
<p>Introduction: I wasrecently interviewedfor "Programmer Magazine", a Chinese magazine. The
interview was published in Chinese, but a lot of people told me they'd like to
see the English version of the interview. Due to the Google translation being,
ahem, a little iffy, I decided to just publish the original English version on
my blog. Hope you enjoy!What drew you to programming and what was the first
interesting program you wrote?I started programming when I was 10 years old on
my TI-82 graphing calculator. Initially I started programming because I wanted
to make games on my calculator – and also because I was bored in math class
:D. The first interesting game I made on my calculator was an archery game
where you'd shoot arrows at moving targets. You'd get points for hitting more
targets or completing all the targets faster. A couple years later I graduated
to programming the TI-89 which was a huge upgrade in power. I remember how the
TI-82 only let you have 26 variables (for the characters 'a' throu</p><p>3 0.14453708 <a title="37-tfidf-3" href="../nathan_marz_storm-2011/nathan_marz_storm-2011-01-19-Inglourious_Software_Patents.html">29 nathan marz storm-2011-01-19-Inglourious Software Patents</a></p>
<p>Introduction: Most articles arguing for the abolishment of software patents focus on how so
many software patents don't meet the "non-obvious and non-trivial" guidelines
for patents. The problem with this approach is that the same argument could be
used to advocate for reform in how software patents are evaluated rather than
the abolishment of software patents altogether.Software patents should be
abolished though, and I'm going to show this with an economic analysis. We'll
see that even non-obvious and non-trivial software patents should never be
granted as they can only cause economic loss.Why do patents exist in the first
place?The patent system exists to provide an incentive for innovationwhere
that incentive would not have existed otherwise.Imagine you're an individual
living in the 19th century. Let's say the patent system does not exist and you
have an idea to make a radically better kind of sewing machine. If you
invested the time to develop your idea into a working invention, the existing
s</p><p>4 0.11653561 <a title="37-tfidf-4" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-03-04-Introducing_%22Nanny%22_-_a_really_simple_dependency_management_tool.html">7 nathan marz storm-2010-03-04-Introducing "Nanny" - a really simple dependency management tool</a></p>
<p>Introduction: Dependency management in software projects is a pretty simple problem when you
think about it. A tool to manage dependencies just needs to do three
things:Provide a mechanism to specify the direct dependencies to a
projectDownload the transitive closure of dependencies to a projectPublish
packages that can be used as a dependency to other projectsSome languages have
good dependency management systems - for example, rubygems. Others, like Java,
have tools like Maven which I would call a complex solution to a simple
problem. You shouldn't need to buy abookto understand the solution to such a
simple problem. Plus, these dependency management systems are all language
specific.I've seen companies do crazy things to manage their dependencies. One
company, to manage their jar files, would put all the jars that any project
might need in a special "jars" project. You would then need to setup a
JARS_HOME environment variable and be sure to update the jars project if you
need any of the dependenc</p><p>5 0.1132773 <a title="37-tfidf-5" href="../nathan_marz_storm-2012/nathan_marz_storm-2012-09-19-Storm%27s_1st_birthday.html">34 nathan marz storm-2012-09-19-Storm's 1st birthday</a></p>
<p>Introduction: Stormwas open-sourced exactly one year ago today. It's been an action-packed
year for Storm, to say the least. Here's some of the exciting stuff that's
happened over the past year:27 companies have publicized that they'reusing
Storm in production. I know of at least a few more companies using it that
haven't published anything yet.O'Reillypublished a bookon Storm.The Storm
mailing list has over 1300 members, with over 500 messages per month.The
@stormprocessor account has over 1200 followers.More than 4000 people have
starred the projecton Github.There's a regular Storm meetup in the Bay Area
with over 230 members. I've also seen lots of Storm-focused meetups happen all
over the world over the past year.29 people all over the world have
contributed to the codebaseWe releasedTrident, a high level abstraction for
realtime computation, that is a major leap forward in what's possible in
realtime.Libraries have been released integrating Storm with Kestrel, Kafka,
JMS, Cassandra, Memcached,</p><p>6 0.11195478 <a title="37-tfidf-6" href="../nathan_marz_storm-2012/nathan_marz_storm-2012-02-06-Suffering-oriented_programming.html">33 nathan marz storm-2012-02-06-Suffering-oriented programming</a></p>
<p>7 0.10929836 <a title="37-tfidf-7" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-08-20-5_Tips_for_Thinking_Under_Uncertainty.html">21 nathan marz storm-2010-08-20-5 Tips for Thinking Under Uncertainty</a></p>
<p>8 0.078183465 <a title="37-tfidf-8" href="../nathan_marz_storm-2011/nathan_marz_storm-2011-10-13-How_to_beat_the_CAP_theorem.html">31 nathan marz storm-2011-10-13-How to beat the CAP theorem</a></p>
<p>9 0.060158972 <a title="37-tfidf-9" href="../nathan_marz_storm-2009/nathan_marz_storm-2009-12-28-The_mathematics_behind_Hadoop-based_systems.html">1 nathan marz storm-2009-12-28-The mathematics behind Hadoop-based systems</a></p>
<p>10 0.060097814 <a title="37-tfidf-10" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-06-16-Your_company_has_a_knowledge_debt_problem.html">18 nathan marz storm-2010-06-16-Your company has a knowledge debt problem</a></p>
<p>11 0.057137556 <a title="37-tfidf-11" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-05-08-News_Feed_in_38_lines_of_code_using_Cascalog.html">16 nathan marz storm-2010-05-08-News Feed in 38 lines of code using Cascalog</a></p>
<p>12 0.055897012 <a title="37-tfidf-12" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-07-12-My_experience_as_the_first_employee_of_a_Y_Combinator_startup.html">19 nathan marz storm-2010-07-12-My experience as the first employee of a Y Combinator startup</a></p>
<p>13 0.055630166 <a title="37-tfidf-13" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-04-14-Introducing_Cascalog%3A_a_Clojure-based_query_language_for_Hadoop.html">13 nathan marz storm-2010-04-14-Introducing Cascalog: a Clojure-based query language for Hadoop</a></p>
<p>14 0.054611579 <a title="37-tfidf-14" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-01-03-Tips_for_Optimizing_Cascading_Flows.html">2 nathan marz storm-2010-01-03-Tips for Optimizing Cascading Flows</a></p>
<p>15 0.05157226 <a title="37-tfidf-15" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-10-05-How_to_get_a_job_at_a_kick-ass_startup_%28for_programmers%29.html">22 nathan marz storm-2010-10-05-How to get a job at a kick-ass startup (for programmers)</a></p>
<p>16 0.049836859 <a title="37-tfidf-16" href="../nathan_marz_storm-2013/nathan_marz_storm-2013-04-12-Break_into_Silicon_Valley_with_a_blog.html">38 nathan marz storm-2013-04-12-Break into Silicon Valley with a blog</a></p>
<p>17 0.049537025 <a title="37-tfidf-17" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-03-10-Thrift_%2B_Graphs_%3D_Strong%2C_flexible_schemas_on_Hadoop.html">9 nathan marz storm-2010-03-10-Thrift + Graphs = Strong, flexible schemas on Hadoop</a></p>
<p>18 0.047302205 <a title="37-tfidf-18" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-07-30-You_should_blog_even_if_you_have_no_readers.html">20 nathan marz storm-2010-07-30-You should blog even if you have no readers</a></p>
<p>19 0.045940153 <a title="37-tfidf-19" href="../nathan_marz_storm-2014/nathan_marz_storm-2014-05-10-Why_we_in_tech_must_support_Lawrence_Lessig.html">41 nathan marz storm-2014-05-10-Why we in tech must support Lawrence Lessig</a></p>
<p>20 0.044480026 <a title="37-tfidf-20" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-10-27-Fastest_Viable_Product%3A_Investing_in_Speed_at_a_Startup.html">23 nathan marz storm-2010-10-27-Fastest Viable Product: Investing in Speed at a Startup</a></p>
<br/>
<h2>similar blogs computed by <a title="lsi-model" href="../home/nathan_marz_storm_lsi.html">lsi model</a></h2><h3>lsi for this blog:</h3><p>topicId topicWeight</p>
<p>[(0, 0.306), (1, 0.037), (2, 0.024), (3, 0.25), (4, -0.254), (5, 0.14), (6, 0.185), (7, -0.132), (8, -0.395), (9, 0.229), (10, -0.073), (11, -0.008), (12, 0.167), (13, 0.042), (14, 0.013), (15, 0.016), (16, 0.044), (17, 0.023), (18, 0.035), (19, -0.004), (20, -0.063), (21, 0.071), (22, -0.0), (23, -0.064), (24, -0.137), (25, 0.091), (26, -0.013), (27, 0.15), (28, 0.06), (29, -0.085), (30, 0.216), (31, 0.455), (32, -0.094), (33, 0.13), (34, -0.261), (35, -0.142), (36, 0.094), (37, -0.016), (38, 0.091), (39, 0.018), (40, -0.006)]</p>
<h3>similar blogs list:</h3><p>simIndex simValue blogId blogTitle</p>
<p>same-blog 1 0.99058366 <a title="37-lsi-1" href="../nathan_marz_storm-2013/nathan_marz_storm-2013-04-02-Principles_of_Software_Engineering%2C_Part_1.html">37 nathan marz storm-2013-04-02-Principles of Software Engineering, Part 1</a></p>
<p>Introduction: This is the first in a series of posts on the principles of software
engineering. There's far more to software engineering than just "making
computers do stuff" – while that phrase is accurate, it does not come close to
describing what's involved in making robust, reliable software. I will use my
experience building large scale systems to inform a first principles approach
to defining what it is we do – or should be doing – as software engineers. I'm
not interested in tired debates like dynamic vs. static languages – instead, I
intend to explore the really core aspects of software engineering.The first
order of business is to define what software engineering even is in the first
place. Software engineering is the construction of software that produces some
desired output for some range of inputs. The inputs to software are more than
just method parameters: they include the hardware on which it's running, the
rate at which it receives data, and anything else that influences the
operatio</p><p>2 0.27177316 <a title="37-lsi-2" href="../nathan_marz_storm-2011/nathan_marz_storm-2011-01-19-Inglourious_Software_Patents.html">29 nathan marz storm-2011-01-19-Inglourious Software Patents</a></p>
<p>Introduction: Most articles arguing for the abolishment of software patents focus on how so
many software patents don't meet the "non-obvious and non-trivial" guidelines
for patents. The problem with this approach is that the same argument could be
used to advocate for reform in how software patents are evaluated rather than
the abolishment of software patents altogether.Software patents should be
abolished though, and I'm going to show this with an economic analysis. We'll
see that even non-obvious and non-trivial software patents should never be
granted as they can only cause economic loss.Why do patents exist in the first
place?The patent system exists to provide an incentive for innovationwhere
that incentive would not have existed otherwise.Imagine you're an individual
living in the 19th century. Let's say the patent system does not exist and you
have an idea to make a radically better kind of sewing machine. If you
invested the time to develop your idea into a working invention, the existing
s</p><p>3 0.20868023 <a title="37-lsi-3" href="../nathan_marz_storm-2014/nathan_marz_storm-2014-02-12-Interview_with_%22Programmer_Magazine%22.html">39 nathan marz storm-2014-02-12-Interview with "Programmer Magazine"</a></p>
<p>Introduction: I wasrecently interviewedfor "Programmer Magazine", a Chinese magazine. The
interview was published in Chinese, but a lot of people told me they'd like to
see the English version of the interview. Due to the Google translation being,
ahem, a little iffy, I decided to just publish the original English version on
my blog. Hope you enjoy!What drew you to programming and what was the first
interesting program you wrote?I started programming when I was 10 years old on
my TI-82 graphing calculator. Initially I started programming because I wanted
to make games on my calculator – and also because I was bored in math class
:D. The first interesting game I made on my calculator was an archery game
where you'd shoot arrows at moving targets. You'd get points for hitting more
targets or completing all the targets faster. A couple years later I graduated
to programming the TI-89 which was a huge upgrade in power. I remember how the
TI-82 only let you have 26 variables (for the characters 'a' throu</p><p>4 0.13823937 <a title="37-lsi-4" href="../nathan_marz_storm-2012/nathan_marz_storm-2012-02-06-Suffering-oriented_programming.html">33 nathan marz storm-2012-02-06-Suffering-oriented programming</a></p>
<p>Introduction: Someone asked me an interesting question the other day: "How did you justify
taking such a huge risk on buildingStormwhile working on astartup?" (Storm is
a realtime computation system). I can see how from an outsider's perspective
investing in such a massive project seems extremely risky for a startup. From
my perspective, though, building Storm wasn't risky at all. It was
challenging, but not risky.I follow a style of development that greatly
reduces the risk of big projects like Storm. I call this style "suffering-
oriented programming." Suffering-oriented programming can be summarized like
so: don't build technology unless you feel the pain of not having it. It
applies to the big, architectural decisions as well as the smaller everyday
programming decisions. Suffering-oriented programming greatly reduces risk by
ensuring that you're always working on something important, and it ensures
that you are well-versed in a problem space before attempting a large
investment.I have a mantra</p><p>5 0.1367234 <a title="37-lsi-5" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-03-04-Introducing_%22Nanny%22_-_a_really_simple_dependency_management_tool.html">7 nathan marz storm-2010-03-04-Introducing "Nanny" - a really simple dependency management tool</a></p>
<p>Introduction: Dependency management in software projects is a pretty simple problem when you
think about it. A tool to manage dependencies just needs to do three
things:Provide a mechanism to specify the direct dependencies to a
projectDownload the transitive closure of dependencies to a projectPublish
packages that can be used as a dependency to other projectsSome languages have
good dependency management systems - for example, rubygems. Others, like Java,
have tools like Maven which I would call a complex solution to a simple
problem. You shouldn't need to buy abookto understand the solution to such a
simple problem. Plus, these dependency management systems are all language
specific.I've seen companies do crazy things to manage their dependencies. One
company, to manage their jar files, would put all the jars that any project
might need in a special "jars" project. You would then need to setup a
JARS_HOME environment variable and be sure to update the jars project if you
need any of the dependenc</p><p>6 0.13098775 <a title="37-lsi-6" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-08-20-5_Tips_for_Thinking_Under_Uncertainty.html">21 nathan marz storm-2010-08-20-5 Tips for Thinking Under Uncertainty</a></p>
<p>7 0.12912877 <a title="37-lsi-7" href="../nathan_marz_storm-2012/nathan_marz_storm-2012-09-19-Storm%27s_1st_birthday.html">34 nathan marz storm-2012-09-19-Storm's 1st birthday</a></p>
<p>8 0.10928837 <a title="37-lsi-8" href="../nathan_marz_storm-2011/nathan_marz_storm-2011-10-13-How_to_beat_the_CAP_theorem.html">31 nathan marz storm-2011-10-13-How to beat the CAP theorem</a></p>
<p>9 0.0913091 <a title="37-lsi-9" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-07-12-My_experience_as_the_first_employee_of_a_Y_Combinator_startup.html">19 nathan marz storm-2010-07-12-My experience as the first employee of a Y Combinator startup</a></p>
<p>10 0.090102583 <a title="37-lsi-10" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-01-03-Tips_for_Optimizing_Cascading_Flows.html">2 nathan marz storm-2010-01-03-Tips for Optimizing Cascading Flows</a></p>
<p>11 0.090009034 <a title="37-lsi-11" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-06-16-Your_company_has_a_knowledge_debt_problem.html">18 nathan marz storm-2010-06-16-Your company has a knowledge debt problem</a></p>
<p>12 0.087828301 <a title="37-lsi-12" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-05-08-News_Feed_in_38_lines_of_code_using_Cascalog.html">16 nathan marz storm-2010-05-08-News Feed in 38 lines of code using Cascalog</a></p>
<p>13 0.086680137 <a title="37-lsi-13" href="../nathan_marz_storm-2014/nathan_marz_storm-2014-05-10-Why_we_in_tech_must_support_Lawrence_Lessig.html">41 nathan marz storm-2014-05-10-Why we in tech must support Lawrence Lessig</a></p>
<p>14 0.08573205 <a title="37-lsi-14" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-03-10-Thrift_%2B_Graphs_%3D_Strong%2C_flexible_schemas_on_Hadoop.html">9 nathan marz storm-2010-03-10-Thrift + Graphs = Strong, flexible schemas on Hadoop</a></p>
<p>15 0.085184693 <a title="37-lsi-15" href="../nathan_marz_storm-2009/nathan_marz_storm-2009-12-28-The_mathematics_behind_Hadoop-based_systems.html">1 nathan marz storm-2009-12-28-The mathematics behind Hadoop-based systems</a></p>
<p>16 0.079022996 <a title="37-lsi-16" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-10-05-How_to_get_a_job_at_a_kick-ass_startup_%28for_programmers%29.html">22 nathan marz storm-2010-10-05-How to get a job at a kick-ass startup (for programmers)</a></p>
<p>17 0.076132566 <a title="37-lsi-17" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-01-13-Mimi_Silbert%3A_the_greatest_hacker_in_the_world.html">3 nathan marz storm-2010-01-13-Mimi Silbert: the greatest hacker in the world</a></p>
<p>18 0.074968509 <a title="37-lsi-18" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-10-27-Fastest_Viable_Product%3A_Investing_in_Speed_at_a_Startup.html">23 nathan marz storm-2010-10-27-Fastest Viable Product: Investing in Speed at a Startup</a></p>
<p>19 0.073645622 <a title="37-lsi-19" href="../nathan_marz_storm-2014/nathan_marz_storm-2014-02-24-The_inexplicable_rise_of_open_floor_plans_in_tech_companies.html">40 nathan marz storm-2014-02-24-The inexplicable rise of open floor plans in tech companies</a></p>
<p>20 0.069923826 <a title="37-lsi-20" href="../nathan_marz_storm-2013/nathan_marz_storm-2013-04-12-Break_into_Silicon_Valley_with_a_blog.html">38 nathan marz storm-2013-04-12-Break into Silicon Valley with a blog</a></p>
<br/>
<h2>similar blogs computed by <a title="lda-model" href="../home/nathan_marz_storm_lda.html">lda model</a></h2><h3>lda for this blog:</h3><p>topicId topicWeight</p>
<p>[(0, 0.023), (5, 0.022), (10, 0.036), (21, 0.52), (26, 0.023), (33, 0.016), (41, 0.04), (48, 0.017), (59, 0.053), (61, 0.012), (68, 0.046), (76, 0.017), (82, 0.035), (88, 0.04), (99, 0.023)]</p>
<h3>similar blogs list:</h3><p>simIndex simValue blogId blogTitle</p>
<p>same-blog 1 0.98037171 <a title="37-lda-1" href="../nathan_marz_storm-2013/nathan_marz_storm-2013-04-02-Principles_of_Software_Engineering%2C_Part_1.html">37 nathan marz storm-2013-04-02-Principles of Software Engineering, Part 1</a></p>
<p>Introduction: This is the first in a series of posts on the principles of software
engineering. There's far more to software engineering than just "making
computers do stuff" – while that phrase is accurate, it does not come close to
describing what's involved in making robust, reliable software. I will use my
experience building large scale systems to inform a first principles approach
to defining what it is we do – or should be doing – as software engineers. I'm
not interested in tired debates like dynamic vs. static languages – instead, I
intend to explore the really core aspects of software engineering.The first
order of business is to define what software engineering even is in the first
place. Software engineering is the construction of software that produces some
desired output for some range of inputs. The inputs to software are more than
just method parameters: they include the hardware on which it's running, the
rate at which it receives data, and anything else that influences the
operatio</p><p>2 0.22122718 <a title="37-lda-2" href="../nathan_marz_storm-2014/nathan_marz_storm-2014-02-12-Interview_with_%22Programmer_Magazine%22.html">39 nathan marz storm-2014-02-12-Interview with "Programmer Magazine"</a></p>
<p>Introduction: I wasrecently interviewedfor "Programmer Magazine", a Chinese magazine. The
interview was published in Chinese, but a lot of people told me they'd like to
see the English version of the interview. Due to the Google translation being,
ahem, a little iffy, I decided to just publish the original English version on
my blog. Hope you enjoy!What drew you to programming and what was the first
interesting program you wrote?I started programming when I was 10 years old on
my TI-82 graphing calculator. Initially I started programming because I wanted
to make games on my calculator – and also because I was bored in math class
:D. The first interesting game I made on my calculator was an archery game
where you'd shoot arrows at moving targets. You'd get points for hitting more
targets or completing all the targets faster. A couple years later I graduated
to programming the TI-89 which was a huge upgrade in power. I remember how the
TI-82 only let you have 26 variables (for the characters 'a' throu</p><p>3 0.20217407 <a title="37-lda-3" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-03-10-Thrift_%2B_Graphs_%3D_Strong%2C_flexible_schemas_on_Hadoop.html">9 nathan marz storm-2010-03-10-Thrift + Graphs = Strong, flexible schemas on Hadoop</a></p>
<p>Introduction: There are a lot of misconceptions about what Hadoop is useful for and what
kind of data you can put in it. A lot of people think that Hadoop is meant for
unstructured data like log files. While Hadoop is great for log files, it's
alsofantasticfor strongly typed, structured data.In this post I'll discuss how
you can use a tool likeThriftto store strongly typed data in Hadoop while
retaining the flexibility to evolve your schema. We'll look at graph-based
schemas and see why they are an ideal fit for many Hadoop-based
applications.OK, so what kind of "structured" data can you put in
Hadoop?Anything! AtBackTypewe put data about news, conversations, and people
into Hadoop as structured objects. You can easily push structured information
about social graphs, financial information, or anything you want into Hadoop.
That sounds all well and good, but why not just use JSON as the data
format?JSON doesn't give you a real schema and doesn't protect against data
inconsistency. For example, if you</p><p>4 0.17567511 <a title="37-lda-4" href="../nathan_marz_storm-2011/nathan_marz_storm-2011-10-13-How_to_beat_the_CAP_theorem.html">31 nathan marz storm-2011-10-13-How to beat the CAP theorem</a></p>
<p>Introduction: The CAP theorem states a database cannot guarantee consistency, availability,
and partition-tolerance at the same time. But you can't sacrifice partition-
tolerance (seehereandhere), so you must make a tradeoff between availability
and consistency. Managing this tradeoff is a central focus of the NoSQL
movement.Consistency means that after you do a successful write, future reads
will always take that write into account. Availability means that you can
always read and write to the system. During a partition, you can only have one
of these properties.Systems that choose consistency over availability have to
deal with some awkward issues. What do you do when the database isn't
available? You can try buffering writes for later, but you risk losing those
writes if you lose the machine with the buffer. Also, buffering writes can be
a form of inconsistency because a client thinks a write has succeeded but the
write isn't in the database yet. Alternatively, you can return errors back to
the cl</p><p>5 0.16089089 <a title="37-lda-5" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-06-16-Your_company_has_a_knowledge_debt_problem.html">18 nathan marz storm-2010-06-16-Your company has a knowledge debt problem</a></p>
<p>Introduction: When your company lacks experience in tools and techniques that can make it
more productive, your company has knowledge debt.Companies tend to operate in
ways that exacerbate their knowledge debt problem. Consider this fairly
typical job ad:Initech is seeking an experienced Software Engineer to jointhe
engineering team.Responsibilities* Design core, back-end software components*
Analyze and improve efficiency, scalability, and stabilityof various system
resourcesRequirements* M.S. Computer Science or related field preferred* 2+
years of Java experience* Expert in relational data modeling and
queryoptimization using MySQLI would posit a guess that this company uses Java
for the majority of its work and uses MySQL on the back-end. Naturally, the
company wants to recruit people who share that skill set and can "jump right
in" and contribute.This mindset is fundamentally flawed. A company should be
hiring for problem solving skills, programming ability, and cultural fit, not
for any specif</p><p>6 0.14734286 <a title="37-lda-6" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-07-12-My_experience_as_the_first_employee_of_a_Y_Combinator_startup.html">19 nathan marz storm-2010-07-12-My experience as the first employee of a Y Combinator startup</a></p>
<p>7 0.14480036 <a title="37-lda-7" href="../nathan_marz_storm-2012/nathan_marz_storm-2012-02-06-Suffering-oriented_programming.html">33 nathan marz storm-2012-02-06-Suffering-oriented programming</a></p>
<p>8 0.1400663 <a title="37-lda-8" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-03-04-Introducing_%22Nanny%22_-_a_really_simple_dependency_management_tool.html">7 nathan marz storm-2010-03-04-Introducing "Nanny" - a really simple dependency management tool</a></p>
<p>9 0.13374402 <a title="37-lda-9" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-04-14-Introducing_Cascalog%3A_a_Clojure-based_query_language_for_Hadoop.html">13 nathan marz storm-2010-04-14-Introducing Cascalog: a Clojure-based query language for Hadoop</a></p>
<p>10 0.13342606 <a title="37-lda-10" href="../nathan_marz_storm-2011/nathan_marz_storm-2011-01-19-Inglourious_Software_Patents.html">29 nathan marz storm-2011-01-19-Inglourious Software Patents</a></p>
<p>11 0.11511033 <a title="37-lda-11" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-10-27-Fastest_Viable_Product%3A_Investing_in_Speed_at_a_Startup.html">23 nathan marz storm-2010-10-27-Fastest Viable Product: Investing in Speed at a Startup</a></p>
<p>12 0.1131241 <a title="37-lda-12" href="../nathan_marz_storm-2013/nathan_marz_storm-2013-04-12-Break_into_Silicon_Valley_with_a_blog.html">38 nathan marz storm-2013-04-12-Break into Silicon Valley with a blog</a></p>
<p>13 0.11095551 <a title="37-lda-13" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-10-05-How_to_get_a_job_at_a_kick-ass_startup_%28for_programmers%29.html">22 nathan marz storm-2010-10-05-How to get a job at a kick-ass startup (for programmers)</a></p>
<p>14 0.10995395 <a title="37-lda-14" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-04-10-Fun_with_equality_in_Clojure.html">12 nathan marz storm-2010-04-10-Fun with equality in Clojure</a></p>
<p>15 0.10972136 <a title="37-lda-15" href="../nathan_marz_storm-2014/nathan_marz_storm-2014-05-10-Why_we_in_tech_must_support_Lawrence_Lessig.html">41 nathan marz storm-2014-05-10-Why we in tech must support Lawrence Lessig</a></p>
<p>16 0.10875528 <a title="37-lda-16" href="../nathan_marz_storm-2014/nathan_marz_storm-2014-02-24-The_inexplicable_rise_of_open_floor_plans_in_tech_companies.html">40 nathan marz storm-2014-02-24-The inexplicable rise of open floor plans in tech companies</a></p>
<p>17 0.10462409 <a title="37-lda-17" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-03-08-Follow-up_to_%22The_mathematics_behind_Hadoop-based_systems%22.html">8 nathan marz storm-2010-03-08-Follow-up to "The mathematics behind Hadoop-based systems"</a></p>
<p>18 0.10249478 <a title="37-lda-18" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-12-06-You_Are_a_Product.html">25 nathan marz storm-2010-12-06-You Are a Product</a></p>
<p>19 0.097615726 <a title="37-lda-19" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-08-20-5_Tips_for_Thinking_Under_Uncertainty.html">21 nathan marz storm-2010-08-20-5 Tips for Thinking Under Uncertainty</a></p>
<p>20 0.09656816 <a title="37-lda-20" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-01-13-Mimi_Silbert%3A_the_greatest_hacker_in_the_world.html">3 nathan marz storm-2010-01-13-Mimi Silbert: the greatest hacker in the world</a></p>
<br/><br/><br/>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-48522588-1', 'makerhacker.github.io');
ga('send', 'pageview');
</script>

</body>
</html>
