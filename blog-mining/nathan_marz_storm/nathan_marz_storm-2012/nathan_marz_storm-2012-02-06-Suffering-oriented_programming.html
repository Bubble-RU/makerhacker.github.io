<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>33 nathan marz storm-2012-02-06-Suffering-oriented programming</title>
</head>

<body>
<p><a title="nathan_marz_storm" href="../nathan_marz_storm_home.html">nathan_marz_storm</a> <a title="nathan_marz_storm-2012" href="../home/nathan_marz_storm-2012_home.html">nathan_marz_storm-2012</a> <a title="nathan_marz_storm-2012-33" href="#">nathan_marz_storm-2012-33</a> knowledge-graph by maker-knowledge-mining</p><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- maker adsense -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-5027806277543591"
     data-ad-slot="4192012269"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>33 nathan marz storm-2012-02-06-Suffering-oriented programming</h1>
<br/><h2>meta infos for this blog</h2><p>Source: <a title="nathan_marz_storm-2012-33-html" href="http://nathanmarz.com//blog/suffering-oriented-programming.html">html</a></p><p>Introduction: Someone asked me an interesting question the other day: "How did you justify taking such a huge risk on building  Storm  while working on a  startup ?" (Storm is a realtime computation system). I can see how from an outsider's perspective investing in such a massive project seems extremely risky for a startup. From my perspective, though, building Storm wasn't risky at all. It was challenging, but not risky.
 
I follow a style of development that greatly reduces the risk of big projects like Storm. I call this style "suffering-oriented programming." Suffering-oriented programming can be summarized like so: don't build technology unless you feel the pain of not having it. It applies to the big, architectural decisions as well as the smaller everyday programming decisions. Suffering-oriented programming greatly reduces risk by ensuring that you're always working on something important, and it ensures that you are well-versed in a problem space before attempting a large investment.
 
I ha</p><br/><h2>Summary: the most important sentenses genereted by tfidf model</h2><p>sentIndex sentText sentNum sentScore</p><p>1 Suffering-oriented programming greatly reduces risk by ensuring that you're always working on something important, and it ensures that you are well-versed in a problem space before attempting a large investment. [sent-10, score-0.568]
</p><p>2 "   First make it possible   When encountering a problem domain with which you're unfamiliar, it's a mistake to try to build a "general" or "extensible" solution right off the bat. [sent-14, score-0.671]
</p><p>3 You just don't understand the problem domain well enough to anticipate what your needs will be in the future. [sent-15, score-0.554]
</p><p>4 You'll make things generic that needn't be, adding complexity and wasting time. [sent-16, score-0.455]
</p><p>5 As you're hacking things out, you'll learn more and more about the intricacies of the problem space. [sent-19, score-0.596]
</p><p>6 The "make it possible" phase for Storm was one year of hacking out a stream processing system using queues and workers. [sent-20, score-0.826]
</p><p>7 At the same time, developing our product drove us to discover new use cases in the "realtime computation" problem space. [sent-29, score-0.49]
</p><p>8 Then make it beautiful   You develop a "map" of the problem space as you explore it by hacking things out. [sent-35, score-0.868]
</p><p>9 Over time, you acquire more and more use cases within the problem domain and develop a deep understanding of the intricacies of building these systems. [sent-36, score-1.092]
</p><p>10 The key to developing the "beautiful" solution is figuring out the  simplest  set of abstractions that solve the concrete use cases you already have. [sent-38, score-0.575]
</p><p>11 As a rule of thumb, the bigger the investment you're trying to make, the deeper you need to understand the problem domain and the more diverse your use cases need to be. [sent-40, score-0.73]
</p><p>12 "Making it beautiful" is where you use your design and abstraction skills to distill the problem space into simple abstractions that can be composed together. [sent-42, score-0.574]
</p><p>13 I view the development of beautiful abstractions as similar to statistical regression: you have a set of points on a graph (your use cases) and you're looking for the simplest curve that fits those points (a set of abstractions). [sent-43, score-0.88]
</p><p>14 A big part of making it beautiful is understanding the performance and resource characteristics of the problem space. [sent-46, score-0.855]
</p><p>15 This is one of the intricacies you learn in the "making it possible" phase, and you should take advantage of that learning when designing your beautiful solution. [sent-47, score-0.475]
</p><p>16 With Storm, I distilled the realtime computation problem domain into a small set of abstractions: streams, spouts, bolts, and topologies. [sent-48, score-0.714]
</p><p>17 The beautiful systems you build give you new capabilities, which allow you to "make it possible" in new and deeper areas of the problem space. [sent-64, score-0.66]
</p><p>18 By its nature, hacking things out in a problem domain you don't understand so well and constantly iterating can lead to some sloppy code. [sent-71, score-0.73]
</p><p>19 Then you learn about making generic abstractions and using encapsulation to make it easier to reason about systems. [sent-81, score-0.601]
</p><p>20 It recognizes that attempts to make things generic without a deep understanding of the problem domain will lead to complexity and waste. [sent-84, score-1.087]
</p>
<br/>
<h2>similar blogs computed by tfidf model</h2><h3>tfidf for this blog:</h3><p>wordName wordTfidf (topN-words)</p>
<p>[('beautiful', 0.3), ('storm', 0.241), ('domain', 0.24), ('abstractions', 0.21), ('problem', 0.21), ('cases', 0.187), ('stream', 0.18), ('queues', 0.173), ('realtime', 0.154), ('phase', 0.139), ('complexity', 0.139), ('generic', 0.139), ('programming', 0.131), ('processing', 0.122), ('hacking', 0.12), ('computation', 0.11), ('understanding', 0.11), ('anticipate', 0.104), ('risk', 0.097), ('use', 0.093), ('system', 0.092), ('things', 0.091), ('allow', 0.09), ('acquire', 0.09), ('intricacies', 0.09), ('workers', 0.09), ('reach', 0.088), ('make', 0.086), ('characteristics', 0.085), ('concrete', 0.085), ('curve', 0.085), ('guaranteeing', 0.085), ('risky', 0.085), ('learn', 0.085), ('making', 0.081), ('possible', 0.075), ('deep', 0.072), ('reduces', 0.069), ('direct', 0.069), ('pain', 0.069), ('streams', 0.069), ('extensible', 0.069), ('resource', 0.069), ('sloppy', 0.069), ('points', 0.066), ('fast', 0.066), ('space', 0.061), ('learned', 0.061), ('build', 0.06), ('graph', 0.06)]</p>
<h3>similar blogs list:</h3><p>simIndex simValue blogId blogTitle</p>
<p>same-blog 1 1.0000004 <a title="33-tfidf-1" href="../nathan_marz_storm-2012/nathan_marz_storm-2012-02-06-Suffering-oriented_programming.html">33 nathan marz storm-2012-02-06-Suffering-oriented programming</a></p>
<p>Introduction: Someone asked me an interesting question the other day: "How did you justify taking such a huge risk on building  Storm  while working on a  startup ?" (Storm is a realtime computation system). I can see how from an outsider's perspective investing in such a massive project seems extremely risky for a startup. From my perspective, though, building Storm wasn't risky at all. It was challenging, but not risky.
 
I follow a style of development that greatly reduces the risk of big projects like Storm. I call this style "suffering-oriented programming." Suffering-oriented programming can be summarized like so: don't build technology unless you feel the pain of not having it. It applies to the big, architectural decisions as well as the smaller everyday programming decisions. Suffering-oriented programming greatly reduces risk by ensuring that you're always working on something important, and it ensures that you are well-versed in a problem space before attempting a large investment.
 
I ha</p><p>2 0.31853619 <a title="33-tfidf-2" href="../nathan_marz_storm-2014/nathan_marz_storm-2014-02-12-Interview_with_%22Programmer_Magazine%22.html">39 nathan marz storm-2014-02-12-Interview with "Programmer Magazine"</a></p>
<p>Introduction: I was  recently interviewed  for "Programmer Magazine", a Chinese magazine. The interview was published in Chinese, but a lot of people told me they'd like to see the English version of the interview. Due to the Google translation being, ahem, a little iffy, I decided to just publish the original English version on my blog. Hope you enjoy! 
  What drew you to programming and what was the first interesting program you wrote?  
I started programming when I was 10 years old on my TI-82 graphing calculator. Initially I started programming because I wanted to make games on my calculator – and also because I was bored in math class :D. The first interesting game I made on my calculator was an archery game where you'd shoot arrows at moving targets. You'd get points for hitting more targets or completing all the targets faster. A couple years later I graduated to programming the TI-89 which was a huge upgrade in power. I remember how the TI-82 only let you have 26 variables (for the character</p><p>3 0.21880129 <a title="33-tfidf-3" href="../nathan_marz_storm-2012/nathan_marz_storm-2012-09-19-Storm%27s_1st_birthday.html">34 nathan marz storm-2012-09-19-Storm's 1st birthday</a></p>
<p>Introduction: Storm  was open-sourced exactly one year ago today. It's been an action-packed year for Storm, to say the least. Here's some of the exciting stuff that's happened over the past year:
  
 27 companies have publicized that they're  using Storm in production . I know of at least a few more companies using it that haven't published anything yet. 
 O'Reilly  published a book  on Storm. 
 The  Storm mailing list  has over 1300 members, with over 500 messages per month. 
 The  @stormprocessor  account has over 1200 followers. 
 More than 4000 people have starred the project  on Github . 
 There's a  regular Storm meetup  in the Bay Area with over 230 members. I've also seen lots of Storm-focused meetups happen all over the world over the past year. 
 29 people all over the world have contributed to the codebase 
 We released  Trident , a high level abstraction for realtime computation, that is a major leap forward in what's possible in realtime. 
 Libraries have been released integrating Stor</p><p>4 0.18491732 <a title="33-tfidf-4" href="../nathan_marz_storm-2011/nathan_marz_storm-2011-10-13-How_to_beat_the_CAP_theorem.html">31 nathan marz storm-2011-10-13-How to beat the CAP theorem</a></p>
<p>Introduction: The CAP theorem states a database cannot guarantee consistency, availability, and partition-tolerance at the same time. But you can't sacrifice partition-tolerance (see  here  and  here ), so you must make a tradeoff between availability and consistency. Managing this tradeoff is a central focus of the NoSQL movement.
 
Consistency means that after you do a successful write, future reads will always take that write into account. Availability means that you can always read and write to the system. During a partition, you can only have one of these properties.
 
Systems that choose consistency over availability have to deal with some awkward issues. What do you do when the database isn't available? You can try buffering writes for later, but you risk losing those writes if you lose the machine with the buffer. Also, buffering writes can be a form of inconsistency because a client thinks a write has succeeded but the write isn't in the database yet. Alternatively, you can return errors ba</p><p>5 0.11195478 <a title="33-tfidf-5" href="../nathan_marz_storm-2013/nathan_marz_storm-2013-04-02-Principles_of_Software_Engineering%2C_Part_1.html">37 nathan marz storm-2013-04-02-Principles of Software Engineering, Part 1</a></p>
<p>Introduction: This is the first in a series of posts on the principles of software engineering. There's far more to software engineering than just "making computers do stuff" – while that phrase is accurate, it does not come close to describing what's involved in making robust, reliable software. I will use my experience building large scale systems to inform a first principles approach to defining what it is we do – or should be doing – as software engineers. I'm not interested in tired debates like dynamic vs. static languages – instead, I intend to explore the really core aspects of software engineering. 
 
The first order of business is to define what software engineering even is in the first place. Software engineering is the construction of software that produces some desired output for some range of inputs. The inputs to software are more than just method parameters: they include the hardware on which it's running, the rate at which it receives data, and anything else that influences the oper</p><p>6 0.095923632 <a title="33-tfidf-6" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-07-12-My_experience_as_the_first_employee_of_a_Y_Combinator_startup.html">19 nathan marz storm-2010-07-12-My experience as the first employee of a Y Combinator startup</a></p>
<p>7 0.09391652 <a title="33-tfidf-7" href="../nathan_marz_storm-2011/nathan_marz_storm-2011-03-29-My_talks_at_POSSCON.html">30 nathan marz storm-2011-03-29-My talks at POSSCON</a></p>
<p>8 0.079001531 <a title="33-tfidf-8" href="../nathan_marz_storm-2013/nathan_marz_storm-2013-04-01-My_new_startup.html">36 nathan marz storm-2013-04-01-My new startup</a></p>
<p>9 0.074905932 <a title="33-tfidf-9" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-10-05-How_to_get_a_job_at_a_kick-ass_startup_%28for_programmers%29.html">22 nathan marz storm-2010-10-05-How to get a job at a kick-ass startup (for programmers)</a></p>
<p>10 0.069815084 <a title="33-tfidf-10" href="../nathan_marz_storm-2013/nathan_marz_storm-2013-04-12-Break_into_Silicon_Valley_with_a_blog.html">38 nathan marz storm-2013-04-12-Break into Silicon Valley with a blog</a></p>
<p>11 0.069071256 <a title="33-tfidf-11" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-07-30-You_should_blog_even_if_you_have_no_readers.html">20 nathan marz storm-2010-07-30-You should blog even if you have no readers</a></p>
<p>12 0.066994049 <a title="33-tfidf-12" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-01-03-Tips_for_Optimizing_Cascading_Flows.html">2 nathan marz storm-2010-01-03-Tips for Optimizing Cascading Flows</a></p>
<p>13 0.063408941 <a title="33-tfidf-13" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-03-04-Introducing_%22Nanny%22_-_a_really_simple_dependency_management_tool.html">7 nathan marz storm-2010-03-04-Introducing "Nanny" - a really simple dependency management tool</a></p>
<p>14 0.063076667 <a title="33-tfidf-14" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-10-27-Fastest_Viable_Product%3A_Investing_in_Speed_at_a_Startup.html">23 nathan marz storm-2010-10-27-Fastest Viable Product: Investing in Speed at a Startup</a></p>
<p>15 0.062585562 <a title="33-tfidf-15" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-12-06-You_Are_a_Product.html">25 nathan marz storm-2010-12-06-You Are a Product</a></p>
<p>16 0.055358585 <a title="33-tfidf-16" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-01-13-Mimi_Silbert%3A_the_greatest_hacker_in_the_world.html">3 nathan marz storm-2010-01-13-Mimi Silbert: the greatest hacker in the world</a></p>
<p>17 0.055231616 <a title="33-tfidf-17" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-08-20-5_Tips_for_Thinking_Under_Uncertainty.html">21 nathan marz storm-2010-08-20-5 Tips for Thinking Under Uncertainty</a></p>
<p>18 0.052409135 <a title="33-tfidf-18" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-06-16-Your_company_has_a_knowledge_debt_problem.html">18 nathan marz storm-2010-06-16-Your company has a knowledge debt problem</a></p>
<p>19 0.052009627 <a title="33-tfidf-19" href="../nathan_marz_storm-2014/nathan_marz_storm-2014-02-24-The_inexplicable_rise_of_open_floor_plans_in_tech_companies.html">40 nathan marz storm-2014-02-24-The inexplicable rise of open floor plans in tech companies</a></p>
<p>20 0.051089037 <a title="33-tfidf-20" href="../nathan_marz_storm-2014/nathan_marz_storm-2014-05-10-Why_we_in_tech_must_support_Lawrence_Lessig.html">41 nathan marz storm-2014-05-10-Why we in tech must support Lawrence Lessig</a></p>
<br/>
<h2>similar blogs computed by <a title="lsi-model" href="../home/nathan_marz_storm_lsi.html">lsi model</a></h2><h3>lsi for this blog:</h3><p>topicId topicWeight</p>
<p>[(0, 0.409), (1, 0.131), (2, -0.019), (3, 0.459), (4, -0.103), (5, 0.13), (6, 0.003), (7, -0.124), (8, 0.178), (9, -0.033), (10, 0.017), (11, 0.002), (12, -0.164), (13, -0.038), (14, -0.151), (15, 0.043), (16, -0.095), (17, 0.096), (18, -0.045), (19, 0.023), (20, 0.068), (21, -0.115), (22, 0.05), (23, -0.022), (24, 0.075), (25, 0.004), (26, -0.052), (27, 0.053), (28, 0.027), (29, 0.07), (30, -0.059), (31, -0.354), (32, -0.231), (33, 0.155), (34, 0.028), (35, -0.122), (36, 0.303), (37, -0.018), (38, 0.32), (39, 0.022), (40, 0.029)]</p>
<h3>similar blogs list:</h3><p>simIndex simValue blogId blogTitle</p>
<p>same-blog 1 0.98928463 <a title="33-lsi-1" href="../nathan_marz_storm-2012/nathan_marz_storm-2012-02-06-Suffering-oriented_programming.html">33 nathan marz storm-2012-02-06-Suffering-oriented programming</a></p>
<p>Introduction: Someone asked me an interesting question the other day: "How did you justify taking such a huge risk on building  Storm  while working on a  startup ?" (Storm is a realtime computation system). I can see how from an outsider's perspective investing in such a massive project seems extremely risky for a startup. From my perspective, though, building Storm wasn't risky at all. It was challenging, but not risky.
 
I follow a style of development that greatly reduces the risk of big projects like Storm. I call this style "suffering-oriented programming." Suffering-oriented programming can be summarized like so: don't build technology unless you feel the pain of not having it. It applies to the big, architectural decisions as well as the smaller everyday programming decisions. Suffering-oriented programming greatly reduces risk by ensuring that you're always working on something important, and it ensures that you are well-versed in a problem space before attempting a large investment.
 
I ha</p><p>2 0.38807574 <a title="33-lsi-2" href="../nathan_marz_storm-2014/nathan_marz_storm-2014-02-12-Interview_with_%22Programmer_Magazine%22.html">39 nathan marz storm-2014-02-12-Interview with "Programmer Magazine"</a></p>
<p>Introduction: I was  recently interviewed  for "Programmer Magazine", a Chinese magazine. The interview was published in Chinese, but a lot of people told me they'd like to see the English version of the interview. Due to the Google translation being, ahem, a little iffy, I decided to just publish the original English version on my blog. Hope you enjoy! 
  What drew you to programming and what was the first interesting program you wrote?  
I started programming when I was 10 years old on my TI-82 graphing calculator. Initially I started programming because I wanted to make games on my calculator – and also because I was bored in math class :D. The first interesting game I made on my calculator was an archery game where you'd shoot arrows at moving targets. You'd get points for hitting more targets or completing all the targets faster. A couple years later I graduated to programming the TI-89 which was a huge upgrade in power. I remember how the TI-82 only let you have 26 variables (for the character</p><p>3 0.24914907 <a title="33-lsi-3" href="../nathan_marz_storm-2012/nathan_marz_storm-2012-09-19-Storm%27s_1st_birthday.html">34 nathan marz storm-2012-09-19-Storm's 1st birthday</a></p>
<p>Introduction: Storm  was open-sourced exactly one year ago today. It's been an action-packed year for Storm, to say the least. Here's some of the exciting stuff that's happened over the past year:
  
 27 companies have publicized that they're  using Storm in production . I know of at least a few more companies using it that haven't published anything yet. 
 O'Reilly  published a book  on Storm. 
 The  Storm mailing list  has over 1300 members, with over 500 messages per month. 
 The  @stormprocessor  account has over 1200 followers. 
 More than 4000 people have starred the project  on Github . 
 There's a  regular Storm meetup  in the Bay Area with over 230 members. I've also seen lots of Storm-focused meetups happen all over the world over the past year. 
 29 people all over the world have contributed to the codebase 
 We released  Trident , a high level abstraction for realtime computation, that is a major leap forward in what's possible in realtime. 
 Libraries have been released integrating Stor</p><p>4 0.24595979 <a title="33-lsi-4" href="../nathan_marz_storm-2011/nathan_marz_storm-2011-10-13-How_to_beat_the_CAP_theorem.html">31 nathan marz storm-2011-10-13-How to beat the CAP theorem</a></p>
<p>Introduction: The CAP theorem states a database cannot guarantee consistency, availability, and partition-tolerance at the same time. But you can't sacrifice partition-tolerance (see  here  and  here ), so you must make a tradeoff between availability and consistency. Managing this tradeoff is a central focus of the NoSQL movement.
 
Consistency means that after you do a successful write, future reads will always take that write into account. Availability means that you can always read and write to the system. During a partition, you can only have one of these properties.
 
Systems that choose consistency over availability have to deal with some awkward issues. What do you do when the database isn't available? You can try buffering writes for later, but you risk losing those writes if you lose the machine with the buffer. Also, buffering writes can be a form of inconsistency because a client thinks a write has succeeded but the write isn't in the database yet. Alternatively, you can return errors ba</p><p>5 0.1784838 <a title="33-lsi-5" href="../nathan_marz_storm-2013/nathan_marz_storm-2013-04-01-My_new_startup.html">36 nathan marz storm-2013-04-01-My new startup</a></p>
<p>Introduction: There's been a lot of speculation about what my new startup is doing, so I've decided to set the record straight and reveal all. We are working on one of the biggest problems on Earth, a problem that affects nearly every person on this planet. Our products will significantly improve the quality of life for billions of people.
 
We are going to revolutionize the bedsheet industry.
  
     
  
Think about it. There's been almost no innovation in bedsheets in thousands of years. There's nothing worse than waking up to discover one of the corners of your Egyptian cotton fitted sheets has slipped off the mattress. How is this not a solved problem yet? Why are we still using sheets with that annoying elastic in it to secure them to our mattresses? They slip all the time – and if you have a deep mattress, good luck finding sheets that even fit. You're just screwed.
 
Consider the impact of solving this problem, of a bedsheet product that  never  slips, that  always  stays secure on the mattre</p><p>6 0.1676154 <a title="33-lsi-6" href="../nathan_marz_storm-2013/nathan_marz_storm-2013-04-02-Principles_of_Software_Engineering%2C_Part_1.html">37 nathan marz storm-2013-04-02-Principles of Software Engineering, Part 1</a></p>
<p>7 0.16187274 <a title="33-lsi-7" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-07-12-My_experience_as_the_first_employee_of_a_Y_Combinator_startup.html">19 nathan marz storm-2010-07-12-My experience as the first employee of a Y Combinator startup</a></p>
<p>8 0.14614742 <a title="33-lsi-8" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-10-05-How_to_get_a_job_at_a_kick-ass_startup_%28for_programmers%29.html">22 nathan marz storm-2010-10-05-How to get a job at a kick-ass startup (for programmers)</a></p>
<p>9 0.13978402 <a title="33-lsi-9" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-01-13-Mimi_Silbert%3A_the_greatest_hacker_in_the_world.html">3 nathan marz storm-2010-01-13-Mimi Silbert: the greatest hacker in the world</a></p>
<p>10 0.12891763 <a title="33-lsi-10" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-01-03-Tips_for_Optimizing_Cascading_Flows.html">2 nathan marz storm-2010-01-03-Tips for Optimizing Cascading Flows</a></p>
<p>11 0.11760958 <a title="33-lsi-11" href="../nathan_marz_storm-2011/nathan_marz_storm-2011-03-29-My_talks_at_POSSCON.html">30 nathan marz storm-2011-03-29-My talks at POSSCON</a></p>
<p>12 0.11541726 <a title="33-lsi-12" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-10-27-Fastest_Viable_Product%3A_Investing_in_Speed_at_a_Startup.html">23 nathan marz storm-2010-10-27-Fastest Viable Product: Investing in Speed at a Startup</a></p>
<p>13 0.11415955 <a title="33-lsi-13" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-03-04-Introducing_%22Nanny%22_-_a_really_simple_dependency_management_tool.html">7 nathan marz storm-2010-03-04-Introducing "Nanny" - a really simple dependency management tool</a></p>
<p>14 0.11405587 <a title="33-lsi-14" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-06-16-Your_company_has_a_knowledge_debt_problem.html">18 nathan marz storm-2010-06-16-Your company has a knowledge debt problem</a></p>
<p>15 0.10999078 <a title="33-lsi-15" href="../nathan_marz_storm-2013/nathan_marz_storm-2013-04-12-Break_into_Silicon_Valley_with_a_blog.html">38 nathan marz storm-2013-04-12-Break into Silicon Valley with a blog</a></p>
<p>16 0.10904706 <a title="33-lsi-16" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-03-10-Thrift_%2B_Graphs_%3D_Strong%2C_flexible_schemas_on_Hadoop.html">9 nathan marz storm-2010-03-10-Thrift + Graphs = Strong, flexible schemas on Hadoop</a></p>
<p>17 0.10836838 <a title="33-lsi-17" href="../nathan_marz_storm-2014/nathan_marz_storm-2014-05-10-Why_we_in_tech_must_support_Lawrence_Lessig.html">41 nathan marz storm-2014-05-10-Why we in tech must support Lawrence Lessig</a></p>
<p>18 0.10465762 <a title="33-lsi-18" href="../nathan_marz_storm-2014/nathan_marz_storm-2014-02-24-The_inexplicable_rise_of_open_floor_plans_in_tech_companies.html">40 nathan marz storm-2014-02-24-The inexplicable rise of open floor plans in tech companies</a></p>
<p>19 0.10375202 <a title="33-lsi-19" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-08-20-5_Tips_for_Thinking_Under_Uncertainty.html">21 nathan marz storm-2010-08-20-5 Tips for Thinking Under Uncertainty</a></p>
<p>20 0.10219275 <a title="33-lsi-20" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-12-06-You_Are_a_Product.html">25 nathan marz storm-2010-12-06-You Are a Product</a></p>
<br/>
<h2>similar blogs computed by <a title="lda-model" href="../home/nathan_marz_storm_lda.html">lda model</a></h2><h3>lda for this blog:</h3><p>topicId topicWeight</p>
<p>[(0, 0.019), (5, 0.018), (10, 0.036), (26, 0.022), (41, 0.057), (48, 0.019), (59, 0.043), (68, 0.567), (76, 0.025), (82, 0.04), (88, 0.072)]</p>
<h3>similar blogs list:</h3><p>simIndex simValue blogId blogTitle</p>
<p>same-blog 1 0.98643702 <a title="33-lda-1" href="../nathan_marz_storm-2012/nathan_marz_storm-2012-02-06-Suffering-oriented_programming.html">33 nathan marz storm-2012-02-06-Suffering-oriented programming</a></p>
<p>Introduction: Someone asked me an interesting question the other day: "How did you justify taking such a huge risk on building  Storm  while working on a  startup ?" (Storm is a realtime computation system). I can see how from an outsider's perspective investing in such a massive project seems extremely risky for a startup. From my perspective, though, building Storm wasn't risky at all. It was challenging, but not risky.
 
I follow a style of development that greatly reduces the risk of big projects like Storm. I call this style "suffering-oriented programming." Suffering-oriented programming can be summarized like so: don't build technology unless you feel the pain of not having it. It applies to the big, architectural decisions as well as the smaller everyday programming decisions. Suffering-oriented programming greatly reduces risk by ensuring that you're always working on something important, and it ensures that you are well-versed in a problem space before attempting a large investment.
 
I ha</p><p>2 0.36398149 <a title="33-lda-2" href="../nathan_marz_storm-2014/nathan_marz_storm-2014-02-12-Interview_with_%22Programmer_Magazine%22.html">39 nathan marz storm-2014-02-12-Interview with "Programmer Magazine"</a></p>
<p>Introduction: I was  recently interviewed  for "Programmer Magazine", a Chinese magazine. The interview was published in Chinese, but a lot of people told me they'd like to see the English version of the interview. Due to the Google translation being, ahem, a little iffy, I decided to just publish the original English version on my blog. Hope you enjoy! 
  What drew you to programming and what was the first interesting program you wrote?  
I started programming when I was 10 years old on my TI-82 graphing calculator. Initially I started programming because I wanted to make games on my calculator – and also because I was bored in math class :D. The first interesting game I made on my calculator was an archery game where you'd shoot arrows at moving targets. You'd get points for hitting more targets or completing all the targets faster. A couple years later I graduated to programming the TI-89 which was a huge upgrade in power. I remember how the TI-82 only let you have 26 variables (for the character</p><p>3 0.35141051 <a title="33-lda-3" href="../nathan_marz_storm-2011/nathan_marz_storm-2011-10-13-How_to_beat_the_CAP_theorem.html">31 nathan marz storm-2011-10-13-How to beat the CAP theorem</a></p>
<p>Introduction: The CAP theorem states a database cannot guarantee consistency, availability, and partition-tolerance at the same time. But you can't sacrifice partition-tolerance (see  here  and  here ), so you must make a tradeoff between availability and consistency. Managing this tradeoff is a central focus of the NoSQL movement.
 
Consistency means that after you do a successful write, future reads will always take that write into account. Availability means that you can always read and write to the system. During a partition, you can only have one of these properties.
 
Systems that choose consistency over availability have to deal with some awkward issues. What do you do when the database isn't available? You can try buffering writes for later, but you risk losing those writes if you lose the machine with the buffer. Also, buffering writes can be a form of inconsistency because a client thinks a write has succeeded but the write isn't in the database yet. Alternatively, you can return errors ba</p><p>4 0.28585038 <a title="33-lda-4" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-03-04-Introducing_%22Nanny%22_-_a_really_simple_dependency_management_tool.html">7 nathan marz storm-2010-03-04-Introducing "Nanny" - a really simple dependency management tool</a></p>
<p>Introduction: Dependency management in software projects is a pretty simple problem when you think about it.  A tool to manage dependencies just needs to do three things:
  
 Provide a mechanism to specify the direct dependencies to a project 
 Download the transitive closure of dependencies to a project 
 Publish packages that can be used as a dependency to other projects 
  
Some languages have good dependency management systems - for example, rubygems. Others, like Java, have tools like Maven which I would call a complex solution to a simple problem. You shouldn't need to buy a  book  to understand the solution to such a simple problem. Plus, these dependency management systems are all language specific.
 
I've seen companies do crazy things to manage their dependencies. One company, to manage their jar files, would put all the jars that any project might need in a special "jars" project. You would then need to setup a JARS_HOME environment variable and be sure to update the jars project if you n</p><p>5 0.22801201 <a title="33-lda-5" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-03-10-Thrift_%2B_Graphs_%3D_Strong%2C_flexible_schemas_on_Hadoop.html">9 nathan marz storm-2010-03-10-Thrift + Graphs = Strong, flexible schemas on Hadoop</a></p>
<p>Introduction: There are a lot of misconceptions about what Hadoop is useful for and what kind of data you can put in it. A lot of people think that Hadoop is meant for unstructured data like log files. While Hadoop is great for log files, it's also  fantastic  for strongly typed, structured data.
 
In this post I'll discuss how you can use a tool like  Thrift  to store strongly typed data in Hadoop while retaining the flexibility to evolve your schema. We'll look at graph-based schemas and see why they are an ideal fit for many Hadoop-based applications.
 
 OK, so what kind of "structured" data can you put in Hadoop? 
 
Anything! At  BackType  we put data about news, conversations, and people into Hadoop as structured objects. You can easily push structured information about social graphs, financial information, or anything you want into Hadoop. Â  
 
 That sounds all well and good, but why not just use JSON as the data format? 
 
JSON doesn't give you a real schema and doesn't protect against data i</p><p>6 0.21999253 <a title="33-lda-6" href="../nathan_marz_storm-2011/nathan_marz_storm-2011-01-19-Inglourious_Software_Patents.html">29 nathan marz storm-2011-01-19-Inglourious Software Patents</a></p>
<p>7 0.2185902 <a title="33-lda-7" href="../nathan_marz_storm-2009/nathan_marz_storm-2009-12-28-The_mathematics_behind_Hadoop-based_systems.html">1 nathan marz storm-2009-12-28-The mathematics behind Hadoop-based systems</a></p>
<p>8 0.20990665 <a title="33-lda-8" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-01-13-Mimi_Silbert%3A_the_greatest_hacker_in_the_world.html">3 nathan marz storm-2010-01-13-Mimi Silbert: the greatest hacker in the world</a></p>
<p>9 0.20939019 <a title="33-lda-9" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-10-27-Fastest_Viable_Product%3A_Investing_in_Speed_at_a_Startup.html">23 nathan marz storm-2010-10-27-Fastest Viable Product: Investing in Speed at a Startup</a></p>
<p>10 0.20642915 <a title="33-lda-10" href="../nathan_marz_storm-2013/nathan_marz_storm-2013-04-02-Principles_of_Software_Engineering%2C_Part_1.html">37 nathan marz storm-2013-04-02-Principles of Software Engineering, Part 1</a></p>
<p>11 0.20463572 <a title="33-lda-11" href="../nathan_marz_storm-2014/nathan_marz_storm-2014-02-24-The_inexplicable_rise_of_open_floor_plans_in_tech_companies.html">40 nathan marz storm-2014-02-24-The inexplicable rise of open floor plans in tech companies</a></p>
<p>12 0.19392847 <a title="33-lda-12" href="../nathan_marz_storm-2013/nathan_marz_storm-2013-04-01-My_new_startup.html">36 nathan marz storm-2013-04-01-My new startup</a></p>
<p>13 0.18293135 <a title="33-lda-13" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-03-08-Follow-up_to_%22The_mathematics_behind_Hadoop-based_systems%22.html">8 nathan marz storm-2010-03-08-Follow-up to "The mathematics behind Hadoop-based systems"</a></p>
<p>14 0.17989443 <a title="33-lda-14" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-06-16-Your_company_has_a_knowledge_debt_problem.html">18 nathan marz storm-2010-06-16-Your company has a knowledge debt problem</a></p>
<p>15 0.16656137 <a title="33-lda-15" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-08-20-5_Tips_for_Thinking_Under_Uncertainty.html">21 nathan marz storm-2010-08-20-5 Tips for Thinking Under Uncertainty</a></p>
<p>16 0.16413561 <a title="33-lda-16" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-12-06-You_Are_a_Product.html">25 nathan marz storm-2010-12-06-You Are a Product</a></p>
<p>17 0.16214782 <a title="33-lda-17" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-04-14-Introducing_Cascalog%3A_a_Clojure-based_query_language_for_Hadoop.html">13 nathan marz storm-2010-04-14-Introducing Cascalog: a Clojure-based query language for Hadoop</a></p>
<p>18 0.1578099 <a title="33-lda-18" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-10-05-How_to_get_a_job_at_a_kick-ass_startup_%28for_programmers%29.html">22 nathan marz storm-2010-10-05-How to get a job at a kick-ass startup (for programmers)</a></p>
<p>19 0.15308796 <a title="33-lda-19" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-03-17-Proof_that_1_%3D_0_using_a_common_logical_fallacy.html">10 nathan marz storm-2010-03-17-Proof that 1 = 0 using a common logical fallacy</a></p>
<p>20 0.14824367 <a title="33-lda-20" href="../nathan_marz_storm-2010/nathan_marz_storm-2010-01-03-Tips_for_Optimizing_Cascading_Flows.html">2 nathan marz storm-2010-01-03-Tips for Optimizing Cascading Flows</a></p>
<br/><br/><br/>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-48522588-1', 'makerhacker.github.io');
ga('send', 'pageview');
</script>

</body>
</html>
