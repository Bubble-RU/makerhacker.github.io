<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>39 jmlr-2006-Inductive Synthesis of Functional Programs: An Explanation Based Generalization Approach     (Special Topic on Inductive Programming)</title>
</head>

<body>
<p><a title="jmlr" href="../jmlr_home.html">jmlr</a> <a title="jmlr-2006" href="../home/jmlr2006_home.html">jmlr2006</a> <a title="jmlr-2006-39" href="../jmlr2006/jmlr-2006-Inductive_Synthesis_of_Functional_Programs%3A_An_Explanation_Based_Generalization_Approach_%C2%A0%C2%A0%C2%A0%C2%A0%28Special_Topic_on_Inductive_Programming%29.html">jmlr2006-39</a> <a title="jmlr-2006-39-reference" href="#">jmlr2006-39-reference</a> knowledge-graph by maker-knowledge-mining</p><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- maker adsense -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-5027806277543591"
     data-ad-slot="4192012269"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>39 jmlr-2006-Inductive Synthesis of Functional Programs: An Explanation Based Generalization Approach     (Special Topic on Inductive Programming)</h1>
<br/><p>Source: <a title="jmlr-2006-39-pdf" href="http://jmlr.org/papers/volume7/kitzelmann06a/kitzelmann06a.pdf">pdf</a></p><p>Author: Emanuel Kitzelmann, Ute Schmid</p><p>Abstract: We describe an approach to the inductive synthesis of recursive equations from input/outputexamples which is based on the classical two-step approach to induction of functional Lisp programs of Summers (1977). In a ﬁrst step, I/O-examples are rewritten to traces which explain the outputs given the respective inputs based on a datatype theory. These traces can be integrated into one conditional expression which represents a non-recursive program. In a second step, this initial program term is generalized into recursive equations by searching for syntactical regularities in the term. Our approach extends the classical work in several aspects. The most important extensions are that we are able to induce a set of recursive equations in one synthesizing step, the equations may contain more than one recursive call, and additionally needed parameters are automatically introduced. Keywords: inductive program synthesis, inductive functional programming, explanation based generalization, recursive program schemes</p><br/>
<h2>reference text</h2><p>M. Berardi, A. Varlaro, and D. Malerba. On the eﬀect of caching in recursive theory learning. In R. Camacho, R. D. King, and A. Srinivasan, editors, Inductive Logic Programming: ILP 2004, pages 44–62. Springer, 2004. A. W. Biermann, G. Guiho, and Y. Kodratoﬀ, editors. Automatic Program Construction Techniques. Collier Macmillan, 1984. 452  An EBG Approach to Inductive Synthesis of Functional Programs  R. Mike Cameron-Jones and J. Ross Quinlan. Avoiding pitfalls when learning recursive theories. In IJCAI, pages 1050–1055. Morgan Kaufmann, 1993. N. Dershowitz and J.-P. Jouanaud. Rewrite systems. In J. Leeuwen, editor, Handbook of Theoretical Computer Science, volume B. Elsevier, 1990. P. Flener. Inductive logic program synthesis with DIALOGS. In S. Muggleton, editor, Proceedings of ILP’96, pages 175–198. Springer, 1997. P. Flener and D. Partridge. Inductive programming. Autom. Softw. Eng., 8(2):131–137, 2001. P. Flener and S. Yilmaz. Inductive synthesis of recursive logic programs: Achievements and prospects. Journal of Logic Programming, 41(2–3):141–195, 1999. E. Mark Gold. Language identiﬁcation in the limit. Information and Control, 10(5):447–474, 1967. E. Kitzelmann. Inductive functional program synthesis – a term-construction and folding approach. Master’s thesis, Dept. of Computer Science, TU Berlin, 2003. http://www.cogsys.wiai.uni-bamberg.de/kitzelmann/documents/thesis.ps. M. L. Lowry and R. D. McCarthy. Autmatic Software Design. MIT Press, Cambridge, Mass., 1991. D. Malerba. Learning recursive theories in the normal ILP setting. Fundamenta Informaticae, 57(1):39–77, 2003. S. Muggleton and L. De Raedt. Inductive logic programming: Theory and methods. Journal of Logic Programming, Special Issue on 10 Years of Logic Programming, 19-20:629–679, 1994. S. H. Muggleton and C. Feng. Eﬃcient induction of logic programs. In Proceedings of the First Conference on Algorithmic Learning Theory, pages 368–381, Tokyo, 1990. Ohmsha. R. Olsson. Inductive functional programming using incremental program transformation. Artiﬁcial Intelligence, 74(1):55–83, 1995. G. D. Plotkin. A note on inductive generalization. In Machine Intelligence, volume 5, pages 153–163. Edinburgh University Press, 1969. J. Ross Quinlan. Learning logical deﬁnitions from relations. Machine Learning, 5:239–266, 1990. M. R. K. Krishna Rao. Inductive inference of term rewriting systems from positive data. In Algorithmic Learning Theory, pages 69–82, 2004. M. R. K. Krishna Rao and A. Sattar. Polynomial-time learnability of logic programs with local variables from entailment. Theoretical Computer Science, 268(2):179–198, 2001. 453  Kitzelmann and Schmid  U. Schmid. Inductive Synthesis of Functional Programs – Universal Planning, Folding of Finite Programs, and Schema Abstraction by Analogical Reasoning. Springer, 2003. U. Schmid and F. Wysotzki. Applying inductive programm synthesis to macro learning. In Proc. 5th International Conference on Artiﬁcial Intelligence Planning and Scheduling (AIPS 2000), pages 371–378. AAAI Press, 2000. J. Schmidhuber. Optimal ordered problem solver. Machine Learning, 54(3):211–254, 2004. D. R. Smith. The synthesis of LISP programs from examples: A survery. In A. W. Biermann, G. Guiho, and Y. Kodratoﬀ, editors, Automatic Program Construction Techniques, pages 307–324. Macmillan, 1984. P. D. Summers. A methodology for LISP program construction from examples. Journal ACM, 24(1):162–175, 1977. L. G. Valiant. A theory of the learnable. In STOC ’84: Proceedings of the sixteenth annual ACM symposium on Theory of computing, pages 436–445, New York, NY, USA, 1984. ACM Press. F. Wysotzki and U. Schmid. Synthesis of recursive programs from ﬁnite examples by detection of macro-functions. Technical Report 01-2, Dept. of Computer Science, TU Berlin, Germany, 2001.  454</p>
<br/>
<br/><br/><br/>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-48522588-1', 'makerhacker.github.io');
ga('send', 'pageview');
</script>

</body>
</html>
