<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>62 jmlr-2005-Probabilistic Non-linear Principal Component Analysis with Gaussian Process Latent Variable Models</title>
</head>

<body>
<p><a title="jmlr" href="../jmlr_home.html">jmlr</a> <a title="jmlr-2005" href="../home/jmlr2005_home.html">jmlr2005</a> <a title="jmlr-2005-62" href="#">jmlr2005-62</a> knowledge-graph by maker-knowledge-mining</p><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- maker adsense -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-5027806277543591"
     data-ad-slot="4192012269"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>62 jmlr-2005-Probabilistic Non-linear Principal Component Analysis with Gaussian Process Latent Variable Models</h1>
<br/><p>Source: <a title="jmlr-2005-62-pdf" href="http://jmlr.org/papers/volume6/lawrence05a/lawrence05a.pdf">pdf</a></p><p>Author: Neil Lawrence</p><p>Abstract: Summarising a high dimensional data set with a low dimensional embedding is a standard approach for exploring its structure. In this paper we provide an overview of some existing techniques for discovering such embeddings. We then introduce a novel probabilistic interpretation of principal component analysis (PCA) that we term dual probabilistic PCA (DPPCA). The DPPCA model has the additional advantage that the linear mappings from the embedded space can easily be nonlinearised through Gaussian processes. We refer to this model as a Gaussian process latent variable model (GP-LVM). Through analysis of the GP-LVM objective function, we relate the model to popular spectral techniques such as kernel PCA and multidimensional scaling. We then review a practical algorithm for GP-LVMs in the context of large data sets and develop it to also handle discrete valued data and missing attributes. We demonstrate the model on a range of real-world and artiﬁcially generated data sets. Keywords: Gaussian processes, latent variable models, principal component analysis, spectral methods, unsupervised learning, visualisation</p><p>Reference: <a title="jmlr-2005-62-reference" href="../jmlr2005_reference/jmlr-2005-Probabilistic_Non-linear_Principal_Component_Analysis_with_Gaussian_Process_Latent_Variable_Models_reference.html">text</a></p><br/><h2>Summary: the most important sentenses genereted by tfidf model</h2><p>sentIndex sentText sentNum sentScore</p><p>1 We then introduce a novel probabilistic interpretation of principal component analysis (PCA) that we term dual probabilistic PCA (DPPCA). [sent-8, score-0.296]
</p><p>2 We refer to this model as a Gaussian process latent variable model (GP-LVM). [sent-10, score-0.35]
</p><p>3 Keywords: Gaussian processes, latent variable models, principal component analysis, spectral methods, unsupervised learning, visualisation  1. [sent-14, score-0.66]
</p><p>4 In a probabilistic model the variables associated with such a space are often known as latent variables. [sent-17, score-0.404]
</p><p>5 In this paper our focus will be on methods that represent the data in this latent (or embedded, we shall use the terms interchangeably) space. [sent-18, score-0.29]
</p><p>6 Our approach is inspired by probabilistic latent variable models. [sent-19, score-0.374]
</p><p>7 It has roots in previously proposed approaches such as density networks (MacKay, 1995) where a multi-layer perceptron (MLP) is used to provide a mapping from the latent projections, X, to the observed data, Y. [sent-20, score-0.327]
</p><p>8 If a two dimensional sub-space is sought then the projections may be visualised; but it may be necessary to include more latent dimensions to capture the variability (and therefore hopefully, but by no means necessarily the structure) in the data. [sent-35, score-0.324]
</p><p>9 Principal component analysis also has a latent variable model representation (Tipping and Bishop, 1999) which is strongly related to Factor Analysis (FA) (Bartholomew, 1987; Basilevsky, 1994). [sent-36, score-0.32]
</p><p>10 Both are linear-Gaussian latent variable models, but FA allows for a richer noise model than PCA (for recent work on non-linear factor analysis see Honkela and Valpola, 2005). [sent-37, score-0.418]
</p><p>11 Naturally statisticians have not constrained themselves to linear methods when visualising data and in the next section we shall brieﬂy review multidimensional scaling and related techniques that rely on proximity data. [sent-38, score-0.29]
</p><p>12 1 Multidimensional Scaling and Kernel PCA We have already mentioned several visualisation techniques which rely on learning a mapping from a latent-space (the embedded space) to the data-space. [sent-40, score-0.431]
</p><p>13 In this section we will brieﬂy review methods that use proximity data to obtain a visualisation or embedding. [sent-41, score-0.483]
</p><p>14 When sampling techniques are used the latent points will be in random positions. [sent-56, score-0.29]
</p><p>15 The existence of this function is important as it allows data points which were not in the training set to be mapped to a position in the latent space without re-solving the eigenvalue problem. [sent-63, score-0.352]
</p><p>16 Neither is it clear how to handle missing data4 as the proximity data matrix cannot normally be computed consistently if a particular attribute is not available. [sent-65, score-0.301]
</p><p>17 We have also included the model that is the subject of this paper, the Gaussian process latent variable model (GP-LVM). [sent-76, score-0.35]
</p><p>18 In the remainder of this paper we will introduce the GP-LVM from the latent variable model perspective. [sent-77, score-0.32]
</p><p>19 Gaussian Process Latent Variable Models In this paper we present the Gaussian process latent variable model. [sent-85, score-0.29]
</p><p>20 Here, by missing data, we mean missing attributes which would normally be used in computing the proximity data matrix. [sent-92, score-0.358]
</p><p>21 For proximity data methods missing data can also mean elements missing from the proximity matrix, we do not discuss this case. [sent-93, score-0.53]
</p><p>22 1 Latent Variable Models Typically we specify a latent variable model relating a set of latent variables, X ∈ ℜN×q , to a set of observed variables, Y ∈ ℜN×D , through a set of parameters. [sent-105, score-0.61]
</p><p>23 The model is deﬁned probabilistically, the latent variables are then marginalised and the parameters are found through maximising the likelihood. [sent-106, score-0.415]
</p><p>24 Here we consider an alternative approach: rather than marginalising the latent variables and optimising the parameters we marginalise the parameters and optimise the latent variables. [sent-107, score-0.829]
</p><p>25 2 Probabilistic PCA Probabilistic PCA (PPCA) is a latent variable model in which the maximum likelihood solution for the parameters is found through solving an eigenvalue problem on the data’s covariance matrix 1786  P ROBABILISTIC N ON - LINEAR PCA  (Tipping and Bishop, 1999). [sent-111, score-0.543]
</p><p>26 We denote the q-dimensional latent variable associated with each data point by xn . [sent-116, score-0.29]
</p><p>27 (1)  To obtain the marginal likelihood we integrate over the latent variables, p (yn |W, β) =  Z  p (yn |xn , W, β) p (xn ) dxn ,  (2)  which requires us to specify a prior distribution over xn . [sent-119, score-0.36]
</p><p>28 Marginalising the latent variables and optimising the parameters via maximum likelihood is a standard approach for ﬁtting latent variable models. [sent-127, score-0.701]
</p><p>29 Instead of optimising parameters and marginalising latent variables we will suggest the dual approach of marginalising parameters, W, and optimising with respect to latent variables, X. [sent-129, score-0.811]
</p><p>30 The Bayesian methodology requires a suitable choice of prior for W, and then proceeds to treat the parameters as latent variables. [sent-135, score-0.29]
</p><p>31 (5)  We now look to optimise with respect to the latent variables. [sent-146, score-0.384]
</p><p>32 If it were possible to marginalise both the parameters and latent variables analytically we could use Bayes factors to perform model selection (see, for example, Bishop, 1999). [sent-151, score-0.378]
</p><p>33 Our probabilistic PCA model shares an underlying structure with that of Tipping and Bishop (1999) but differs in that where they optimise we marginalise and where they marginalise we optimise. [sent-160, score-0.324]
</p><p>34 This is recognised as the covariance associated with each factor of the marginal likelihood for dual probabilistic PCA (5). [sent-172, score-0.281]
</p><p>35 5 Gaussian Process Latent Variable Models The dual interpretation of probabilistic PCA described above points to a new class of models which consist of Gaussian process mappings from a latent space, X, to an observed data-space, Y. [sent-176, score-0.477]
</p><p>36 By replacing the inner product kernel with a covariance function that allows for non-linear functions we can obtain a non-linear latent variable model. [sent-185, score-0.432]
</p><p>37 The cross entropy between this Gaussian and the Gaussian process whose marginal likelihood was given in (4) is −  Z  N (z|0, S) ln N (z|0, K) dz =  N 1 1 ln 2π + ln |K| + tr K−1 S . [sent-196, score-0.296]
</p><p>38 In practice this means that the GP-LVM is harder to optimise (solving an eigenvalue problem is no longer sufﬁcient) but the GP-LVM maintains a probabilistic interpretation that kernel PCA doesn’t have. [sent-214, score-0.359]
</p><p>39 Therefore our approach is not a probabilistic interpretation of multidimensional scaling: we refer the reader to MacKay and Zinnes (1986) and Oh and Raftery (2001) for details of probabilistic MDS methods. [sent-217, score-0.26]
</p><p>40 So the new objective function is 1 1 1 N ln |S| − ln |K| + tr KS−1 − , 2 2 2 2 The minimum can again be found through an eigenvalue problem, but now the retained eigenvalues from K are the smallest, rather than the largest. [sent-222, score-0.303]
</p><p>41 To use a particular kernel in the GP-LVM we ﬁrst note that gradients of (6) with respect to the latent points can be found through ﬁrst taking the gradient with respect to the kernel, ∂L = K−1 YYT K−1 − DK−1 , ∂K  (10)  ∂K and then combining it with ∂xn, j through the chain rule. [sent-234, score-0.42]
</p><p>42 As computation of (10) is straightforward and independent of the kernel choice we only require that the gradient of the kernel with respect to  1791  L AWRENCE  the latent points can be computed. [sent-235, score-0.464]
</p><p>43 These gradients may then be used in combination with (6) in a non-linear optimiser to obtain a latent variable representation of the data. [sent-236, score-0.333]
</p><p>44 2 Illustration of GP-LVM via SCG To illustrate a simple Gaussian process latent variable model we turn to the ‘multi-phase oil ﬂow’ data (Bishop and James, 1993). [sent-243, score-0.414]
</p><p>45 Figure 1(b) then shows the visualisation obtained using the GP-LVM with the RBF kernel, γ k (xi , x j ) = θrbf exp − (xi − x j )T (xi − x j ) + θbias + θwhite δi j . [sent-255, score-0.311]
</p><p>46 2 To obtain this visualisation the log likelihood was optimised jointly with respect to the latent positions X and the kernel parameters θbias , θwhite , θrbf and γ. [sent-256, score-0.859]
</p><p>47 The kernel was initialised using PCA to set X, the kernel parameters were initialised as θrbf = γ = 1 and θwhite = θbias = exp (−1). [sent-257, score-0.284]
</p><p>48 n=1  The likelihood for the RBF kernel was optimised using scaled conjugate gradient (see http: //www. [sent-260, score-0.277]
</p><p>49 Multiplying the likelihood by this prior leads to a joint distribution over data points and latent points. [sent-266, score-0.36]
</p><p>50 The greyscales in plot (b) indicate the precision with which the manifold was expressed in 1793 data-space for that latent point. [sent-300, score-0.29]
</p><p>51 L AWRENCE  Method Errors  PCA 20  GP-LVM 4  Non-metric MDS 13  Metric MDS 6  GTM* 7  kernel PCA* 13  Table 2: Errors made by the different methods when using the latent-space for nearest neighbour classiﬁcation in the latent space. [sent-301, score-0.435]
</p><p>52 For GTM we varied the size of the latent grid between 3 × 3 and 15 × 15, and the number of hidden nodes in the RBF network was varied between 4 and 36. [sent-309, score-0.29]
</p><p>53 The best result was obtained for a 10 × 10 latent grid with 25 nodes in the RBF network, it is shown in Figure 1(e). [sent-310, score-0.29]
</p><p>54 Note the characteristic gridding effect in the GTM’s visualisation which arises from the layout of the latent points. [sent-311, score-0.601]
</p><p>55 For kernel PCA we used the RBF kernel and varied the kernel width between 0. [sent-312, score-0.261]
</p><p>56 A Practical Algorithm for GP-LVMs So far we have shown that PCA can be viewed probabilistically from two perspectives, the ﬁrst involves integrating latent variables and the second optimising them. [sent-336, score-0.341]
</p><p>57 The resulting computational advantages make visualisation of large numbers of data points practical. [sent-340, score-0.311]
</p><p>58 1795  L AWRENCE  Algorithm 1 An algorithm for visualisation with a GP-LVM. [sent-355, score-0.311]
</p><p>59 Optimise (11) with respect to the parameters of K (and optionally the latent positions XI ) using scaled conjugate gradients. [sent-361, score-0.401]
</p><p>60 Fortunately, active set selection allows us to optimise each of these points independently as, given a ﬁxed active set, the individual data points are no longer interdependent. [sent-367, score-0.266]
</p><p>61 The active set is ﬁrst selected, then the kernel parameters and active set positions are optimised. [sent-375, score-0.305]
</p><p>62 The active set is then re-selected and then the latent positions of the points not in the active set are optimised. [sent-376, score-0.508]
</p><p>63 In each iteration we perform two active set selections because the choice of active set is dependent on both the kernel parameters and the latent point positions. [sent-377, score-0.549]
</p><p>64 1796  P ROBABILISTIC N ON - LINEAR PCA    ¢¡ ¢ £ ¤  Figure 2: The Gaussian process as a latent variable model. [sent-383, score-0.29]
</p><p>65 To this end we ﬁrstly reformulate our Gaussian process so that it contains an additional latent variable F = [f1 . [sent-387, score-0.29]
</p><p>66 ni  (14)  i=1  Our approach to different noise models will be to approximate them with a Gaussian noise model of this form (see also Csató, 2002; Minka, 2001). [sent-393, score-0.286]
</p><p>67 The noise models we consider in this paper will be independent across the dimensions, D  p (yn |fn ) = ∏ p (yni | fni ) , i=1  giving approximations of the form p (yni | fni ) ≈ N mni | fni , β−1 . [sent-394, score-0.341]
</p><p>68 Csató 2002; Minka 2001) that the parameters of the approximation are given by νni βni = (15) 1 − νni ςni mni = where ςni is nth diagonal element of Σi , gni = Zni =  Z  gni ¯ + fni νni  ∂ ∂ f¯ni  (16)  ∂ ln Zni and νni = g2 − 2 ∂ςni ln Zni where ni  p (yni | fni ) q (F) dF. [sent-405, score-0.35]
</p><p>69 This is a characteristic which the Gaussian process latent variable model shares. [sent-412, score-0.32]
</p><p>70 Note that for these visualisation algorithms over-ﬁtting is not a problem as long as the latent-space is of lower dimensionality than the data-space. [sent-424, score-0.311]
</p><p>71 This is a consequence of the integration over the mapping between the latent and the data-space. [sent-425, score-0.327]
</p><p>72 σ2 →0  In our experiments we preferred to include the noise term with the kernel as the noise level, θwhite , can then be jointly optimised with the kernel parameters and the latent point positions. [sent-446, score-0.715]
</p><p>73 For each of the different algorithms we explore the quality of the visualisation in terms of the ease with which the different ﬂow regimes can be separated in the embedded space. [sent-464, score-0.394]
</p><p>74 In Figure 4(a) we show the data visualised with the non-sparse GP-LVM algorithm and in Figure 4(b) we have recreated the visualisation in (Bishop et al. [sent-489, score-0.438]
</p><p>75 2 H ANDWRITTEN D IGITS The oil ﬂow data has twelve attributes, twelve dimensions is too many for the structure of the data set to be visualised without resorting to displaying embedded spaces, but there are many data sets with much greater dimensionality. [sent-495, score-0.382]
</p><p>76 One popular data set for visualisation algorithms has been handwritten digits. [sent-496, score-0.345]
</p><p>77 We therefore followed Hinton and Roweis (2003) in our 2-D visualisation of a sub-set of 3000 of the digits 0-4 (600 of each digit) from a 16 × 16 greyscale version of the USPS digit data set (Figure 5). [sent-497, score-0.368]
</p><p>78 As for the oil data we looked for an objective assessment of the quality of the visualisation by evaluation errors on a nearest neighbour classiﬁer in the latent-space. [sent-500, score-0.504]
</p><p>79 5 −3  −2  −1  0 (b)  Figure 3: The full oil ﬂow data set visualised with (a) an RBF based sparse GP-LVM, (b) an MLP based sparse GP-LVM. [sent-509, score-0.285]
</p><p>80 (b) GTM with 225 latent points laid out on a 15 × 15 grid and with 16 RBF nodes. [sent-525, score-0.29]
</p><p>81 Non-Gaussian, linear, latent trait models have already been proposed (Bartholomew, 1987; Tipping, 1999), in this section we use the ADF approach described in Section 5 to explore two non-Gaussian data sets with GP-LVM models based around non-Gaussian noise models. [sent-575, score-0.388]
</p><p>82 For both visualisations an RBF kernel was used in combination with a Gaussian prior over the latent-space, however the two visualisations make use of different noise models. [sent-582, score-0.415]
</p><p>83 Reconstruction method GP-LVM with Bernoulli noise GP-LVM with Gaussian noise Assume pixels are ‘not ink’  pixel error rate 23. [sent-601, score-0.272]
</p><p>84 Note that there can be local minima in the embedded space, we therefore optimised the embedded space location ten times with different starting positions and selected that with the largest likelihood. [sent-607, score-0.267]
</p><p>85 Results are shown for the Bernoulli noise model, the Gaussian noise model and a baseline approach (which is simply to assume that the missing pixels do not contain ink). [sent-610, score-0.361]
</p><p>86 Top row: test images from the data set of twos, second row: pixels removed from the test images are shown in red, third row: reconstruction which assumes missing pixels are ‘not ink’, fourth row: reconstruction by the Gaussian GP-LVM, ﬁfth row: reconstruction by the binary noise model. [sent-628, score-0.401]
</p><p>87 Discussion We have presented the Gaussian process latent variable model, which is a non-linear probabilistic extension of PCA. [sent-630, score-0.374]
</p><p>88 Our experiments show that the GP-LVM is a viable alternative to other nonlinear visualisation approaches for small data sets. [sent-631, score-0.311]
</p><p>89 The new datum has an associated latent variable, x∗ . [sent-643, score-0.29]
</p><p>90 I,∗ I,I 1809  (21)  L AWRENCE  To determine the likelihood of the new point, we ﬁrst ﬁnd the MAP solution for this new latent point. [sent-646, score-0.36]
</p><p>91 Conclusions We have presented a new class of models for probabilistic modelling and visualisation of high dimensional data. [sent-653, score-0.429]
</p><p>92 We showed there is a general objective function based on the Kullback-Leibler divergence that connects these models with proximity data based methods such as kernel PCA and multidimensional scaling. [sent-655, score-0.36]
</p><p>93 In all these cases the embedded space is treated as a latent variable and problems of propagating distributions through the non-linear mapping are avoided by using point representations of the data within the latent space. [sent-660, score-0.7]
</p><p>94 Acknowledgments We thank Aaron Hertzmann and his collaborators for ongoing access to their work on style based inverse kinematics, Amos Storkey for pointing out that the GP-LVM fails on the Swiss-roll data with a PCA initialisation and Michael Tipping for discussions on visualisation techniques. [sent-662, score-0.34]
</p><p>95 the prior distribution for the latent variables is then taken to be Gaussian, p (xn ) = N (xn |0, I) , and is duly marginalised to recover the marginal likelihood for the data, N  p (Y|W, β) = ∏ p (yn |W, β) ,  (22)  p (yn |W, β) = N yn |0, WWT + β−1 I . [sent-667, score-0.49]
</p><p>96 Tipping and Bishop (1999) showed how to optimise (22), in the next section we review this optimisation for DPPCA, but generalise it slightly so that it applies for any symmetric matrix S, rather than only the inner product matrix YYT . [sent-677, score-0.281]
</p><p>97 The full KL divergence is KL (S||K) = =  1 1 N 1 ln |K| − ln |S| + tr K−1 S − 2 2 2 2 1 q 1 N N −q 1 ∑ ln λi − 2 ln β − 2 ∑ ln λi + 2 tr 2 i=1 i=1  = −  L2 + β−1 I  −1  Λ  1 N N −q β N N −q ∑ ln λi − 2 ln β − 2 + 2 ∑ λi 2 i=q+1 i=q+1  where we have used the fact that S = UΛUT . [sent-692, score-0.516]
</p><p>98 A fast EM algorithm for latent variable density models. [sent-729, score-0.29]
</p><p>99 Gaussian process models for visualisation of high dimensional data. [sent-786, score-0.345]
</p><p>100 A probabilistic model for the multidimensional scaling of proximity and preference data. [sent-802, score-0.346]
</p>
<br/>
<h2>similar papers computed by tfidf model</h2><h3>tfidf for this paper:</h3><p>wordName wordTfidf (topN-words)</p>
<p>[('pca', 0.37), ('visualisation', 0.311), ('latent', 0.29), ('gtm', 0.288), ('mds', 0.206), ('awrence', 0.196), ('robabilistic', 0.185), ('proximity', 0.172), ('yyt', 0.155), ('visualised', 0.127), ('tipping', 0.125), ('mlp', 0.12), ('visualisations', 0.115), ('optimisation', 0.115), ('bishop', 0.113), ('rbf', 0.11), ('noise', 0.098), ('oil', 0.094), ('optimise', 0.094), ('missing', 0.093), ('dppca', 0.092), ('kernel', 0.087), ('active', 0.086), ('probabilistic', 0.084), ('embedded', 0.083), ('yn', 0.082), ('fni', 0.081), ('likelihood', 0.07), ('gaussian', 0.07), ('ln', 0.064), ('white', 0.064), ('eigenvalue', 0.062), ('ni', 0.06), ('multidimensional', 0.06), ('principal', 0.059), ('neighbour', 0.058), ('isomap', 0.058), ('marginalise', 0.058), ('visualising', 0.058), ('digit', 0.057), ('christopher', 0.056), ('covariance', 0.055), ('optimised', 0.055), ('initialised', 0.055), ('optimising', 0.051), ('neil', 0.048), ('sparsi', 0.048), ('sammon', 0.048), ('yni', 0.048), ('marginalised', 0.048), ('ow', 0.047), ('maximising', 0.047), ('xxt', 0.047), ('yt', 0.047), ('fin', 0.046), ('marginalising', 0.046), ('ulvt', 0.046), ('visualise', 0.046), ('wwt', 0.046), ('positions', 0.046), ('gradients', 0.043), ('topographic', 0.043), ('pixels', 0.042), ('reconstruction', 0.042), ('objective', 0.041), ('twelve', 0.039), ('modes', 0.039), ('eigenvalues', 0.038), ('dual', 0.037), ('mapping', 0.037), ('matrix', 0.036), ('conjugate', 0.036), ('lawrence', 0.036), ('aston', 0.035), ('ivm', 0.035), ('recognised', 0.035), ('wxn', 0.035), ('wxt', 0.035), ('zni', 0.035), ('michael', 0.035), ('tenenbaum', 0.034), ('yin', 0.034), ('mappings', 0.034), ('pixel', 0.034), ('dimensional', 0.034), ('handwritten', 0.034), ('tr', 0.034), ('interpretation', 0.032), ('sparse', 0.032), ('fa', 0.031), ('ground', 0.031), ('truth', 0.031), ('processes', 0.031), ('model', 0.03), ('outlined', 0.03), ('marginalisation', 0.029), ('svens', 0.029), ('twos', 0.029), ('initialisation', 0.029), ('scaled', 0.029)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 1.0000014 <a title="62-tfidf-1" href="./jmlr-2005-Probabilistic_Non-linear_Principal_Component_Analysis_with_Gaussian_Process_Latent_Variable_Models.html">62 jmlr-2005-Probabilistic Non-linear Principal Component Analysis with Gaussian Process Latent Variable Models</a></p>
<p>Author: Neil Lawrence</p><p>Abstract: Summarising a high dimensional data set with a low dimensional embedding is a standard approach for exploring its structure. In this paper we provide an overview of some existing techniques for discovering such embeddings. We then introduce a novel probabilistic interpretation of principal component analysis (PCA) that we term dual probabilistic PCA (DPPCA). The DPPCA model has the additional advantage that the linear mappings from the embedded space can easily be nonlinearised through Gaussian processes. We refer to this model as a Gaussian process latent variable model (GP-LVM). Through analysis of the GP-LVM objective function, we relate the model to popular spectral techniques such as kernel PCA and multidimensional scaling. We then review a practical algorithm for GP-LVMs in the context of large data sets and develop it to also handle discrete valued data and missing attributes. We demonstrate the model on a range of real-world and artiﬁcially generated data sets. Keywords: Gaussian processes, latent variable models, principal component analysis, spectral methods, unsupervised learning, visualisation</p><p>2 0.097373791 <a title="62-tfidf-2" href="./jmlr-2005-Assessing_Approximate_Inference_for_Binary_Gaussian_Process_Classification.html">14 jmlr-2005-Assessing Approximate Inference for Binary Gaussian Process Classification</a></p>
<p>Author: Malte Kuss, Carl Edward Rasmussen</p><p>Abstract: Gaussian process priors can be used to deﬁne ﬂexible, probabilistic classiﬁcation models. Unfortunately exact Bayesian inference is analytically intractable and various approximation techniques have been proposed. In this work we review and compare Laplace’s method and Expectation Propagation for approximate Bayesian inference in the binary Gaussian process classiﬁcation model. We present a comprehensive comparison of the approximations, their predictive performance and marginal likelihood estimates to results obtained by MCMC sampling. We explain theoretically and corroborate empirically the advantages of Expectation Propagation compared to Laplace’s method. Keywords: Gaussian process priors, probabilistic classiﬁcation, Laplace’s approximation, expectation propagation, marginal likelihood, evidence, MCMC</p><p>3 0.089458786 <a title="62-tfidf-3" href="./jmlr-2005-Gaussian_Processes_for_Ordinal_Regression.html">36 jmlr-2005-Gaussian Processes for Ordinal Regression</a></p>
<p>Author: Wei Chu, Zoubin Ghahramani</p><p>Abstract: We present a probabilistic kernel approach to ordinal regression based on Gaussian processes. A threshold model that generalizes the probit function is used as the likelihood function for ordinal variables. Two inference techniques, based on the Laplace approximation and the expectation propagation algorithm respectively, are derived for hyperparameter learning and model selection. We compare these two Gaussian process approaches with a previous ordinal regression method based on support vector machines on some benchmark and real-world data sets, including applications of ordinal regression to collaborative ﬁltering and gene expression analysis. Experimental results on these data sets verify the usefulness of our approach. Keywords: Gaussian processes, ordinal regression, approximate Bayesian inference, collaborative ﬁltering, gene expression analysis, feature selection</p><p>4 0.081858262 <a title="62-tfidf-4" href="./jmlr-2005-A_Unifying_View_of_Sparse_Approximate_Gaussian_Process_Regression.html">7 jmlr-2005-A Unifying View of Sparse Approximate Gaussian Process Regression</a></p>
<p>Author: Joaquin Quiñonero-Candela, Carl Edward Rasmussen</p><p>Abstract: We provide a new unifying view, including all existing proper probabilistic sparse approximations for Gaussian process regression. Our approach relies on expressing the effective prior which the methods are using. This allows new insights to be gained, and highlights the relationship between existing methods. It also allows for a clear theoretically justiﬁed ranking of the closeness of the known approximations to the corresponding full GPs. Finally we point directly to designs of new better sparse approximations, combining the best of the existing strategies, within attractive computational constraints. Keywords: Gaussian process, probabilistic regression, sparse approximation, Bayesian committee machine Regression models based on Gaussian processes (GPs) are simple to implement, ﬂexible, fully probabilistic models, and thus a powerful tool in many areas of application. Their main limitation is that memory requirements and computational demands grow as the square and cube respectively, of the number of training cases n, effectively limiting a direct implementation to problems with at most a few thousand cases. To overcome the computational limitations numerous authors have recently suggested a wealth of sparse approximations. Common to all these approximation schemes is that only a subset of the latent variables are treated exactly, and the remaining variables are given some approximate, but computationally cheaper treatment. However, the published algorithms have widely different motivations, emphasis and exposition, so it is difﬁcult to get an overview (see Rasmussen and Williams, 2006, chapter 8) of how they relate to each other, and which can be expected to give rise to the best algorithms. In this paper we provide a unifying view of sparse approximations for GP regression. Our approach is simple, but powerful: for each algorithm we analyze the posterior, and compute the effective prior which it is using. Thus, we reinterpret the algorithms as “exact inference with an approximated prior”, rather than the existing (ubiquitous) interpretation “approximate inference with the exact prior”. This approach has the advantage of directly expressing the approximations in terms of prior assumptions about the function, which makes the consequences of the approximations much easier to understand. While our view of the approximations is not the only one possible, it has the advantage of putting all existing probabilistic sparse approximations under one umbrella, thus enabling direct comparison and revealing the relation between them. In Section 1 we brieﬂy introduce GP models for regression. In Section 2 we present our unifying framework and write out the key equations in preparation for the unifying analysis of sparse c 2005 Joaquin Qui˜ onero-Candela and Carl Edward Rasmussen. n ˜ Q UI NONERO -C ANDELA AND R ASMUSSEN algorithms in Sections 4-7. The relation of transduction and augmentation to our sparse framework is covered in Section 8. All our approximations are written in terms of a new set of inducing variables. The choice of these variables is itself a challenging problem, and is discussed in Section 9. We comment on a few special approximations outside our general scheme in Section 10 and conclusions are drawn at the end. 1. Gaussian Processes for Regression Probabilistic regression is usually formulated as follows: given a training set D = {(xi , yi ), i = 1, . . . , n} of n pairs of (vectorial) inputs xi and noisy (real, scalar) outputs yi , compute the predictive distribution of the function values f∗ (or noisy y∗ ) at test locations x∗ . In the simplest case (which we deal with here) we assume that the noise is additive, independent and Gaussian, such that the relationship between the (latent) function f (x) and the observed noisy targets y are given by yi = f (xi ) + εi , where εi ∼ N (0, σ2 ) , noise (1) where σ2 is the variance of the noise. noise Deﬁnition 1 A Gaussian process (GP) is a collection of random variables, any ﬁnite number of which have consistent1 joint Gaussian distributions. Gaussian process (GP) regression is a Bayesian approach which assumes a GP prior2 over functions, i.e. assumes a priori that function values behave according to p(f|x1 , x2 , . . . , xn ) = N (0, K) , (2) where f = [ f1 , f2 , . . . , fn ] is a vector of latent function values, fi = f (xi ) and K is a covariance matrix, whose entries are given by the covariance function, Ki j = k(xi , x j ). Note that the GP treats the latent function values fi as random variables, indexed by the corresponding input. In the following, for simplicity we will always neglect the explicit conditioning on the inputs; the GP model and all expressions are always conditional on the corresponding inputs. The GP model is concerned only with the conditional of the outputs given the inputs; we do not model anything about the inputs themselves. Remark 2 Note, that to adhere to a strict Bayesian formalism, the GP covariance function,3 which deﬁnes the prior, should not depend on the data (although it can depend on additional parameters). As we will see in later sections, some approximations are strictly equivalent to GPs, while others are not. That is, the implied prior may still be multivariate Gaussian, but the covariance function may be different for training and test cases. Deﬁnition 3 A Gaussian process is called degenerate iff the covariance function has a ﬁnite number of non-zero eigenvalues. 1. By consistency is meant simply that the random variables obey the usual rules of marginalization, etc. 2. For notational simplicity we exclusively use zero-mean priors. 3. The covariance function itself shouldn’t depend on the data, though its value at a speciﬁc pair of inputs of course will. 1940 S PARSE A PPROXIMATE G AUSSIAN P ROCESS R EGRESSION Degenerate GPs (such as e.g. with polynomial covariance function) correspond to ﬁnite linear (-in-the-parameters) models, whereas non-degenerate GPs (such as e.g. with squared exponential or RBF covariance function) do not. The prior for a ﬁnite m dimensional linear model only considers a universe of at most m linearly independent functions; this may often be too restrictive when n m. Note however, that non-degeneracy on its own doesn’t guarantee the existence of the “right kind” of ﬂexibility for a given particular modelling task. For a more detailed background on GP models, see for example that of Rasmussen and Williams (2006). Inference in the GP model is simple: we put a joint GP prior on training and test latent values, f and f∗ 4 , and combine it with the likelihood5 p(y|f) using Bayes rule, to obtain the joint posterior p(f, f∗ )p(y|f) . p(y) p(f, f∗ |y) = (3) The ﬁnal step needed to produce the desired posterior predictive distribution is to marginalize out the unwanted training set latent variables: p(f∗ |y) = Z 1 p(y) p(f, f∗ |y)df = Z p(y|f) p(f, f∗ ) df , (4) or in words: the predictive distribution is the marginal of the renormalized joint prior times the likelihood. The joint GP prior and the independent likelihood are both Gaussian p(f, f∗ ) = N 0, Kf,f K∗,f Kf,∗ K∗,∗ , and p(y|f) = N (f, σ2 I) , noise (5) where K is subscript by the variables between which the covariance is computed (and we use the asterisk ∗ as shorthand for f∗ ) and I is the identity matrix. Since both factors in the integral are Gaussian, the integral can be evaluated in closed form to give the Gaussian predictive distribution p(f∗ |y) = N K∗,f (Kf,f + σ2 I)−1 y, K∗,∗ − K∗,f (Kf,f + σ2 I)−1 Kf,∗ , noise noise (6) see the relevant Gaussian identity in appendix A. The problem with the above expression is that it requires inversion of a matrix of size n × n which requires O (n3 ) operations, where n is the number of training cases. Thus, the simple exact implementation can handle problems with at most a few thousand training cases. 2. A New Unifying View We now seek to modify the joint prior p(f∗ , f) from (5) in ways which will reduce the computational requirements from (6). Let us ﬁrst rewrite that prior by introducing an additional set of m latent variables u = [u1 , . . . , um ] , which we call the inducing variables. These latent variables are values of the Gaussian process (as also f and f∗ ), corresponding to a set of input locations Xu , which we call the inducing inputs. Whereas the additional latent variables u are always marginalized out in the predictive distribution, the choice of inducing inputs does leave an imprint on the ﬁnal solution. 4. We will mostly consider a vector of test cases f∗ (rather than a single f∗ ). 5. You may have been expecting the likelihood written as p(y|f∗ , f) but since the likelihood is conditionally independent of everything else given f, this makes no difference. 1941 ˜ Q UI NONERO -C ANDELA AND R ASMUSSEN The inducing variables will turn out to be generalizations of variables which other authors have referred to variously as “support points”, “active set” or “pseudo-inputs”. Particular sparse algorithms choose the inducing variables in various different ways; some algorithms chose the inducing inputs to be a subset of the training set, others not, as we will discuss in Section 9. For now consider any arbitrary inducing variables. Due to the consistency of Gaussian processes, we know that we can recover p(f∗ , f) by simply integrating (marginalizing) out u from the joint GP prior p(f∗ , f, u) p(f∗ , f) = Z p(f∗ , f, u) du = Z p(f∗ , f|u) p(u) du, where p(u) = N (0, Ku,u ) . (7) This is an exact expression. Now, we introduce the fundamental approximation which gives rise to almost all sparse approximations. We approximate the joint prior by assuming that f∗ and f are conditionally independent given u, see Figure 1, such that p(f∗ , f) q(f∗ , f) = Z q(f∗ |u) q(f|u) p(u) du . (8) The name inducing variable is motivated by the fact that f and f∗ can only communicate though u, and u therefore induces the dependencies between training and test cases. As we shall detail in the following sections, the different computationally efﬁcient algorithms proposed in the literature correspond to different additional assumptions about the two approximate inducing conditionals q(f|u), q(f∗ |u) of the integral in (8). It will be useful for future reference to specify here the exact expressions for the two conditionals training conditional: test conditional: −1 p(f|u) = N (Kf,u Ku,u u, Kf,f − Qf,f ) , −1 p(f∗ |u) = N (K∗,u Ku,u u, K∗,∗ − Q∗,∗ ) , (9a) (9b) −1 where we have introduced the shorthand notation6 Qa,b Ka,u Ku,u Ku,b . We can readily identify the expressions in (9) as special (noise free) cases of the standard predictive equation (6) with u playing the role of (noise free) observations. Note that the (positive semi-deﬁnite) covariance matrices in (9) have the form K − Q with the following interpretation: the prior covariance K minus a (non-negative deﬁnite) matrix Q quantifying how much information u provides about the variables in question (f or f∗ ). We emphasize that all the sparse methods discussed in the paper correspond simply to different approximations to the conditionals in (9), and throughout we use the exact likelihood and inducing prior p(y|f) = N (f, σ2 I) , and p(u) = N (0, Ku,u ) . (10) noise 3. The Subset of Data (SoD) Approximation Before we get started with the more sophisticated approximations, we mention as a baseline method the simplest possible sparse approximation (which doesn’t fall inside our general scheme): use only a subset of the data (SoD). The computational complexity is reduced to O (m3 ), where m < n. We would not generally expect SoD to be a competitive method, since it would seem impossible (even with fairly redundant data and a good choice of the subset) to get a realistic picture of the 6. Note, that Qa,b depends on u although this is not explicit in the notation. 1942 S PARSE A PPROXIMATE G AUSSIAN P ROCESS R EGRESSION u u    e ¡   ¡ e  e    ¡  e   ¡  e   ¡   e ¡   r r r r r fn f1 f2 f∗    e ¡   ¡ e  e    ¡  e   ¡  e   ¡   e ¡   r r r r r fn f1 f2 f∗ Figure 1: Graphical model of the relation between the inducing variables u, the training latent functions values f = [ f1 , . . . , fn ] and the test function value f∗ . The thick horizontal line represents a set of fully connected nodes. The observations y1 , . . . , yn , y∗ (not shown) would dangle individually from the corresponding latent values, by way of the exact (factored) likelihood (5). Left graph: the fully connected graph corresponds to the case where no approximation is made to the full joint Gaussian process distribution between these variables. The inducing variables u are superﬂuous in this case, since all latent function values can communicate with all others. Right graph: assumption of conditional independence between training and test function values given u. This gives rise to the separation between training and test conditionals from (8). Notice that having cut the communication path between training and test latent function values, information from f can only be transmitted to f∗ via the inducing variables u. uncertainties, when only a part of the training data is even considered. We include it here mostly as a baseline against which to compare better sparse approximations. In Figure 5 top, left we see how the SoD method produces wide predictive distributions, when training on a randomly selected subset of 10 cases. A fair comparison to other methods would take into account that the computational complexity is independent of n as opposed to other more advanced methods. These extra computational resources could be spent in a number of ways, e.g. larger m, or an active (rather than random) selection of the m points. In this paper we will concentrate on understanding the theoretical foundations of the various approximations rather than investigating the necessary heuristics needed to turn the approximation schemes into actually practical algorithms. 4. The Subset of Regressors (SoR) Approximation The Subset of Regressors (SoR) algorithm was given by Silverman (1985), and mentioned again by Wahba et al. (1999). It was then adapted by Smola and Bartlett (2001) to propose a sparse greedy approximation to Gaussian process regression. SoR models are ﬁnite linear-in-the-parameters models with a particular prior on the weights. For any input x∗ , the corresponding function value f∗ is given by: f∗ = K∗,u wu , with −1 p(wu ) = N (0, Ku,u ) , (11) where there is one weight associated to each inducing input in Xu . Note that the covariance matrix for the prior on the weights is the inverse of that on u, such that we recover the exact GP prior on u, 1943 ˜ Q UI NONERO -C ANDELA AND R ASMUSSEN which is Gaussian with zero mean and covariance u = Ku,u wu ⇒ uu = Ku,u wu wu Ku,u = Ku,u . (12) −1 Using the effective prior on u and the fact that wu = Ku,u u we can redeﬁne the SoR model in an equivalent, more intuitive way: −1 f∗ = K∗,u Ku,u u , with u ∼ N (0, Ku,u ) . (13) We are now ready to integrate the SoR model in our unifying framework. Given that there is a deterministic relation between any f∗ and u, the approximate conditional distributions in the integral in eq. (8) are given by: −1 qSoR (f|u) = N (Kf,u Ku,u u, 0) , and −1 qSoR (f∗ |u) = N (K∗,u Ku,u u, 0) , (14) with zero conditional covariance, compare to (9). The effective prior implied by the SoR approximation is easily obtained from (8), giving qSoR (f, f∗ ) = N 0, Qf,f Qf,∗ Q∗,f Q∗,∗ , (15) −1 where we recall Qa,b Ka,u Ku,u Ku,b . A more descriptive name for this method, would be the Deterministic Inducing Conditional (DIC) approximation. We see that this approximate prior is degenerate. There are only m degrees of freedom in the model, which implies that only m linearly independent functions can be drawn from the prior. The m + 1-th one is a linear combination of the previous. For example, in a very low noise regime, the posterior could be severely constrained by only m training cases. The degeneracy of the prior causes unreasonable predictive distributions. Indeed, the approximate prior over functions is so restrictive, that given enough data only a very limited family of functions will be plausible under the posterior, leading to overconﬁdent predictive variances. This is a general problem of ﬁnite linear models with small numbers of weights (for more details see Rasmussen and Qui˜ onero-Candela, 2005). Figure 5, top, right panel, illustrates the unreasonable n predictive uncertainties of the SoR approximation on a toy dataset.7 The predictive distribution is obtained by using the SoR approximate prior (15) instead of the true prior in (4). For each algorithm we give two forms of the predictive distribution, one which is easy to interpret, and the other which is economical to compute with: qSoR (f∗ |y) = N Q∗,f (Qf,f + σ2 I)−1 y, Q∗,∗ − Q∗,f (Qf,f + σ2 I)−1 Qf,∗ , noise noise = N σ K∗,u Σ Ku,f y, K∗,u ΣKu,∗ , −2 (16a) (16b) where we have deﬁned Σ = (σ−2 Ku,f Kf,u + Ku,u )−1 . Equation (16a) is readily recognized as the regular prediction equation (6), except that the covariance K has everywhere been replaced by Q, which was already suggested by (15). This corresponds to replacing the covariance function k with −1 kSoR (xi , x j ) = k(xi , u)Ku,u k(u, x j ). The new covariance function has rank (at most) m. Thus we have the following 7. Wary of this fact, Smola and Bartlett (2001) propose using the predictive variances of the SoD, or a more accurate computationally costly alternative (more details are given by Qui˜ onero-Candela, 2004, Chapter 3). n 1944 S PARSE A PPROXIMATE G AUSSIAN P ROCESS R EGRESSION Remark 4 The SoR approximation is equivalent to exact inference in the degenerate Gaussian −1 process with covariance function kSoR (xi , x j ) = k(xi , u)Ku,u k(u, x j ). The equivalent (16b) is computationally cheaper, and with (11) in mind, Σ is the covariance of the posterior on the weights wu . Note that as opposed to the subset of data method, all training cases are taken into account. The computational complexity is O (nm2 ) initially, and O (m) and O (m2 ) per test case for the predictive mean and variance respectively. 5. The Deterministic Training Conditional (DTC) Approximation Taking up ideas already contained in the work of Csat´ and Opper (2002), Seeger et al. (2003) o recently proposed another sparse approximation to Gaussian process regression, which does not suffer from the nonsensical predictive uncertainties of the SoR approximation, but that interestingly leads to exactly the same predictive mean. Seeger et al. (2003), who called the method Projected Latent Variables (PLV), presented the method as relying on a likelihood approximation, based on −1 the projection f = Kf,u Ku,u u: p(y|f) −1 q(y|u) = N (Kf,u Ku,u u, σ2 I) . noise (17) The method has also been called the Projected Process Approximation (PPA) by Rasmussen and Williams (2006, Chapter 8). One way of obtaining an equivalent model is to retain the usual likelihood, but to impose a deterministic training conditional and the exact test conditional from eq. (9b) −1 qDTC (f|u) = N (Kf,u Ku,u u, 0), and qDTC (f∗ |u) = p(f∗ |u) . (18) This reformulation has the advantage of allowing us to stick to our view of exact inference (with exact likelihood) with approximate priors. Indeed, under this model the conditional distribution of f given u is identical to that of the SoR, given in the left of (14). A systematic name for this approximation is the Deterministic Training Conditional (DTC). The fundamental difference with SoR is that DTC uses the exact test conditional (9b) instead of the deterministic relation between f∗ and u of SoR. The joint prior implied by DTC is given by: qDTC (f, f∗ ) = N 0, Qf,f Qf,∗ Q∗,f K∗,∗ , (19) which is surprisingly similar to the effective prior implied by the SoR approximation (15). The fundamental difference is that under the DTC approximation f∗ has a prior variance of its own, given by K∗,∗ . This prior variance reverses the behaviour of the predictive uncertainties, and turns them into sensible ones, see Figure 5 for an illustration. The predictive distribution is now given by: qDTC (f∗ |y) = N (Q∗,f (Qf,f + σ2 I)−1 y, K∗,∗ − Q∗,f (Qf,f + σ2 I)−1 Qf,∗ noise noise = N σ K∗,u Σ Ku,f y, K∗,∗ − Q∗,∗ + K∗,u ΣK∗,u , −2 (20a) (20b) where again we have deﬁned Σ = (σ−2 Ku,f Kf,u + Ku,u )−1 as in (16). The predictive mean for the DTC is identical to that of the SoR approximation (16), but the predictive variance replaces the Q∗,∗ from SoR with K∗,∗ (which is larger, since K∗,∗ − Q∗,∗ is positive deﬁnite). This added term is the predictive variance of the posterior of f∗ conditioned on u. It grows to the prior variance K∗,∗ as x∗ moves far from the inducing inputs in Xu . 1945 ˜ Q UI NONERO -C ANDELA AND R ASMUSSEN u    e ¡   ¡ e  e    ¡  e   ¡  e   ¡   e ¡   r r r f1 f2 fn f∗ Figure 2: Graphical model for the FITC approximation. Compared to those in Figure 1, all edges between latent function values have been removed: the latent function values are conditionally fully independent given the inducing variables u. Although strictly speaking the SoR and DTC approximations could also be represented by this graph, note that both further assume a deterministic relation between f and u. Remark 5 The only difference between the predictive distribution of DTC and SoR is the variance. The predictive variance of DTC is never smaller than that of SoR. Note, that since the covariances for training cases and test cases are computed differently, see (19), it follows that Remark 6 The DTC approximation does not correspond exactly to a Gaussian process, as the covariance between latent values depends on whether they are considered training or test cases, violating consistency, see Deﬁnition 1. The computational complexity has the same order as for SoR. 6. The Fully Independent Training Conditional (FITC) Approximation Recently Snelson and Ghahramani (2006) proposed another likelihood approximation to speed up Gaussian process regression, which they called Sparse Gaussian Processes using Pseudo-inputs (SGPP). While the DTC is based on the likelihood approximation given by (17), the SGPP proposes a more sophisticated likelihood approximation with a richer covariance p(y|f) −1 q(y|u) = N (Kf,u Ku,u u, diag[Kf,f − Qf,f ] + σ2 I) , noise (21) where diag[A] is a diagonal matrix whose elements match the diagonal of A. As we did in (18) for the DTC, we provide an alternative equivalent formulation called Fully Independent Training Conditional (FITC) based on the inducing conditionals: n qFITC (f|u) = ∏ p( fi |u) = N i=1 −1 Kf,u Ku,u u, diag[Kf,f −Qf,f ] , and qFITC ( f∗ |u) = p( f∗ |u) . (22) We see that as opposed to SoR and DTC, FITC does not impose a deterministic relation between f and u. Instead of ignoring the variance, FITC proposes an approximation to the training conditional distribution of f given u as a further independence assumption. In addition, the exact test conditional from (9b) is used in (22), although for reasons which will become clear towards the end of this 1946 S PARSE A PPROXIMATE G AUSSIAN P ROCESS R EGRESSION section, we initially consider only a single test case, f∗ . The corresponding graphical model is given in Figure 2. The effective prior implied by the FITC is given by qFITC (f, f∗ ) = N 0, Qf,f − diag[Qf,f − Kf,f ] Qf,∗ Q∗,f K∗,∗ . (23) Note, that the sole difference between the DTC and FITC is that in the top left corner of the implied prior covariance, FITC replaces the approximate covariances of DTC by the exact ones on the diagonal. The predictive distribution is qFITC ( f∗ |y) = N Q∗,f (Qf,f + Λ)−1 y, K∗,∗ − Q∗,f (Qf,f + Λ)−1 Qf,∗ (24a) = N K∗,u ΣKu,f Λ−1 y, K∗,∗ − Q∗,∗ + K∗,u ΣKu,∗ , (24b) where we have deﬁned Σ = (Ku,u + Ku,f Λ−1 Kf,u )−1 and Λ = diag[Kf,f − Qf,f + σ2 I ]. The compunoise tational complexity is identical to that of SoR and DTC. So far we have only considered a single test case. There are two options for joint predictions, either 1) use the exact full test conditional from (9b), or 2) extend the additional factorizing assumption to the test conditional. Although Snelson and Ghahramani (2006) don’t explicitly discuss joint predictions, it would seem that they probably intend the second option. Whereas the additional independence assumption for the test cases is not really necessary for computational reasons, it does affect the nature of the approximation. Under option 1) the training and test covariance are computed differently, and thus this does not correspond to our strict deﬁnition of a GP model, but Remark 7 Iff the assumption of full independence is extended to the test conditional, the FITC approximation is equivalent to exact inference in a non-degenerate Gaussian process with covariance function kFIC (xi , x j ) = kSoR (xi , x j ) + δi, j [k(xi , x j ) − kSoR (xi , x j )], where δi, j is Kronecker’s delta. A logical name for the method where the conditionals (training and test) are always forced to be fully independent would be the Fully Independent Conditional (FIC) approximation. The effective prior implied by FIC is: qFIC (f, f∗ ) = N 0, Qf,f − diag[Qf,f − Kf,f ] Qf,∗ Q∗,f Q∗,∗ − diag[Q∗,∗ − K∗,∗ ] . (25) 7. The Partially Independent Training Conditional (PITC) Approximation In the previous section we saw how to improve the DTC approximation by approximating the training conditional with an independent distribution, i.e. one with a diagonal covariance matrix. In this section we will further improve the approximation (while remaining computationally attractive) by extending the training conditional to have a block diagonal covariance: −1 qPITC (f|u) = N Kf,u Ku,u u, blockdiag[Kf,f − Qf,f ] , and qPITC (f∗ |u) = p(f∗ |u) . (26) where blockdiag[A] is a block diagonal matrix (where the blocking structure is not explicitly stated). We represent graphically the PITC approximation in Figure 3. Developing this analogously to the FITC approximation from the previous section, we get the joint prior qPITC (f, f∗ ) = N 0, Qf,f − blockdiag[Qf,f − Kf,f ] Qf,∗ Q∗,f K∗,∗ 1947 , (27) ˜ Q UI NONERO -C ANDELA AND R ASMUSSEN u    e ¡   ¡ e  e    ¡  e   ¡  e   ¡   e ¡   r r r fI fI fI f∗ 1 2 k Figure 3: Graphical representation of the PITC approximation. The set of latent function values fIi indexed by the the set of indices Ii is fully connected. The PITC differs from FITC (see graph in Fig. 2) in that conditional independence is now between the k groups of training latent function values. This corresponds to the block diagonal approximation to the true training conditional given in (26). and the predictive distribution is identical to (24), except for the alternative deﬁnition of Λ = blockdiag[Kf,f − Qf,f + σ2 I ]. An identical expression was obtained by Schwaighofer and Tresp noise (2003, Sect. 3), developing from the original Bayesian committee machine (BCM) by Tresp (2000). The relationship to the FITC was pointed out by Lehel Csat´ . The BCM was originally proposed as o a transductive learner (i.e. where the test inputs have to be known before training), and the inducing inputs Xu were chosen to be the test inputs. We discuss transduction in detail in the next section. It is important to realize that the BCM proposes two orthogonal ideas: ﬁrst, the block diagonal structure of the partially independent training conditional, and second setting the inducing inputs to be the test inputs. These two ideas can be used independently and in Section 8 we propose using the ﬁrst without the second. The computational complexity of the PITC approximation depends on the blocking structure imposed in (26). A reasonable choice, also recommended by Tresp (2000) may be to choose k = n/m blocks, each of size m × m. The computational complexity remains O (nm2 ). Since in the PITC model the covariance is computed differently for training and test cases Remark 8 The PITC approximation does not correspond exactly to a Gaussian process. This is because computing covariances requires knowing whether points are from the training- or test-set, (27). One can obtain a Gaussian process from the PITC by extending the partial conditional independence assumption to the test conditional, as we did in Remark 7 for the FITC. 8. Transduction and Augmentation The idea of transduction is that one should restrict the goal of learning to prediction on a prespeciﬁed set of test cases, rather than trying to learn an entire function (induction) and then evaluate it at the test inputs. There may be no universally agreed upon deﬁnition of transduction. In this paper we use Deﬁnition 9 Transduction occurs only if the predictive distribution depends on other test inputs. This operational deﬁnition excludes models for which there exist an equivalent inductive counterpart. According to this deﬁnition, it is irrelevant when the bulk of the computation takes place. 1948 S PARSE A PPROXIMATE G AUSSIAN P ROCESS R EGRESSION u f∗   e  ¡     ¡ e   e ¡     ¡     e e   ¡       e ¡   r r r fI fI fI 1 2 k Figure 4: Two views on Augmentation. One view is to see that the test latent function value f∗ is now part of the inducing variables u and therefore has access to the training latent function values. An equivalent view is to consider that we have dropped the assumption of conditional independence between f∗ and the training latent function values. Even if f∗ has now direct access to each of the training fi , these still need to go through u to talk to each other if they fall in conditionally independent blocks. We have in this ﬁgure decided to recycle the graph for PITC from Figure 3 to show that all approximations we have presented can be augmented, irrespective of what the approximation for the training conditional is. There are several different possible motivations for transduction: 1) transduction is somehow easier than induction (Vapnik, 1995), 2) the test inputs may reveal important information, which should be used during training. This motivation drives models in semi-supervised learning (studied mostly in the context of classiﬁcation) and 3) for approximate algorithms one may be able to limit the discrepancies of the approximation at the test points. For exact GP models it seems that the ﬁrst reason doesn’t really apply. If you make predictions at the test points that are consistent with a GP, then it is trivial inside the GP framework to extend these to any other input points, and in effect we have done induction. The second reason seems more interesting. However, in a standard GP setting, it is a consequence of the consistency property, see Remark 2, that predictions at one test input are independent of the location of any other test inputs. Therefore transduction can not be married with exact GPs: Remark 10 Transduction can not occur in exact Gaussian process models. Whereas this holds for the usual setting of GPs, it could be different in non-standard situations where e.g. the covariance function depends on the empirical input densities. Transduction can occur in the sparse approximation to GPs, by making the choice of inducing variables depend on the test inputs. The BCM from the previous section, where Xu = X∗ (where X∗ are the test inputs) is an example of this. Since the inducing variables are connected to all other nodes (see Figure 3) we would expect the approximation to be good at u = f∗ , which is what we care about for predictions, relating to reason 3) above. While this reasoning is sound, it is not necessarily a sufﬁcient consideration for getting a good model. The model has to be able to simultaneously explain the training targets as well and if the choice of u makes this difﬁcult, the posterior at the points of interest may be distorted. Thus, the choice of u should be governed by the ability to model the conditional of the latents given the inputs, and not solely by the density of the (test) inputs. The main drawback of transduction is that by its nature it doesn’t provide a predictive model in the way inductive models do. In the usual GP model one can do the bulk of the computation 1949 ˜ Q UI NONERO -C ANDELA AND R ASMUSSEN involved in the predictive distributions (e.g. matrix inversion) before seeing the test cases, enabling fast computation of test predictions. It is interesting that whereas other methods spend much effort trying to optimize the inducing variables, the BCM simply uses the test set. The quality of the BCM approximation depends then on the particular location of the test inputs, upon which one usually does not have any control. We now see that there may be a better method, eliminating the drawback of transduction, namely use the PITC approximation, but choose the u’s carefully (see Section 9), don’t just use the test set. 8.1 Augmentation An idea closely related to transduction, but not covered by our deﬁnition, is augmentation, which in contrast to transduction is done individually for each test case. Since in the previous sections, we haven’t assumed anything about u, we can simply augment the set of inducing variables by f∗ (i.e. have one additional inducing variable equal to the current test latent), and see what happens in the predictive distributions for the different methods. Let’s ﬁrst investigate the consequences for the test conditional from (9b). Note, the interpretation of the covariance matrix K∗,∗ − Q∗,∗ was “the prior covariance minus the information which u provides about f∗ ”. It is clear that the augmented u (with f∗ ) provides all possible information about f∗ , and consequently Q∗,∗ = K∗,∗ . An equivalent view on augmentation is that the assumption of conditional independence between f∗ and f is dropped. This is seen trivially by adding edges between f∗ and the fi in the graphical model, Figure 4. Augmentation was originally proposed by Rasmussen (2002), and applied in detail to the SoR with RBF covariance by Qui˜ onero-Candela (2004). Because the SoR is a ﬁnite linear model, and n the basis functions are local (Gaussian bumps), the predictive distributions can be very misleading. For example, when making predictions far away from the center of any basis function, all basis functions have insigniﬁcant magnitudes, and the prediction (averaged over the posterior) will be close to zero, with very small error-bars; this is the opposite of the desired behaviour, where we would expect the error-bars to grow as we move away from the training cases. Here augmentation makes a particularly big difference turning the nonsensical predictive distribution into a reasonable one, by ensuring that there is always a basis function centered on the test case. Compare the nonaugmented to the augmented SoR in Figure 5. An analogous Gaussian process based ﬁnite linear model that has recently been healed by augmentation is the relevance vector machine (Rasmussen and Qui˜ onero-Candela, 2005). n Although augmentation was initially proposed for a narrow set of circumstances, it is easily applied to any of the approximations discussed. Of course, augmentation doesn’t make any sense for an exact, non-degenerate Gaussian process model (a GP with a covariance function that has a feature-space which is inﬁnite dimensional, i.e. with basis functions everywhere). Remark 11 A full non-degenerate Gaussian process cannot be augmented, since the corresponding f∗ would already be connected to all other variables in the graphical model. But augmentation does make sense for sparse approximations to GPs. The more general process view on augmentation has several advantages over the basis function view. It is not completely clear from the basis function view, which basis function should be used for augmentation. For example, Rasmussen and Qui˜ onero-Candela (2005) successfully apply augn mentation using basis functions that have a zero contribution at the test location! In the process view 1950 S PARSE A PPROXIMATE G AUSSIAN P ROCESS R EGRESSION however, it seems clear that one would chose the additional inducing variable to be f∗ , to minimize the effects of the approximations. Let us compute the effective prior for the augmented SoR. Given that f∗ is in the inducing set, the test conditional is not an approximation and we can rewrite the integral leading to the effective prior: Z qASoR (f∗ , f) = qSoR (f| f∗ , u) p( f∗ , u) du . (28) It is interesting to notice that this is also the effective prior that would result from augmenting the DTC approximation, since qSoR (f| f∗ , u) = qDTC (f| f∗ , u). Remark 12 Augmented SoR (ASoR) is equivalent to augmented DTC (ADTC). Augmented DTC only differs from DTC in the additional presence of f∗ among the inducing variables in the training conditional. We can only expect augmented DTC to be a more accurate approximation than DTC, since adding an additional inducing variable can only help capture information from y. Therefore Remark 13 DTC is a less accurate (but cheaper) approximation than augmented SoR. We saw previously in Section 5 that the DTC approximation does not suffer from the nonsensical predictive variances of the SoR. The equivalence between the augmented SoR and augmented DTC is another way of seeing how augmentation reverses the misbehaviour of SoR. The predictive distribution of the augmented SoR is obtained by adding f∗ to u in (20). Prediction with an augmented sparse model comes at a higher computational cost, since now f∗ directly interacts with all of f and not just with u. For each new test case, updating the augmented Σ in the predictive equation (for example (20b) for DTC) implies computing the vector matrix product K∗,f Kf,u with complexity O (nm). This is clearly higher than the O (m) for the mean, and O (m2 ) for the predictive distribution of all the non-augmented methods we have discussed. Augmentation seems to be only really necessary for methods that make a severe approximation to the test conditional, like the SoR. For methods that make little or no approximation to the test conditional, it is difﬁcult to predict the degree to which augmentation would help. However, one can see by giving f∗ access to all of the training latent function values in f, one would expect augmentation to give less under-conﬁdent predictive distributions near the training data. Figure 5 clearly shows that augmented DTC (equivalent to augmented SoR) has a superior predictive distribution (both mean and variance) than standard DTC. Note however that in the ﬁgure we have purposely chosen a too short lengthscale to enhance visualization. Quantitatively, this superiority was experimentally assessed by Qui˜ onero-Candela (2004, Table 3.1). Augmentation hasn’t been n compared to the more advanced approximations FITC and PITC, and the ﬁgure would change in the more realistic scenario where the inducing inputs and hyperparameters are learnt (Snelson and Ghahramani, 2006). Transductive methods like the BCM can be seen as joint augmentation, and one could potentially use it for any of the methods presented. It seems that the good performance of the BCM could essentially stem from augmentation, the presence of the other test inputs in the inducing set being probably of little beneﬁt. Joint augmentation might bring some computational advantage, but won’t change the scaling: note that augmenting m times at a cost of O (nm) apiece implies the same O (nm2 ) total cost as the jointly augmented BCM. 1951 ˜ Q UI NONERO -C ANDELA AND R ASMUSSEN SoD SoR 1.5 1.5 1 1 0.5 0.5 0 0 −0.5 −0.5 −1 −1 −1.5 −15 −10 −5 0 5 10 15 −1.5 −15 −10 −5 DTC 0 5 10 15 5 10 15 5 10 15 ASoR/ADTC 1.5 1.5 1 1 0.5 0.5 0 0 −0.5 −0.5 −1 −1 −1.5 −15 −10 −5 0 5 10 15 −1.5 −15 −10 −5 FITC 0 PITC 1.5 1.5 1 1 0.5 0.5 0 0 −0.5 −0.5 −1 −1 −1.5 −15 −10 −5 0 5 10 15 −1.5 −15 −10 −5 0 Figure 5: Toy example with identical covariance function and hyperparameters. The squared exponential covariance function is used, and a slightly too short lengthscale is chosen on purpose to emphasize the different behaviour of the predictive uncertainties. The dots are the training points, the crosses are the targets corresponding to the inducing inputs, randomly selected from the training set. The solid line is the mean of the predictive distribution, and the dotted lines show the 95% conﬁdence interval of the predictions. Augmented DTC (ADTC) is equivalent to augmented SoR (ASoR), see Remark 12. 1952 S PARSE A PPROXIMATE G AUSSIAN P ROCESS R EGRESSION 9. On the Choice of the Inducing Variables We have until now assumed that the inducing inputs Xu were given. Traditionally, sparse models have very often been built upon a carefully chosen subset of the training inputs. This concept is probably best exempliﬁed in the popular support vector machine (Cortes and Vapnik, 1995). In sparse Gaussian processes it has also been suggested to select the inducing inputs Xu from among the training inputs. Since this involves a prohibitive combinatorial optimization, greedy optimization approaches have been suggested using various selection criteria like online learning (Csat´ and o Opper, 2002), greedy posterior maximization (Smola and Bartlett, 2001), maximum information gain (Seeger et al., 2003), matching pursuit (Keerthi and Chu, 2006), and probably more. As discussed in the previous section, selecting the inducing inputs from among the test inputs has also been considered in transductive settings. Recently, Snelson and Ghahramani (2006) have proposed to relax the constraint that the inducing variables must be a subset of training/test cases, turning the discrete selection problem into one of continuous optimization. One may hope that ﬁnding a good solution is easier in the continuous than the discrete case, although ﬁnding the global optimum is intractable in both cases. And perhaps the less restrictive choice can lead to better performance in very sparse models. Which optimality criterion should be used to set the inducing inputs? Departing from a fully Bayesian treatment which would involve deﬁning priors on Xu , one could maximize the marginal likelihood (also called the evidence) with respect to Xu , an approach also followed by Snelson and Ghahramani (2006). Each of the approximate methods proposed involves a different effective prior, and hence its own particular effective marginal likelihood conditioned on the inducing inputs q(y|Xu ) = ZZ p(y|f) q(f|u) p(u|Xu )du df = Z p(y|f) q(f|Xu )df , (29) which of course is independent of the test conditional. We have in the above equation explicitly conditioned on the inducing inputs Xu . Using Gaussian identities, the effective marginal likelihood is very easily obtained by adding a ridge σ2 I (from the likelihood) to the covariance of effective noise prior on f. Using the appropriate deﬁnitions of Λ, the log marginal likelihood becomes 1 log q(y|Xu ) = − 2 log |Qf,f + Λ| − 1 y (Qf,f + Λ)−1 y − n log(2π) , 2 2 (30) where ΛSoR = ΛDTC = σ2 I, ΛFITC = diag[Kf,f − Qf,f ] + σ2 I, and ΛPITC = blockdiag[Kf,f − noise noise Qf,f ] + σ2 I. The computational cost of the marginal likelihood is O (nm2 ) for all methods, that of noise its gradient with respect to one element of Xu is O (nm). This of course implies that the complexity of computing the gradient wrt. to the whole of Xu is O (dnm2 ), where d is the dimension of the input space. It has been proposed to maximize the effective posterior instead of the effective marginal likelihood (Smola and Bartlett, 2001). However this is potentially dangerous and can lead to overﬁtting. Maximizing the whole evidence instead is sound and comes at an identical computational cost (for a deeper analysis see Qui˜ onero-Candela, 2004, Sect. 3.3.5 and Fig. 3.2). n The marginal likelihood has traditionally been used to learn the hyperparameters of GPs in the non fully Bayesian treatment (see for example Williams and Rasmussen, 1996). For the sparse approximations presented here, once you are learning Xu it is straightforward to allow for learning hyperparameters (of the covariance function) during the same optimization, and there is no need to interleave optimization of u with learning of the hyperparameters as it has been proposed for example by Seeger et al. (2003). 1953 ˜ Q UI NONERO -C ANDELA AND R ASMUSSEN 10. Other Methods In this section we brieﬂy mention two approximations which don’t ﬁt in our unifying scheme, since one doesn’t correspond to a proper probabilistic model, and the other one uses a particular construction for the covariance function, rather than allowing any general covariance function. 10.1 The Nystr¨ m Approximation o The Nystr¨ m Approximation for speeding up GP regression was originally proposed by Williams o and Seeger (2001), and then questioned by Williams et al. (2002). Like SoR and DTC, the Nystr¨ m o Approximation for GP regression approximates the prior covariance of f by Qf,f . However, unlike these methods, the Nystr¨ m Approximation is not based on a generative probabilistic model. The o prior covariance between f∗ and f is taken to be exact, which is inconsistent with the prior covariance on f: Qf,f Kf,∗ . (31) q(f, f∗ ) = N 0, K∗,f K∗,∗ As a result we cannot derive this method from our unifying framework, nor represent it with a graphical model. Worse, the resulting prior covariance matrix is not even guaranteed to be positive deﬁnite, allowing the predictive variances to be negative. Notice that replacing Kf,∗ by Qf,∗ in (31) is enough to make the prior covariance positive deﬁnite, and one obtains the DTC approximation. Remark 14 The Nystr¨ m Approximation does not correspond to a well-formed probabilistic model. o Ignoring any quibbles about positive deﬁniteness, the predictive distribution of the Nystr¨ m Apo proximation is given by: p( f∗ |y) = N Kf,∗ [Qf,f + σ2 I]−1 y, K∗,∗ − Kf,∗ [Qf,f + σ2 I]−1 Kf,∗ , noise noise (32) but the predictive variance is not guaranteed to be positive. The computational cost is O (nm2 ). 10.2 The Relevance Vector Machine The relevance vector machine, introduced by Tipping (2001), is a ﬁnite linear model with an independent Gaussian prior imposed on the weights. For any input x∗ , the corresponding function output is given by: f∗ = φ∗ w , with p(w|A) = N (0, A) , (33) where φ∗ = [φ1 (x), . . . , φm (x)] is the (row) vector of responses of the m basis functions, and A = diag(α1 , . . . , αm ) is the diagonal matrix of joint prior precisions (inverse variances) of the weights. The αi are learnt by maximizing the RVM evidence (obtained by also assuming Gaussian additive iid. noise, see (1)), and for the typical case of rich enough sets of basis functions many of the precisions go to inﬁnity effectively pruning out the corresponding weights (for a very interesting analysis see Wipf et al., 2004). The RVM is thus a sparse method and the surviving basis functions are called relevance vectors. Note that since the RVM is a ﬁnite linear model with Gaussian priors on the weights, it can be seen as a Gaussian process: Remark 15 The RVM is equivalent to a degenerate Gaussian process with covariance function kRVM (xi , x j ) = φi A−1 φ j = ∑m α−1 φk (xi ) φk (x j ), k=1 k 1954 S PARSE A PPROXIMATE G AUSSIAN P ROCESS R EGRESSION q(f∗ |u) q(f|u) GP exact exact SoR determ. determ. DTC exact determ. FITC (exact) fully indep. PITC exact partially indep. Method joint prior covariance Kf,f Kf,∗ K∗,f K∗,∗ Qf,f Qf,∗ Q∗,f Q∗,∗ Qf,f Qf,∗ Q∗,f K∗,∗ Qf,f − diag[Qf,f − Kf,f ] Qf,∗ Q∗,f K∗,∗ Qf,f − blokdiag[Qf,f − Kf,f ] Qf,∗ Q∗,f K∗,∗ GP? √ √ √ ( ) Table 1: Summary of the way approximations are built. All these methods are detailed in the previous sections. The initial cost and that of the mean and variance per test case are respectively n2 , n and n2 for the exact GP, and nm2 , m and m2 for all other methods. The “GP?” column indicates whether the approximation is equivalent to a GP. For FITC see Remark 7. as was also pointed out by Tipping (2001, eq. (59)). Whereas all sparse approximations we have presented until now are totally independent of the choice of covariance function, for the RVM this choice is restricted to covariance functions that can be expressed as ﬁnite expansions in terms of some basis functions. Being degenerate GPs in exactly the same way as the SoR (presented in Section 4), the RVM does also suffer from unreasonable predictive variances. Rasmussen and Qui˜ onero-Candela (2005) show that the predictive distributions of RVMs can also be healed by n augmentation, see Section 8. Once the αi have been learnt, denoting by m the number of surviving relevance vectors, the complexity of computing the predictive distribution of the RVM is O (m) for mean and O (m2 ) for the variance. RVMs are often used with radial basis functions centered on the training inputs. One potentially interesting extension to the RVM would be to learn the locations of the centers of the basis functions, in the same way as proposed by Snelson and Ghahramani (2006) for the FITC approximation, see Section 6. This is a curious reminiscence of learning the centers in RBF Networks. 11. Conclusions We have provided a unifying framework for sparse approximations to Gaussian processes for regression. Our approach consists of two steps, ﬁrst 1) we recast the approximation in terms of approximations to the prior, and second 2) we introduce inducing variables u and the idea of conditional independence given u. We recover all existing sparse methods by making further simpliﬁcations of the covariances of the training and test conditionals, see Table 1 for a summary. Previous methods were presented based on different approximation paradigms (e.g. likelihood approximations, projection methods, matrix approximations, minimization of Kullback-Leibler divergence, etc), making direct comparison difﬁcult. Under our unifying view we deconstruct methods, making it clear which building blocks they are based upon. For example, the SGPP by Snelson 1955 ˜ Q UI NONERO -C ANDELA AND R ASMUSSEN and Ghahramani (2006) contains two ideas, 1) a likelihood approximation and 2) the idea of varying the inducing inputs continuously; these two ideas could easily be used independently, and incorporated in other methods. Similarly, the BCM by Tresp (2000) contains two independent ideas 1) a block diagonal assumption, and 2) the (transductive) idea of choosing the test inputs as the inducing variables. Finally we note that although all three ideas of 1) transductively setting u = f∗ , 2) augmentation and 3) continuous optimization of Xu have been proposed in very speciﬁc settings, in fact they are completely general ideas, which can be applied to any of the approximation schemes considered. We have ranked the approximation according to how close they are to the corresponding full GP. However, the performance in practical situations may not always follow this theoretical ranking since the approximations might exhibit properties (not present in the full GP) which may be particularly suitable for speciﬁc datasets. This may make the interpretation of empirical comparisons challenging. A further complication arises when adding the necessary heuristics for turning the theoretical constructs into practical algorithms. We have not described full algorithms in this paper, but are currently working on a detailed empirical study (in preparation, see also Rasmussen and Williams, 2006, chapter 8). We note that the order of the computational complexity is identical for all the methods considered, O (nm2 ). This highlights that there is no computational excuse for using gross approximations, such as assuming deterministic relationships, in particular one should probably think twice before using SoR or even DTC. Although augmentation has attractive predictive properties, it is computationally expensive. It remains unclear whether augmentation could be beneﬁcial on a ﬁxed computational budget. We have only considered the simpler case of regression in this paper, but sparseness is also commonly sought in classiﬁcation settings. It should not be difﬁcult to cast probabilistic approximation methods such as Expectation Propagation (EP) or the Laplace method (for a comparison, see Kuss and Rasmussen, 2005) into our unifying framework. Our analysis suggests that a new interesting approximation would come from combining the best possible approximation (PITC) with the most powerful selection method for the inducing inputs. This would correspond to a non-transductive version of the BCM. We would evade the necessity of knowing the test set before doing the bulk of the computation, and we could hope to supersede the superior performance reported by Snelson and Ghahramani (2006) for very sparse approximations. Acknowledgments Thanks to Neil Lawrence for arranging the 2005 Gaussian Process Round Table meeting in Shefﬁeld, which provided much inspiration to this paper. Special thanks to Olivier Chapelle, Lehel Csat´ , o Zoubin Ghahramani, Matthias Seeger, Ed Snelson and Chris Williams for helpful discussions, and to three anonymous reviewers. Both authors were supported by the German Research Council (DFG) through grant RA 1030/1. This work was supported in part by the IST Programme of the European Community, under the PASCAL Network of Excellence, IST-2002-506778. 1956 S PARSE A PPROXIMATE G AUSSIAN P ROCESS R EGRESSION Appendix A. Gaussian and Matrix Identities In this appendix we provide identities used to manipulate matrices and Gaussian distributions throughout the paper. Let x and y be jointly Gaussian x y µx µy ∼ N , A C C B , (34) then the marginal and the conditional are given by x ∼ N (µx , A) , and x|y ∼ N µx +C B−1 (y − µy ), A −C B−1C (35) Also, the product of a Gaussian in x with a Gaussian in a linear projection P x is again a Gaussian, although unnormalized N (x|a, A) N (P x|b, B) = zc N (x|c,C) , (36) where C = A−1 + P B−1 P −1 c = C A−1 a + P B−1 b . , The normalizing constant zc is gaussian in the means a and b of the two Gaussians: m 1 1 zc = (2 π)− 2 |B + P A P |− 2 exp − 2 (b − P a) B+PAP −1 (b − P a) . (37) The matrix inversion lemma, also known as the Woodbury, Sherman & Morrison formula states that: (Z +UWV )−1 = Z −1 − Z −1U(W −1 +V Z −1U)−1V Z −1 , (38) assuming the relevant inverses all exist. Here Z is n × n, W is m × m and U and V are both of size n × m; consequently if Z −1 is known, and a low rank (ie. m < n) perturbation are made to Z as in left hand side of eq. (38), considerable speedup can be achieved. References Corinna Cortes and Vladimir Vapnik. Support-vector network. Machine Learning, 20(3):273–297, 1995. Lehel Csat´ and Manfred Opper. Sparse online Gaussian processes. Neural Computation, 14(3): o 641–669, 2002. Sathiya Keerthi and Wei Chu. A Matching Pursuit approach to sparse Gaussian process regression. In Y. Weiss, B. Sch¨ lkopf, and J. Platt, editors, Advances in Neural Information Processing o Systems 18, Cambridge, Massachussetts, 2006. The MIT Press. Malte Kuss and Carl Edward Rasmussen. Assessing approximate inference for binary Gaussian process classiﬁcation. Journal of Machine Learning Research, pages 1679–1704, 2005. Joaquin Qui˜ onero-Candela. Learning with Uncertainty – Gaussian Processes and Relevance Vecn tor Machines. PhD thesis, Technical University of Denmark, Lyngby, Denmark, 2004. Carl Edward Rasmussen. Reduced rank Gaussian process learning. Technical report, Gatsby Computational Neuroscience Unit, UCL, 2002. 1957 ˜ Q UI NONERO -C ANDELA AND R ASMUSSEN Carl Edward Rasmussen and Joaquin Qui˜ onero-Candela. Healing the relevance vector machine by n augmentation. In International Conference on Machine Learning, 2005. Carl Edward Rasmussen and Christopher K. I. Williams. Gaussian Processes for Machine Learning. The MIT press, 2006. Anton Schwaighofer and Volker Tresp. Transductive and inductive methods for approximate Gaussian process regression. In Suzanna Becker, Sebastian Thrun, and Klaus Obermayer, editors, Advances in Neural Information Processing Systems 15, pages 953–960, Cambridge, Massachussetts, 2003. The MIT Press. Matthias Seeger, Christopher K. I. Williams, and Neil Lawrence. Fast forward selection to speed up sparse Gaussian process regression. In Christopher M. Bishop and Brendan J. Frey, editors, Ninth International Workshop on Artiﬁcial Intelligence and Statistics. Society for Artiﬁcial Intelligence and Statistics, 2003. Bernhard W. Silverman. Some aspects of the spline smoothing approach to non-parametric regression curve ﬁtting. J. Roy. Stat. Soc. B, 47(1):1–52, 1985. (with discussion). Alexander J. Smola and Peter L. Bartlett. Sparse greedy Gaussian process regression. In Todd K. Leen, Thomas G. Dietterich, and Volker Tresp, editors, Advances in Neural Information Processing Systems 13, pages 619–625, Cambridge, Massachussetts, 2001. The MIT Press. Edward Snelson and Zoubin Ghahramani. Sparse Gaussian processes using pseudo-inputs. In Y. Weiss, B. Sch¨ lkopf, and J. Platt, editors, Advances in Neural Information Processing Systems o 18, Cambridge, Massachussetts, 2006. The MIT Press. Michael E. Tipping. Sparse Bayesian learning and the Relevance Vector Machine. Journal of Machine Learning Research, 1:211–244, 2001. Volker Tresp. A Bayesian committee machine. Neural Computation, 12(11):2719–2741, 2000. Vladimir N. Vapnik. The Nature of Statistical Learning Theory. Springer Verlag, 1995. Grace Wahba, Xiwu Lin, Fangyu Gao, Dong Xiang, Ronald Klein, and Barbara Klein. The biasvariance tradeoff and the randomized GACV. In Michael S. Kerns, Sara A. Solla, and David A. Cohn, editors, Advances in Neural Information Processing Systems 11, pages 620–626, Cambridge, Massachussetts, 1999. The MIT Press. Christopher K. I. Williams and Carl Edward Rasmussen. Gaussian processes for regression. In David S. Touretzky, Michael C. Mozer, and Michael E. Hasselmo, editors, Advances in Neural Information Processing Systems 8, pages 514–520, Cambridge, Massachussetts, 1996. The MIT Press. Christopher K. I. Williams, Carl Edward Rasmussen, Anton Schwaighofer, and Volker Tresp. Observations of the Nystr¨ m method for Gaussiam process prediction. Technical report, University o of Edinburgh, Edinburgh, Scotland, 2002. 1958 S PARSE A PPROXIMATE G AUSSIAN P ROCESS R EGRESSION Christopher K. I. Williams and Mathias Seeger. Using the Nystr¨ m method to speed up kernel o machines. In Todd K. Leen, Thomas G. Dietterich, and Volker Tresp, editors, Advances in Neural Information Processing Systems 13, pages 682–688, Cambridge, Massachussetts, 2001. The MIT Press. David Wipf, Jason Palmer, and Bhaskar Rao. Perspectives on sparse Bayesian learning. In Sebastian Thrun, Lawrence Saul, and Bernhard Sch¨ lkopf, editors, Advances in Neural Information o Processing Systems 16, Cambridge, Massachussetts, 2004. The MIT Press. 1959</p><p>5 0.07744509 <a title="62-tfidf-5" href="./jmlr-2005-Variational_Message_Passing.html">71 jmlr-2005-Variational Message Passing</a></p>
<p>Author: John Winn, Christopher M. Bishop</p><p>Abstract: Bayesian inference is now widely established as one of the principal foundations for machine learning. In practice, exact inference is rarely possible, and so a variety of approximation techniques have been developed, one of the most widely used being a deterministic framework called variational inference. In this paper we introduce Variational Message Passing (VMP), a general purpose algorithm for applying variational inference to Bayesian Networks. Like belief propagation, VMP proceeds by sending messages between nodes in the network and updating posterior beliefs using local operations at each node. Each such update increases a lower bound on the log evidence (unless already at a local maximum). In contrast to belief propagation, VMP can be applied to a very general class of conjugate-exponential models because it uses a factorised variational approximation. Furthermore, by introducing additional variational parameters, VMP can be applied to models containing non-conjugate distributions. The VMP framework also allows the lower bound to be evaluated, and this can be used both for model comparison and for detection of convergence. Variational message passing has been implemented in the form of a general purpose inference engine called VIBES (‘Variational Inference for BayEsian networkS’) which allows models to be speciﬁed graphically and then solved variationally without recourse to coding. Keywords: Bayesian networks, variational inference, message passing</p><p>6 0.053656034 <a title="62-tfidf-6" href="./jmlr-2005-Semigroup_Kernels_on_Measures.html">64 jmlr-2005-Semigroup Kernels on Measures</a></p>
<p>7 0.053552836 <a title="62-tfidf-7" href="./jmlr-2005-Active_Learning_to_Recognize_Multiple_Types_of_Plankton.html">9 jmlr-2005-Active Learning to Recognize Multiple Types of Plankton</a></p>
<p>8 0.053515114 <a title="62-tfidf-8" href="./jmlr-2005-Feature_Selection_for_Unsupervised_and_Supervised_Inference%3A_The_Emergence_of_Sparsity_in_a_Weight-Based_Approach.html">34 jmlr-2005-Feature Selection for Unsupervised and Supervised Inference: The Emergence of Sparsity in a Weight-Based Approach</a></p>
<p>9 0.053126551 <a title="62-tfidf-9" href="./jmlr-2005-Learning_Multiple_Tasks_with_Kernel_Methods.html">45 jmlr-2005-Learning Multiple Tasks with Kernel Methods</a></p>
<p>10 0.052258763 <a title="62-tfidf-10" href="./jmlr-2005-Asymptotic_Model_Selection_for_Naive_Bayesian_Networks.html">15 jmlr-2005-Asymptotic Model Selection for Naive Bayesian Networks</a></p>
<p>11 0.051000174 <a title="62-tfidf-11" href="./jmlr-2005-Learning_the_Kernel_with_Hyperkernels_%C2%A0%C2%A0%C2%A0%C2%A0%28Kernel_Machines_Section%29.html">49 jmlr-2005-Learning the Kernel with Hyperkernels     (Kernel Machines Section)</a></p>
<p>12 0.050983962 <a title="62-tfidf-12" href="./jmlr-2005-A_Bayesian_Model_for_Supervised_Clustering_with_the_Dirichlet_Process_Prior.html">2 jmlr-2005-A Bayesian Model for Supervised Clustering with the Dirichlet Process Prior</a></p>
<p>13 0.04738652 <a title="62-tfidf-13" href="./jmlr-2005-Information_Bottleneck_for_Gaussian_Variables.html">39 jmlr-2005-Information Bottleneck for Gaussian Variables</a></p>
<p>14 0.047343779 <a title="62-tfidf-14" href="./jmlr-2005-Fast_Kernel_Classifiers_with_Online_and_Active_Learning.html">33 jmlr-2005-Fast Kernel Classifiers with Online and Active Learning</a></p>
<p>15 0.047109686 <a title="62-tfidf-15" href="./jmlr-2005-Expectation_Consistent_Approximate_Inference.html">32 jmlr-2005-Expectation Consistent Approximate Inference</a></p>
<p>16 0.043860517 <a title="62-tfidf-16" href="./jmlr-2005-Diffusion_Kernels_on_Statistical_Manifolds.html">26 jmlr-2005-Diffusion Kernels on Statistical Manifolds</a></p>
<p>17 0.043245677 <a title="62-tfidf-17" href="./jmlr-2005-Matrix_Exponentiated_Gradient_Updates_for_On-line_Learning_and_Bregman_Projection.html">55 jmlr-2005-Matrix Exponentiated Gradient Updates for On-line Learning and Bregman Projection</a></p>
<p>18 0.042729791 <a title="62-tfidf-18" href="./jmlr-2005-Quasi-Geodesic_Neural_Learning_Algorithms_Over_the_Orthogonal_Group%3A_A_Tutorial.html">63 jmlr-2005-Quasi-Geodesic Neural Learning Algorithms Over the Orthogonal Group: A Tutorial</a></p>
<p>19 0.041917302 <a title="62-tfidf-19" href="./jmlr-2005-Separating_a_Real-Life_Nonlinear_Image_Mixture.html">65 jmlr-2005-Separating a Real-Life Nonlinear Image Mixture</a></p>
<p>20 0.04106278 <a title="62-tfidf-20" href="./jmlr-2005-Dimension_Reduction_in_Text_Classification_with_Support_Vector_Machines.html">27 jmlr-2005-Dimension Reduction in Text Classification with Support Vector Machines</a></p>
<br/>
<h2>similar papers computed by <a title="lsi-model" href="../home/jmlr2005_lsi.html">lsi model</a></h2><h3>lsi for this paper:</h3><p>topicId topicWeight</p>
<p>[(0, 0.257), (1, -0.021), (2, -0.072), (3, -0.041), (4, 0.172), (5, 0.002), (6, 0.027), (7, 0.127), (8, -0.09), (9, 0.197), (10, 0.036), (11, -0.068), (12, -0.005), (13, 0.02), (14, -0.14), (15, -0.048), (16, -0.007), (17, -0.046), (18, -0.13), (19, -0.069), (20, 0.01), (21, -0.208), (22, -0.05), (23, 0.014), (24, -0.149), (25, -0.1), (26, 0.098), (27, -0.011), (28, -0.062), (29, -0.061), (30, 0.082), (31, 0.049), (32, -0.23), (33, 0.143), (34, 0.051), (35, -0.074), (36, 0.318), (37, -0.103), (38, 0.07), (39, 0.275), (40, 0.073), (41, 0.266), (42, -0.096), (43, -0.013), (44, -0.088), (45, 0.051), (46, -0.148), (47, -0.14), (48, 0.121), (49, -0.135)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 0.95543194 <a title="62-lsi-1" href="./jmlr-2005-Probabilistic_Non-linear_Principal_Component_Analysis_with_Gaussian_Process_Latent_Variable_Models.html">62 jmlr-2005-Probabilistic Non-linear Principal Component Analysis with Gaussian Process Latent Variable Models</a></p>
<p>Author: Neil Lawrence</p><p>Abstract: Summarising a high dimensional data set with a low dimensional embedding is a standard approach for exploring its structure. In this paper we provide an overview of some existing techniques for discovering such embeddings. We then introduce a novel probabilistic interpretation of principal component analysis (PCA) that we term dual probabilistic PCA (DPPCA). The DPPCA model has the additional advantage that the linear mappings from the embedded space can easily be nonlinearised through Gaussian processes. We refer to this model as a Gaussian process latent variable model (GP-LVM). Through analysis of the GP-LVM objective function, we relate the model to popular spectral techniques such as kernel PCA and multidimensional scaling. We then review a practical algorithm for GP-LVMs in the context of large data sets and develop it to also handle discrete valued data and missing attributes. We demonstrate the model on a range of real-world and artiﬁcially generated data sets. Keywords: Gaussian processes, latent variable models, principal component analysis, spectral methods, unsupervised learning, visualisation</p><p>2 0.37803233 <a title="62-lsi-2" href="./jmlr-2005-A_Unifying_View_of_Sparse_Approximate_Gaussian_Process_Regression.html">7 jmlr-2005-A Unifying View of Sparse Approximate Gaussian Process Regression</a></p>
<p>Author: Joaquin Quiñonero-Candela, Carl Edward Rasmussen</p><p>Abstract: We provide a new unifying view, including all existing proper probabilistic sparse approximations for Gaussian process regression. Our approach relies on expressing the effective prior which the methods are using. This allows new insights to be gained, and highlights the relationship between existing methods. It also allows for a clear theoretically justiﬁed ranking of the closeness of the known approximations to the corresponding full GPs. Finally we point directly to designs of new better sparse approximations, combining the best of the existing strategies, within attractive computational constraints. Keywords: Gaussian process, probabilistic regression, sparse approximation, Bayesian committee machine Regression models based on Gaussian processes (GPs) are simple to implement, ﬂexible, fully probabilistic models, and thus a powerful tool in many areas of application. Their main limitation is that memory requirements and computational demands grow as the square and cube respectively, of the number of training cases n, effectively limiting a direct implementation to problems with at most a few thousand cases. To overcome the computational limitations numerous authors have recently suggested a wealth of sparse approximations. Common to all these approximation schemes is that only a subset of the latent variables are treated exactly, and the remaining variables are given some approximate, but computationally cheaper treatment. However, the published algorithms have widely different motivations, emphasis and exposition, so it is difﬁcult to get an overview (see Rasmussen and Williams, 2006, chapter 8) of how they relate to each other, and which can be expected to give rise to the best algorithms. In this paper we provide a unifying view of sparse approximations for GP regression. Our approach is simple, but powerful: for each algorithm we analyze the posterior, and compute the effective prior which it is using. Thus, we reinterpret the algorithms as “exact inference with an approximated prior”, rather than the existing (ubiquitous) interpretation “approximate inference with the exact prior”. This approach has the advantage of directly expressing the approximations in terms of prior assumptions about the function, which makes the consequences of the approximations much easier to understand. While our view of the approximations is not the only one possible, it has the advantage of putting all existing probabilistic sparse approximations under one umbrella, thus enabling direct comparison and revealing the relation between them. In Section 1 we brieﬂy introduce GP models for regression. In Section 2 we present our unifying framework and write out the key equations in preparation for the unifying analysis of sparse c 2005 Joaquin Qui˜ onero-Candela and Carl Edward Rasmussen. n ˜ Q UI NONERO -C ANDELA AND R ASMUSSEN algorithms in Sections 4-7. The relation of transduction and augmentation to our sparse framework is covered in Section 8. All our approximations are written in terms of a new set of inducing variables. The choice of these variables is itself a challenging problem, and is discussed in Section 9. We comment on a few special approximations outside our general scheme in Section 10 and conclusions are drawn at the end. 1. Gaussian Processes for Regression Probabilistic regression is usually formulated as follows: given a training set D = {(xi , yi ), i = 1, . . . , n} of n pairs of (vectorial) inputs xi and noisy (real, scalar) outputs yi , compute the predictive distribution of the function values f∗ (or noisy y∗ ) at test locations x∗ . In the simplest case (which we deal with here) we assume that the noise is additive, independent and Gaussian, such that the relationship between the (latent) function f (x) and the observed noisy targets y are given by yi = f (xi ) + εi , where εi ∼ N (0, σ2 ) , noise (1) where σ2 is the variance of the noise. noise Deﬁnition 1 A Gaussian process (GP) is a collection of random variables, any ﬁnite number of which have consistent1 joint Gaussian distributions. Gaussian process (GP) regression is a Bayesian approach which assumes a GP prior2 over functions, i.e. assumes a priori that function values behave according to p(f|x1 , x2 , . . . , xn ) = N (0, K) , (2) where f = [ f1 , f2 , . . . , fn ] is a vector of latent function values, fi = f (xi ) and K is a covariance matrix, whose entries are given by the covariance function, Ki j = k(xi , x j ). Note that the GP treats the latent function values fi as random variables, indexed by the corresponding input. In the following, for simplicity we will always neglect the explicit conditioning on the inputs; the GP model and all expressions are always conditional on the corresponding inputs. The GP model is concerned only with the conditional of the outputs given the inputs; we do not model anything about the inputs themselves. Remark 2 Note, that to adhere to a strict Bayesian formalism, the GP covariance function,3 which deﬁnes the prior, should not depend on the data (although it can depend on additional parameters). As we will see in later sections, some approximations are strictly equivalent to GPs, while others are not. That is, the implied prior may still be multivariate Gaussian, but the covariance function may be different for training and test cases. Deﬁnition 3 A Gaussian process is called degenerate iff the covariance function has a ﬁnite number of non-zero eigenvalues. 1. By consistency is meant simply that the random variables obey the usual rules of marginalization, etc. 2. For notational simplicity we exclusively use zero-mean priors. 3. The covariance function itself shouldn’t depend on the data, though its value at a speciﬁc pair of inputs of course will. 1940 S PARSE A PPROXIMATE G AUSSIAN P ROCESS R EGRESSION Degenerate GPs (such as e.g. with polynomial covariance function) correspond to ﬁnite linear (-in-the-parameters) models, whereas non-degenerate GPs (such as e.g. with squared exponential or RBF covariance function) do not. The prior for a ﬁnite m dimensional linear model only considers a universe of at most m linearly independent functions; this may often be too restrictive when n m. Note however, that non-degeneracy on its own doesn’t guarantee the existence of the “right kind” of ﬂexibility for a given particular modelling task. For a more detailed background on GP models, see for example that of Rasmussen and Williams (2006). Inference in the GP model is simple: we put a joint GP prior on training and test latent values, f and f∗ 4 , and combine it with the likelihood5 p(y|f) using Bayes rule, to obtain the joint posterior p(f, f∗ )p(y|f) . p(y) p(f, f∗ |y) = (3) The ﬁnal step needed to produce the desired posterior predictive distribution is to marginalize out the unwanted training set latent variables: p(f∗ |y) = Z 1 p(y) p(f, f∗ |y)df = Z p(y|f) p(f, f∗ ) df , (4) or in words: the predictive distribution is the marginal of the renormalized joint prior times the likelihood. The joint GP prior and the independent likelihood are both Gaussian p(f, f∗ ) = N 0, Kf,f K∗,f Kf,∗ K∗,∗ , and p(y|f) = N (f, σ2 I) , noise (5) where K is subscript by the variables between which the covariance is computed (and we use the asterisk ∗ as shorthand for f∗ ) and I is the identity matrix. Since both factors in the integral are Gaussian, the integral can be evaluated in closed form to give the Gaussian predictive distribution p(f∗ |y) = N K∗,f (Kf,f + σ2 I)−1 y, K∗,∗ − K∗,f (Kf,f + σ2 I)−1 Kf,∗ , noise noise (6) see the relevant Gaussian identity in appendix A. The problem with the above expression is that it requires inversion of a matrix of size n × n which requires O (n3 ) operations, where n is the number of training cases. Thus, the simple exact implementation can handle problems with at most a few thousand training cases. 2. A New Unifying View We now seek to modify the joint prior p(f∗ , f) from (5) in ways which will reduce the computational requirements from (6). Let us ﬁrst rewrite that prior by introducing an additional set of m latent variables u = [u1 , . . . , um ] , which we call the inducing variables. These latent variables are values of the Gaussian process (as also f and f∗ ), corresponding to a set of input locations Xu , which we call the inducing inputs. Whereas the additional latent variables u are always marginalized out in the predictive distribution, the choice of inducing inputs does leave an imprint on the ﬁnal solution. 4. We will mostly consider a vector of test cases f∗ (rather than a single f∗ ). 5. You may have been expecting the likelihood written as p(y|f∗ , f) but since the likelihood is conditionally independent of everything else given f, this makes no difference. 1941 ˜ Q UI NONERO -C ANDELA AND R ASMUSSEN The inducing variables will turn out to be generalizations of variables which other authors have referred to variously as “support points”, “active set” or “pseudo-inputs”. Particular sparse algorithms choose the inducing variables in various different ways; some algorithms chose the inducing inputs to be a subset of the training set, others not, as we will discuss in Section 9. For now consider any arbitrary inducing variables. Due to the consistency of Gaussian processes, we know that we can recover p(f∗ , f) by simply integrating (marginalizing) out u from the joint GP prior p(f∗ , f, u) p(f∗ , f) = Z p(f∗ , f, u) du = Z p(f∗ , f|u) p(u) du, where p(u) = N (0, Ku,u ) . (7) This is an exact expression. Now, we introduce the fundamental approximation which gives rise to almost all sparse approximations. We approximate the joint prior by assuming that f∗ and f are conditionally independent given u, see Figure 1, such that p(f∗ , f) q(f∗ , f) = Z q(f∗ |u) q(f|u) p(u) du . (8) The name inducing variable is motivated by the fact that f and f∗ can only communicate though u, and u therefore induces the dependencies between training and test cases. As we shall detail in the following sections, the different computationally efﬁcient algorithms proposed in the literature correspond to different additional assumptions about the two approximate inducing conditionals q(f|u), q(f∗ |u) of the integral in (8). It will be useful for future reference to specify here the exact expressions for the two conditionals training conditional: test conditional: −1 p(f|u) = N (Kf,u Ku,u u, Kf,f − Qf,f ) , −1 p(f∗ |u) = N (K∗,u Ku,u u, K∗,∗ − Q∗,∗ ) , (9a) (9b) −1 where we have introduced the shorthand notation6 Qa,b Ka,u Ku,u Ku,b . We can readily identify the expressions in (9) as special (noise free) cases of the standard predictive equation (6) with u playing the role of (noise free) observations. Note that the (positive semi-deﬁnite) covariance matrices in (9) have the form K − Q with the following interpretation: the prior covariance K minus a (non-negative deﬁnite) matrix Q quantifying how much information u provides about the variables in question (f or f∗ ). We emphasize that all the sparse methods discussed in the paper correspond simply to different approximations to the conditionals in (9), and throughout we use the exact likelihood and inducing prior p(y|f) = N (f, σ2 I) , and p(u) = N (0, Ku,u ) . (10) noise 3. The Subset of Data (SoD) Approximation Before we get started with the more sophisticated approximations, we mention as a baseline method the simplest possible sparse approximation (which doesn’t fall inside our general scheme): use only a subset of the data (SoD). The computational complexity is reduced to O (m3 ), where m < n. We would not generally expect SoD to be a competitive method, since it would seem impossible (even with fairly redundant data and a good choice of the subset) to get a realistic picture of the 6. Note, that Qa,b depends on u although this is not explicit in the notation. 1942 S PARSE A PPROXIMATE G AUSSIAN P ROCESS R EGRESSION u u    e ¡   ¡ e  e    ¡  e   ¡  e   ¡   e ¡   r r r r r fn f1 f2 f∗    e ¡   ¡ e  e    ¡  e   ¡  e   ¡   e ¡   r r r r r fn f1 f2 f∗ Figure 1: Graphical model of the relation between the inducing variables u, the training latent functions values f = [ f1 , . . . , fn ] and the test function value f∗ . The thick horizontal line represents a set of fully connected nodes. The observations y1 , . . . , yn , y∗ (not shown) would dangle individually from the corresponding latent values, by way of the exact (factored) likelihood (5). Left graph: the fully connected graph corresponds to the case where no approximation is made to the full joint Gaussian process distribution between these variables. The inducing variables u are superﬂuous in this case, since all latent function values can communicate with all others. Right graph: assumption of conditional independence between training and test function values given u. This gives rise to the separation between training and test conditionals from (8). Notice that having cut the communication path between training and test latent function values, information from f can only be transmitted to f∗ via the inducing variables u. uncertainties, when only a part of the training data is even considered. We include it here mostly as a baseline against which to compare better sparse approximations. In Figure 5 top, left we see how the SoD method produces wide predictive distributions, when training on a randomly selected subset of 10 cases. A fair comparison to other methods would take into account that the computational complexity is independent of n as opposed to other more advanced methods. These extra computational resources could be spent in a number of ways, e.g. larger m, or an active (rather than random) selection of the m points. In this paper we will concentrate on understanding the theoretical foundations of the various approximations rather than investigating the necessary heuristics needed to turn the approximation schemes into actually practical algorithms. 4. The Subset of Regressors (SoR) Approximation The Subset of Regressors (SoR) algorithm was given by Silverman (1985), and mentioned again by Wahba et al. (1999). It was then adapted by Smola and Bartlett (2001) to propose a sparse greedy approximation to Gaussian process regression. SoR models are ﬁnite linear-in-the-parameters models with a particular prior on the weights. For any input x∗ , the corresponding function value f∗ is given by: f∗ = K∗,u wu , with −1 p(wu ) = N (0, Ku,u ) , (11) where there is one weight associated to each inducing input in Xu . Note that the covariance matrix for the prior on the weights is the inverse of that on u, such that we recover the exact GP prior on u, 1943 ˜ Q UI NONERO -C ANDELA AND R ASMUSSEN which is Gaussian with zero mean and covariance u = Ku,u wu ⇒ uu = Ku,u wu wu Ku,u = Ku,u . (12) −1 Using the effective prior on u and the fact that wu = Ku,u u we can redeﬁne the SoR model in an equivalent, more intuitive way: −1 f∗ = K∗,u Ku,u u , with u ∼ N (0, Ku,u ) . (13) We are now ready to integrate the SoR model in our unifying framework. Given that there is a deterministic relation between any f∗ and u, the approximate conditional distributions in the integral in eq. (8) are given by: −1 qSoR (f|u) = N (Kf,u Ku,u u, 0) , and −1 qSoR (f∗ |u) = N (K∗,u Ku,u u, 0) , (14) with zero conditional covariance, compare to (9). The effective prior implied by the SoR approximation is easily obtained from (8), giving qSoR (f, f∗ ) = N 0, Qf,f Qf,∗ Q∗,f Q∗,∗ , (15) −1 where we recall Qa,b Ka,u Ku,u Ku,b . A more descriptive name for this method, would be the Deterministic Inducing Conditional (DIC) approximation. We see that this approximate prior is degenerate. There are only m degrees of freedom in the model, which implies that only m linearly independent functions can be drawn from the prior. The m + 1-th one is a linear combination of the previous. For example, in a very low noise regime, the posterior could be severely constrained by only m training cases. The degeneracy of the prior causes unreasonable predictive distributions. Indeed, the approximate prior over functions is so restrictive, that given enough data only a very limited family of functions will be plausible under the posterior, leading to overconﬁdent predictive variances. This is a general problem of ﬁnite linear models with small numbers of weights (for more details see Rasmussen and Qui˜ onero-Candela, 2005). Figure 5, top, right panel, illustrates the unreasonable n predictive uncertainties of the SoR approximation on a toy dataset.7 The predictive distribution is obtained by using the SoR approximate prior (15) instead of the true prior in (4). For each algorithm we give two forms of the predictive distribution, one which is easy to interpret, and the other which is economical to compute with: qSoR (f∗ |y) = N Q∗,f (Qf,f + σ2 I)−1 y, Q∗,∗ − Q∗,f (Qf,f + σ2 I)−1 Qf,∗ , noise noise = N σ K∗,u Σ Ku,f y, K∗,u ΣKu,∗ , −2 (16a) (16b) where we have deﬁned Σ = (σ−2 Ku,f Kf,u + Ku,u )−1 . Equation (16a) is readily recognized as the regular prediction equation (6), except that the covariance K has everywhere been replaced by Q, which was already suggested by (15). This corresponds to replacing the covariance function k with −1 kSoR (xi , x j ) = k(xi , u)Ku,u k(u, x j ). The new covariance function has rank (at most) m. Thus we have the following 7. Wary of this fact, Smola and Bartlett (2001) propose using the predictive variances of the SoD, or a more accurate computationally costly alternative (more details are given by Qui˜ onero-Candela, 2004, Chapter 3). n 1944 S PARSE A PPROXIMATE G AUSSIAN P ROCESS R EGRESSION Remark 4 The SoR approximation is equivalent to exact inference in the degenerate Gaussian −1 process with covariance function kSoR (xi , x j ) = k(xi , u)Ku,u k(u, x j ). The equivalent (16b) is computationally cheaper, and with (11) in mind, Σ is the covariance of the posterior on the weights wu . Note that as opposed to the subset of data method, all training cases are taken into account. The computational complexity is O (nm2 ) initially, and O (m) and O (m2 ) per test case for the predictive mean and variance respectively. 5. The Deterministic Training Conditional (DTC) Approximation Taking up ideas already contained in the work of Csat´ and Opper (2002), Seeger et al. (2003) o recently proposed another sparse approximation to Gaussian process regression, which does not suffer from the nonsensical predictive uncertainties of the SoR approximation, but that interestingly leads to exactly the same predictive mean. Seeger et al. (2003), who called the method Projected Latent Variables (PLV), presented the method as relying on a likelihood approximation, based on −1 the projection f = Kf,u Ku,u u: p(y|f) −1 q(y|u) = N (Kf,u Ku,u u, σ2 I) . noise (17) The method has also been called the Projected Process Approximation (PPA) by Rasmussen and Williams (2006, Chapter 8). One way of obtaining an equivalent model is to retain the usual likelihood, but to impose a deterministic training conditional and the exact test conditional from eq. (9b) −1 qDTC (f|u) = N (Kf,u Ku,u u, 0), and qDTC (f∗ |u) = p(f∗ |u) . (18) This reformulation has the advantage of allowing us to stick to our view of exact inference (with exact likelihood) with approximate priors. Indeed, under this model the conditional distribution of f given u is identical to that of the SoR, given in the left of (14). A systematic name for this approximation is the Deterministic Training Conditional (DTC). The fundamental difference with SoR is that DTC uses the exact test conditional (9b) instead of the deterministic relation between f∗ and u of SoR. The joint prior implied by DTC is given by: qDTC (f, f∗ ) = N 0, Qf,f Qf,∗ Q∗,f K∗,∗ , (19) which is surprisingly similar to the effective prior implied by the SoR approximation (15). The fundamental difference is that under the DTC approximation f∗ has a prior variance of its own, given by K∗,∗ . This prior variance reverses the behaviour of the predictive uncertainties, and turns them into sensible ones, see Figure 5 for an illustration. The predictive distribution is now given by: qDTC (f∗ |y) = N (Q∗,f (Qf,f + σ2 I)−1 y, K∗,∗ − Q∗,f (Qf,f + σ2 I)−1 Qf,∗ noise noise = N σ K∗,u Σ Ku,f y, K∗,∗ − Q∗,∗ + K∗,u ΣK∗,u , −2 (20a) (20b) where again we have deﬁned Σ = (σ−2 Ku,f Kf,u + Ku,u )−1 as in (16). The predictive mean for the DTC is identical to that of the SoR approximation (16), but the predictive variance replaces the Q∗,∗ from SoR with K∗,∗ (which is larger, since K∗,∗ − Q∗,∗ is positive deﬁnite). This added term is the predictive variance of the posterior of f∗ conditioned on u. It grows to the prior variance K∗,∗ as x∗ moves far from the inducing inputs in Xu . 1945 ˜ Q UI NONERO -C ANDELA AND R ASMUSSEN u    e ¡   ¡ e  e    ¡  e   ¡  e   ¡   e ¡   r r r f1 f2 fn f∗ Figure 2: Graphical model for the FITC approximation. Compared to those in Figure 1, all edges between latent function values have been removed: the latent function values are conditionally fully independent given the inducing variables u. Although strictly speaking the SoR and DTC approximations could also be represented by this graph, note that both further assume a deterministic relation between f and u. Remark 5 The only difference between the predictive distribution of DTC and SoR is the variance. The predictive variance of DTC is never smaller than that of SoR. Note, that since the covariances for training cases and test cases are computed differently, see (19), it follows that Remark 6 The DTC approximation does not correspond exactly to a Gaussian process, as the covariance between latent values depends on whether they are considered training or test cases, violating consistency, see Deﬁnition 1. The computational complexity has the same order as for SoR. 6. The Fully Independent Training Conditional (FITC) Approximation Recently Snelson and Ghahramani (2006) proposed another likelihood approximation to speed up Gaussian process regression, which they called Sparse Gaussian Processes using Pseudo-inputs (SGPP). While the DTC is based on the likelihood approximation given by (17), the SGPP proposes a more sophisticated likelihood approximation with a richer covariance p(y|f) −1 q(y|u) = N (Kf,u Ku,u u, diag[Kf,f − Qf,f ] + σ2 I) , noise (21) where diag[A] is a diagonal matrix whose elements match the diagonal of A. As we did in (18) for the DTC, we provide an alternative equivalent formulation called Fully Independent Training Conditional (FITC) based on the inducing conditionals: n qFITC (f|u) = ∏ p( fi |u) = N i=1 −1 Kf,u Ku,u u, diag[Kf,f −Qf,f ] , and qFITC ( f∗ |u) = p( f∗ |u) . (22) We see that as opposed to SoR and DTC, FITC does not impose a deterministic relation between f and u. Instead of ignoring the variance, FITC proposes an approximation to the training conditional distribution of f given u as a further independence assumption. In addition, the exact test conditional from (9b) is used in (22), although for reasons which will become clear towards the end of this 1946 S PARSE A PPROXIMATE G AUSSIAN P ROCESS R EGRESSION section, we initially consider only a single test case, f∗ . The corresponding graphical model is given in Figure 2. The effective prior implied by the FITC is given by qFITC (f, f∗ ) = N 0, Qf,f − diag[Qf,f − Kf,f ] Qf,∗ Q∗,f K∗,∗ . (23) Note, that the sole difference between the DTC and FITC is that in the top left corner of the implied prior covariance, FITC replaces the approximate covariances of DTC by the exact ones on the diagonal. The predictive distribution is qFITC ( f∗ |y) = N Q∗,f (Qf,f + Λ)−1 y, K∗,∗ − Q∗,f (Qf,f + Λ)−1 Qf,∗ (24a) = N K∗,u ΣKu,f Λ−1 y, K∗,∗ − Q∗,∗ + K∗,u ΣKu,∗ , (24b) where we have deﬁned Σ = (Ku,u + Ku,f Λ−1 Kf,u )−1 and Λ = diag[Kf,f − Qf,f + σ2 I ]. The compunoise tational complexity is identical to that of SoR and DTC. So far we have only considered a single test case. There are two options for joint predictions, either 1) use the exact full test conditional from (9b), or 2) extend the additional factorizing assumption to the test conditional. Although Snelson and Ghahramani (2006) don’t explicitly discuss joint predictions, it would seem that they probably intend the second option. Whereas the additional independence assumption for the test cases is not really necessary for computational reasons, it does affect the nature of the approximation. Under option 1) the training and test covariance are computed differently, and thus this does not correspond to our strict deﬁnition of a GP model, but Remark 7 Iff the assumption of full independence is extended to the test conditional, the FITC approximation is equivalent to exact inference in a non-degenerate Gaussian process with covariance function kFIC (xi , x j ) = kSoR (xi , x j ) + δi, j [k(xi , x j ) − kSoR (xi , x j )], where δi, j is Kronecker’s delta. A logical name for the method where the conditionals (training and test) are always forced to be fully independent would be the Fully Independent Conditional (FIC) approximation. The effective prior implied by FIC is: qFIC (f, f∗ ) = N 0, Qf,f − diag[Qf,f − Kf,f ] Qf,∗ Q∗,f Q∗,∗ − diag[Q∗,∗ − K∗,∗ ] . (25) 7. The Partially Independent Training Conditional (PITC) Approximation In the previous section we saw how to improve the DTC approximation by approximating the training conditional with an independent distribution, i.e. one with a diagonal covariance matrix. In this section we will further improve the approximation (while remaining computationally attractive) by extending the training conditional to have a block diagonal covariance: −1 qPITC (f|u) = N Kf,u Ku,u u, blockdiag[Kf,f − Qf,f ] , and qPITC (f∗ |u) = p(f∗ |u) . (26) where blockdiag[A] is a block diagonal matrix (where the blocking structure is not explicitly stated). We represent graphically the PITC approximation in Figure 3. Developing this analogously to the FITC approximation from the previous section, we get the joint prior qPITC (f, f∗ ) = N 0, Qf,f − blockdiag[Qf,f − Kf,f ] Qf,∗ Q∗,f K∗,∗ 1947 , (27) ˜ Q UI NONERO -C ANDELA AND R ASMUSSEN u    e ¡   ¡ e  e    ¡  e   ¡  e   ¡   e ¡   r r r fI fI fI f∗ 1 2 k Figure 3: Graphical representation of the PITC approximation. The set of latent function values fIi indexed by the the set of indices Ii is fully connected. The PITC differs from FITC (see graph in Fig. 2) in that conditional independence is now between the k groups of training latent function values. This corresponds to the block diagonal approximation to the true training conditional given in (26). and the predictive distribution is identical to (24), except for the alternative deﬁnition of Λ = blockdiag[Kf,f − Qf,f + σ2 I ]. An identical expression was obtained by Schwaighofer and Tresp noise (2003, Sect. 3), developing from the original Bayesian committee machine (BCM) by Tresp (2000). The relationship to the FITC was pointed out by Lehel Csat´ . The BCM was originally proposed as o a transductive learner (i.e. where the test inputs have to be known before training), and the inducing inputs Xu were chosen to be the test inputs. We discuss transduction in detail in the next section. It is important to realize that the BCM proposes two orthogonal ideas: ﬁrst, the block diagonal structure of the partially independent training conditional, and second setting the inducing inputs to be the test inputs. These two ideas can be used independently and in Section 8 we propose using the ﬁrst without the second. The computational complexity of the PITC approximation depends on the blocking structure imposed in (26). A reasonable choice, also recommended by Tresp (2000) may be to choose k = n/m blocks, each of size m × m. The computational complexity remains O (nm2 ). Since in the PITC model the covariance is computed differently for training and test cases Remark 8 The PITC approximation does not correspond exactly to a Gaussian process. This is because computing covariances requires knowing whether points are from the training- or test-set, (27). One can obtain a Gaussian process from the PITC by extending the partial conditional independence assumption to the test conditional, as we did in Remark 7 for the FITC. 8. Transduction and Augmentation The idea of transduction is that one should restrict the goal of learning to prediction on a prespeciﬁed set of test cases, rather than trying to learn an entire function (induction) and then evaluate it at the test inputs. There may be no universally agreed upon deﬁnition of transduction. In this paper we use Deﬁnition 9 Transduction occurs only if the predictive distribution depends on other test inputs. This operational deﬁnition excludes models for which there exist an equivalent inductive counterpart. According to this deﬁnition, it is irrelevant when the bulk of the computation takes place. 1948 S PARSE A PPROXIMATE G AUSSIAN P ROCESS R EGRESSION u f∗   e  ¡     ¡ e   e ¡     ¡     e e   ¡       e ¡   r r r fI fI fI 1 2 k Figure 4: Two views on Augmentation. One view is to see that the test latent function value f∗ is now part of the inducing variables u and therefore has access to the training latent function values. An equivalent view is to consider that we have dropped the assumption of conditional independence between f∗ and the training latent function values. Even if f∗ has now direct access to each of the training fi , these still need to go through u to talk to each other if they fall in conditionally independent blocks. We have in this ﬁgure decided to recycle the graph for PITC from Figure 3 to show that all approximations we have presented can be augmented, irrespective of what the approximation for the training conditional is. There are several different possible motivations for transduction: 1) transduction is somehow easier than induction (Vapnik, 1995), 2) the test inputs may reveal important information, which should be used during training. This motivation drives models in semi-supervised learning (studied mostly in the context of classiﬁcation) and 3) for approximate algorithms one may be able to limit the discrepancies of the approximation at the test points. For exact GP models it seems that the ﬁrst reason doesn’t really apply. If you make predictions at the test points that are consistent with a GP, then it is trivial inside the GP framework to extend these to any other input points, and in effect we have done induction. The second reason seems more interesting. However, in a standard GP setting, it is a consequence of the consistency property, see Remark 2, that predictions at one test input are independent of the location of any other test inputs. Therefore transduction can not be married with exact GPs: Remark 10 Transduction can not occur in exact Gaussian process models. Whereas this holds for the usual setting of GPs, it could be different in non-standard situations where e.g. the covariance function depends on the empirical input densities. Transduction can occur in the sparse approximation to GPs, by making the choice of inducing variables depend on the test inputs. The BCM from the previous section, where Xu = X∗ (where X∗ are the test inputs) is an example of this. Since the inducing variables are connected to all other nodes (see Figure 3) we would expect the approximation to be good at u = f∗ , which is what we care about for predictions, relating to reason 3) above. While this reasoning is sound, it is not necessarily a sufﬁcient consideration for getting a good model. The model has to be able to simultaneously explain the training targets as well and if the choice of u makes this difﬁcult, the posterior at the points of interest may be distorted. Thus, the choice of u should be governed by the ability to model the conditional of the latents given the inputs, and not solely by the density of the (test) inputs. The main drawback of transduction is that by its nature it doesn’t provide a predictive model in the way inductive models do. In the usual GP model one can do the bulk of the computation 1949 ˜ Q UI NONERO -C ANDELA AND R ASMUSSEN involved in the predictive distributions (e.g. matrix inversion) before seeing the test cases, enabling fast computation of test predictions. It is interesting that whereas other methods spend much effort trying to optimize the inducing variables, the BCM simply uses the test set. The quality of the BCM approximation depends then on the particular location of the test inputs, upon which one usually does not have any control. We now see that there may be a better method, eliminating the drawback of transduction, namely use the PITC approximation, but choose the u’s carefully (see Section 9), don’t just use the test set. 8.1 Augmentation An idea closely related to transduction, but not covered by our deﬁnition, is augmentation, which in contrast to transduction is done individually for each test case. Since in the previous sections, we haven’t assumed anything about u, we can simply augment the set of inducing variables by f∗ (i.e. have one additional inducing variable equal to the current test latent), and see what happens in the predictive distributions for the different methods. Let’s ﬁrst investigate the consequences for the test conditional from (9b). Note, the interpretation of the covariance matrix K∗,∗ − Q∗,∗ was “the prior covariance minus the information which u provides about f∗ ”. It is clear that the augmented u (with f∗ ) provides all possible information about f∗ , and consequently Q∗,∗ = K∗,∗ . An equivalent view on augmentation is that the assumption of conditional independence between f∗ and f is dropped. This is seen trivially by adding edges between f∗ and the fi in the graphical model, Figure 4. Augmentation was originally proposed by Rasmussen (2002), and applied in detail to the SoR with RBF covariance by Qui˜ onero-Candela (2004). Because the SoR is a ﬁnite linear model, and n the basis functions are local (Gaussian bumps), the predictive distributions can be very misleading. For example, when making predictions far away from the center of any basis function, all basis functions have insigniﬁcant magnitudes, and the prediction (averaged over the posterior) will be close to zero, with very small error-bars; this is the opposite of the desired behaviour, where we would expect the error-bars to grow as we move away from the training cases. Here augmentation makes a particularly big difference turning the nonsensical predictive distribution into a reasonable one, by ensuring that there is always a basis function centered on the test case. Compare the nonaugmented to the augmented SoR in Figure 5. An analogous Gaussian process based ﬁnite linear model that has recently been healed by augmentation is the relevance vector machine (Rasmussen and Qui˜ onero-Candela, 2005). n Although augmentation was initially proposed for a narrow set of circumstances, it is easily applied to any of the approximations discussed. Of course, augmentation doesn’t make any sense for an exact, non-degenerate Gaussian process model (a GP with a covariance function that has a feature-space which is inﬁnite dimensional, i.e. with basis functions everywhere). Remark 11 A full non-degenerate Gaussian process cannot be augmented, since the corresponding f∗ would already be connected to all other variables in the graphical model. But augmentation does make sense for sparse approximations to GPs. The more general process view on augmentation has several advantages over the basis function view. It is not completely clear from the basis function view, which basis function should be used for augmentation. For example, Rasmussen and Qui˜ onero-Candela (2005) successfully apply augn mentation using basis functions that have a zero contribution at the test location! In the process view 1950 S PARSE A PPROXIMATE G AUSSIAN P ROCESS R EGRESSION however, it seems clear that one would chose the additional inducing variable to be f∗ , to minimize the effects of the approximations. Let us compute the effective prior for the augmented SoR. Given that f∗ is in the inducing set, the test conditional is not an approximation and we can rewrite the integral leading to the effective prior: Z qASoR (f∗ , f) = qSoR (f| f∗ , u) p( f∗ , u) du . (28) It is interesting to notice that this is also the effective prior that would result from augmenting the DTC approximation, since qSoR (f| f∗ , u) = qDTC (f| f∗ , u). Remark 12 Augmented SoR (ASoR) is equivalent to augmented DTC (ADTC). Augmented DTC only differs from DTC in the additional presence of f∗ among the inducing variables in the training conditional. We can only expect augmented DTC to be a more accurate approximation than DTC, since adding an additional inducing variable can only help capture information from y. Therefore Remark 13 DTC is a less accurate (but cheaper) approximation than augmented SoR. We saw previously in Section 5 that the DTC approximation does not suffer from the nonsensical predictive variances of the SoR. The equivalence between the augmented SoR and augmented DTC is another way of seeing how augmentation reverses the misbehaviour of SoR. The predictive distribution of the augmented SoR is obtained by adding f∗ to u in (20). Prediction with an augmented sparse model comes at a higher computational cost, since now f∗ directly interacts with all of f and not just with u. For each new test case, updating the augmented Σ in the predictive equation (for example (20b) for DTC) implies computing the vector matrix product K∗,f Kf,u with complexity O (nm). This is clearly higher than the O (m) for the mean, and O (m2 ) for the predictive distribution of all the non-augmented methods we have discussed. Augmentation seems to be only really necessary for methods that make a severe approximation to the test conditional, like the SoR. For methods that make little or no approximation to the test conditional, it is difﬁcult to predict the degree to which augmentation would help. However, one can see by giving f∗ access to all of the training latent function values in f, one would expect augmentation to give less under-conﬁdent predictive distributions near the training data. Figure 5 clearly shows that augmented DTC (equivalent to augmented SoR) has a superior predictive distribution (both mean and variance) than standard DTC. Note however that in the ﬁgure we have purposely chosen a too short lengthscale to enhance visualization. Quantitatively, this superiority was experimentally assessed by Qui˜ onero-Candela (2004, Table 3.1). Augmentation hasn’t been n compared to the more advanced approximations FITC and PITC, and the ﬁgure would change in the more realistic scenario where the inducing inputs and hyperparameters are learnt (Snelson and Ghahramani, 2006). Transductive methods like the BCM can be seen as joint augmentation, and one could potentially use it for any of the methods presented. It seems that the good performance of the BCM could essentially stem from augmentation, the presence of the other test inputs in the inducing set being probably of little beneﬁt. Joint augmentation might bring some computational advantage, but won’t change the scaling: note that augmenting m times at a cost of O (nm) apiece implies the same O (nm2 ) total cost as the jointly augmented BCM. 1951 ˜ Q UI NONERO -C ANDELA AND R ASMUSSEN SoD SoR 1.5 1.5 1 1 0.5 0.5 0 0 −0.5 −0.5 −1 −1 −1.5 −15 −10 −5 0 5 10 15 −1.5 −15 −10 −5 DTC 0 5 10 15 5 10 15 5 10 15 ASoR/ADTC 1.5 1.5 1 1 0.5 0.5 0 0 −0.5 −0.5 −1 −1 −1.5 −15 −10 −5 0 5 10 15 −1.5 −15 −10 −5 FITC 0 PITC 1.5 1.5 1 1 0.5 0.5 0 0 −0.5 −0.5 −1 −1 −1.5 −15 −10 −5 0 5 10 15 −1.5 −15 −10 −5 0 Figure 5: Toy example with identical covariance function and hyperparameters. The squared exponential covariance function is used, and a slightly too short lengthscale is chosen on purpose to emphasize the different behaviour of the predictive uncertainties. The dots are the training points, the crosses are the targets corresponding to the inducing inputs, randomly selected from the training set. The solid line is the mean of the predictive distribution, and the dotted lines show the 95% conﬁdence interval of the predictions. Augmented DTC (ADTC) is equivalent to augmented SoR (ASoR), see Remark 12. 1952 S PARSE A PPROXIMATE G AUSSIAN P ROCESS R EGRESSION 9. On the Choice of the Inducing Variables We have until now assumed that the inducing inputs Xu were given. Traditionally, sparse models have very often been built upon a carefully chosen subset of the training inputs. This concept is probably best exempliﬁed in the popular support vector machine (Cortes and Vapnik, 1995). In sparse Gaussian processes it has also been suggested to select the inducing inputs Xu from among the training inputs. Since this involves a prohibitive combinatorial optimization, greedy optimization approaches have been suggested using various selection criteria like online learning (Csat´ and o Opper, 2002), greedy posterior maximization (Smola and Bartlett, 2001), maximum information gain (Seeger et al., 2003), matching pursuit (Keerthi and Chu, 2006), and probably more. As discussed in the previous section, selecting the inducing inputs from among the test inputs has also been considered in transductive settings. Recently, Snelson and Ghahramani (2006) have proposed to relax the constraint that the inducing variables must be a subset of training/test cases, turning the discrete selection problem into one of continuous optimization. One may hope that ﬁnding a good solution is easier in the continuous than the discrete case, although ﬁnding the global optimum is intractable in both cases. And perhaps the less restrictive choice can lead to better performance in very sparse models. Which optimality criterion should be used to set the inducing inputs? Departing from a fully Bayesian treatment which would involve deﬁning priors on Xu , one could maximize the marginal likelihood (also called the evidence) with respect to Xu , an approach also followed by Snelson and Ghahramani (2006). Each of the approximate methods proposed involves a different effective prior, and hence its own particular effective marginal likelihood conditioned on the inducing inputs q(y|Xu ) = ZZ p(y|f) q(f|u) p(u|Xu )du df = Z p(y|f) q(f|Xu )df , (29) which of course is independent of the test conditional. We have in the above equation explicitly conditioned on the inducing inputs Xu . Using Gaussian identities, the effective marginal likelihood is very easily obtained by adding a ridge σ2 I (from the likelihood) to the covariance of effective noise prior on f. Using the appropriate deﬁnitions of Λ, the log marginal likelihood becomes 1 log q(y|Xu ) = − 2 log |Qf,f + Λ| − 1 y (Qf,f + Λ)−1 y − n log(2π) , 2 2 (30) where ΛSoR = ΛDTC = σ2 I, ΛFITC = diag[Kf,f − Qf,f ] + σ2 I, and ΛPITC = blockdiag[Kf,f − noise noise Qf,f ] + σ2 I. The computational cost of the marginal likelihood is O (nm2 ) for all methods, that of noise its gradient with respect to one element of Xu is O (nm). This of course implies that the complexity of computing the gradient wrt. to the whole of Xu is O (dnm2 ), where d is the dimension of the input space. It has been proposed to maximize the effective posterior instead of the effective marginal likelihood (Smola and Bartlett, 2001). However this is potentially dangerous and can lead to overﬁtting. Maximizing the whole evidence instead is sound and comes at an identical computational cost (for a deeper analysis see Qui˜ onero-Candela, 2004, Sect. 3.3.5 and Fig. 3.2). n The marginal likelihood has traditionally been used to learn the hyperparameters of GPs in the non fully Bayesian treatment (see for example Williams and Rasmussen, 1996). For the sparse approximations presented here, once you are learning Xu it is straightforward to allow for learning hyperparameters (of the covariance function) during the same optimization, and there is no need to interleave optimization of u with learning of the hyperparameters as it has been proposed for example by Seeger et al. (2003). 1953 ˜ Q UI NONERO -C ANDELA AND R ASMUSSEN 10. Other Methods In this section we brieﬂy mention two approximations which don’t ﬁt in our unifying scheme, since one doesn’t correspond to a proper probabilistic model, and the other one uses a particular construction for the covariance function, rather than allowing any general covariance function. 10.1 The Nystr¨ m Approximation o The Nystr¨ m Approximation for speeding up GP regression was originally proposed by Williams o and Seeger (2001), and then questioned by Williams et al. (2002). Like SoR and DTC, the Nystr¨ m o Approximation for GP regression approximates the prior covariance of f by Qf,f . However, unlike these methods, the Nystr¨ m Approximation is not based on a generative probabilistic model. The o prior covariance between f∗ and f is taken to be exact, which is inconsistent with the prior covariance on f: Qf,f Kf,∗ . (31) q(f, f∗ ) = N 0, K∗,f K∗,∗ As a result we cannot derive this method from our unifying framework, nor represent it with a graphical model. Worse, the resulting prior covariance matrix is not even guaranteed to be positive deﬁnite, allowing the predictive variances to be negative. Notice that replacing Kf,∗ by Qf,∗ in (31) is enough to make the prior covariance positive deﬁnite, and one obtains the DTC approximation. Remark 14 The Nystr¨ m Approximation does not correspond to a well-formed probabilistic model. o Ignoring any quibbles about positive deﬁniteness, the predictive distribution of the Nystr¨ m Apo proximation is given by: p( f∗ |y) = N Kf,∗ [Qf,f + σ2 I]−1 y, K∗,∗ − Kf,∗ [Qf,f + σ2 I]−1 Kf,∗ , noise noise (32) but the predictive variance is not guaranteed to be positive. The computational cost is O (nm2 ). 10.2 The Relevance Vector Machine The relevance vector machine, introduced by Tipping (2001), is a ﬁnite linear model with an independent Gaussian prior imposed on the weights. For any input x∗ , the corresponding function output is given by: f∗ = φ∗ w , with p(w|A) = N (0, A) , (33) where φ∗ = [φ1 (x), . . . , φm (x)] is the (row) vector of responses of the m basis functions, and A = diag(α1 , . . . , αm ) is the diagonal matrix of joint prior precisions (inverse variances) of the weights. The αi are learnt by maximizing the RVM evidence (obtained by also assuming Gaussian additive iid. noise, see (1)), and for the typical case of rich enough sets of basis functions many of the precisions go to inﬁnity effectively pruning out the corresponding weights (for a very interesting analysis see Wipf et al., 2004). The RVM is thus a sparse method and the surviving basis functions are called relevance vectors. Note that since the RVM is a ﬁnite linear model with Gaussian priors on the weights, it can be seen as a Gaussian process: Remark 15 The RVM is equivalent to a degenerate Gaussian process with covariance function kRVM (xi , x j ) = φi A−1 φ j = ∑m α−1 φk (xi ) φk (x j ), k=1 k 1954 S PARSE A PPROXIMATE G AUSSIAN P ROCESS R EGRESSION q(f∗ |u) q(f|u) GP exact exact SoR determ. determ. DTC exact determ. FITC (exact) fully indep. PITC exact partially indep. Method joint prior covariance Kf,f Kf,∗ K∗,f K∗,∗ Qf,f Qf,∗ Q∗,f Q∗,∗ Qf,f Qf,∗ Q∗,f K∗,∗ Qf,f − diag[Qf,f − Kf,f ] Qf,∗ Q∗,f K∗,∗ Qf,f − blokdiag[Qf,f − Kf,f ] Qf,∗ Q∗,f K∗,∗ GP? √ √ √ ( ) Table 1: Summary of the way approximations are built. All these methods are detailed in the previous sections. The initial cost and that of the mean and variance per test case are respectively n2 , n and n2 for the exact GP, and nm2 , m and m2 for all other methods. The “GP?” column indicates whether the approximation is equivalent to a GP. For FITC see Remark 7. as was also pointed out by Tipping (2001, eq. (59)). Whereas all sparse approximations we have presented until now are totally independent of the choice of covariance function, for the RVM this choice is restricted to covariance functions that can be expressed as ﬁnite expansions in terms of some basis functions. Being degenerate GPs in exactly the same way as the SoR (presented in Section 4), the RVM does also suffer from unreasonable predictive variances. Rasmussen and Qui˜ onero-Candela (2005) show that the predictive distributions of RVMs can also be healed by n augmentation, see Section 8. Once the αi have been learnt, denoting by m the number of surviving relevance vectors, the complexity of computing the predictive distribution of the RVM is O (m) for mean and O (m2 ) for the variance. RVMs are often used with radial basis functions centered on the training inputs. One potentially interesting extension to the RVM would be to learn the locations of the centers of the basis functions, in the same way as proposed by Snelson and Ghahramani (2006) for the FITC approximation, see Section 6. This is a curious reminiscence of learning the centers in RBF Networks. 11. Conclusions We have provided a unifying framework for sparse approximations to Gaussian processes for regression. Our approach consists of two steps, ﬁrst 1) we recast the approximation in terms of approximations to the prior, and second 2) we introduce inducing variables u and the idea of conditional independence given u. We recover all existing sparse methods by making further simpliﬁcations of the covariances of the training and test conditionals, see Table 1 for a summary. Previous methods were presented based on different approximation paradigms (e.g. likelihood approximations, projection methods, matrix approximations, minimization of Kullback-Leibler divergence, etc), making direct comparison difﬁcult. Under our unifying view we deconstruct methods, making it clear which building blocks they are based upon. For example, the SGPP by Snelson 1955 ˜ Q UI NONERO -C ANDELA AND R ASMUSSEN and Ghahramani (2006) contains two ideas, 1) a likelihood approximation and 2) the idea of varying the inducing inputs continuously; these two ideas could easily be used independently, and incorporated in other methods. Similarly, the BCM by Tresp (2000) contains two independent ideas 1) a block diagonal assumption, and 2) the (transductive) idea of choosing the test inputs as the inducing variables. Finally we note that although all three ideas of 1) transductively setting u = f∗ , 2) augmentation and 3) continuous optimization of Xu have been proposed in very speciﬁc settings, in fact they are completely general ideas, which can be applied to any of the approximation schemes considered. We have ranked the approximation according to how close they are to the corresponding full GP. However, the performance in practical situations may not always follow this theoretical ranking since the approximations might exhibit properties (not present in the full GP) which may be particularly suitable for speciﬁc datasets. This may make the interpretation of empirical comparisons challenging. A further complication arises when adding the necessary heuristics for turning the theoretical constructs into practical algorithms. We have not described full algorithms in this paper, but are currently working on a detailed empirical study (in preparation, see also Rasmussen and Williams, 2006, chapter 8). We note that the order of the computational complexity is identical for all the methods considered, O (nm2 ). This highlights that there is no computational excuse for using gross approximations, such as assuming deterministic relationships, in particular one should probably think twice before using SoR or even DTC. Although augmentation has attractive predictive properties, it is computationally expensive. It remains unclear whether augmentation could be beneﬁcial on a ﬁxed computational budget. We have only considered the simpler case of regression in this paper, but sparseness is also commonly sought in classiﬁcation settings. It should not be difﬁcult to cast probabilistic approximation methods such as Expectation Propagation (EP) or the Laplace method (for a comparison, see Kuss and Rasmussen, 2005) into our unifying framework. Our analysis suggests that a new interesting approximation would come from combining the best possible approximation (PITC) with the most powerful selection method for the inducing inputs. This would correspond to a non-transductive version of the BCM. We would evade the necessity of knowing the test set before doing the bulk of the computation, and we could hope to supersede the superior performance reported by Snelson and Ghahramani (2006) for very sparse approximations. Acknowledgments Thanks to Neil Lawrence for arranging the 2005 Gaussian Process Round Table meeting in Shefﬁeld, which provided much inspiration to this paper. Special thanks to Olivier Chapelle, Lehel Csat´ , o Zoubin Ghahramani, Matthias Seeger, Ed Snelson and Chris Williams for helpful discussions, and to three anonymous reviewers. Both authors were supported by the German Research Council (DFG) through grant RA 1030/1. This work was supported in part by the IST Programme of the European Community, under the PASCAL Network of Excellence, IST-2002-506778. 1956 S PARSE A PPROXIMATE G AUSSIAN P ROCESS R EGRESSION Appendix A. Gaussian and Matrix Identities In this appendix we provide identities used to manipulate matrices and Gaussian distributions throughout the paper. Let x and y be jointly Gaussian x y µx µy ∼ N , A C C B , (34) then the marginal and the conditional are given by x ∼ N (µx , A) , and x|y ∼ N µx +C B−1 (y − µy ), A −C B−1C (35) Also, the product of a Gaussian in x with a Gaussian in a linear projection P x is again a Gaussian, although unnormalized N (x|a, A) N (P x|b, B) = zc N (x|c,C) , (36) where C = A−1 + P B−1 P −1 c = C A−1 a + P B−1 b . , The normalizing constant zc is gaussian in the means a and b of the two Gaussians: m 1 1 zc = (2 π)− 2 |B + P A P |− 2 exp − 2 (b − P a) B+PAP −1 (b − P a) . (37) The matrix inversion lemma, also known as the Woodbury, Sherman & Morrison formula states that: (Z +UWV )−1 = Z −1 − Z −1U(W −1 +V Z −1U)−1V Z −1 , (38) assuming the relevant inverses all exist. Here Z is n × n, W is m × m and U and V are both of size n × m; consequently if Z −1 is known, and a low rank (ie. m < n) perturbation are made to Z as in left hand side of eq. (38), considerable speedup can be achieved. References Corinna Cortes and Vladimir Vapnik. Support-vector network. Machine Learning, 20(3):273–297, 1995. Lehel Csat´ and Manfred Opper. Sparse online Gaussian processes. Neural Computation, 14(3): o 641–669, 2002. Sathiya Keerthi and Wei Chu. A Matching Pursuit approach to sparse Gaussian process regression. In Y. Weiss, B. Sch¨ lkopf, and J. Platt, editors, Advances in Neural Information Processing o Systems 18, Cambridge, Massachussetts, 2006. The MIT Press. Malte Kuss and Carl Edward Rasmussen. Assessing approximate inference for binary Gaussian process classiﬁcation. Journal of Machine Learning Research, pages 1679–1704, 2005. Joaquin Qui˜ onero-Candela. Learning with Uncertainty – Gaussian Processes and Relevance Vecn tor Machines. PhD thesis, Technical University of Denmark, Lyngby, Denmark, 2004. Carl Edward Rasmussen. Reduced rank Gaussian process learning. Technical report, Gatsby Computational Neuroscience Unit, UCL, 2002. 1957 ˜ Q UI NONERO -C ANDELA AND R ASMUSSEN Carl Edward Rasmussen and Joaquin Qui˜ onero-Candela. Healing the relevance vector machine by n augmentation. In International Conference on Machine Learning, 2005. Carl Edward Rasmussen and Christopher K. I. Williams. Gaussian Processes for Machine Learning. The MIT press, 2006. Anton Schwaighofer and Volker Tresp. Transductive and inductive methods for approximate Gaussian process regression. In Suzanna Becker, Sebastian Thrun, and Klaus Obermayer, editors, Advances in Neural Information Processing Systems 15, pages 953–960, Cambridge, Massachussetts, 2003. The MIT Press. Matthias Seeger, Christopher K. I. Williams, and Neil Lawrence. Fast forward selection to speed up sparse Gaussian process regression. In Christopher M. Bishop and Brendan J. Frey, editors, Ninth International Workshop on Artiﬁcial Intelligence and Statistics. Society for Artiﬁcial Intelligence and Statistics, 2003. Bernhard W. Silverman. Some aspects of the spline smoothing approach to non-parametric regression curve ﬁtting. J. Roy. Stat. Soc. B, 47(1):1–52, 1985. (with discussion). Alexander J. Smola and Peter L. Bartlett. Sparse greedy Gaussian process regression. In Todd K. Leen, Thomas G. Dietterich, and Volker Tresp, editors, Advances in Neural Information Processing Systems 13, pages 619–625, Cambridge, Massachussetts, 2001. The MIT Press. Edward Snelson and Zoubin Ghahramani. Sparse Gaussian processes using pseudo-inputs. In Y. Weiss, B. Sch¨ lkopf, and J. Platt, editors, Advances in Neural Information Processing Systems o 18, Cambridge, Massachussetts, 2006. The MIT Press. Michael E. Tipping. Sparse Bayesian learning and the Relevance Vector Machine. Journal of Machine Learning Research, 1:211–244, 2001. Volker Tresp. A Bayesian committee machine. Neural Computation, 12(11):2719–2741, 2000. Vladimir N. Vapnik. The Nature of Statistical Learning Theory. Springer Verlag, 1995. Grace Wahba, Xiwu Lin, Fangyu Gao, Dong Xiang, Ronald Klein, and Barbara Klein. The biasvariance tradeoff and the randomized GACV. In Michael S. Kerns, Sara A. Solla, and David A. Cohn, editors, Advances in Neural Information Processing Systems 11, pages 620–626, Cambridge, Massachussetts, 1999. The MIT Press. Christopher K. I. Williams and Carl Edward Rasmussen. Gaussian processes for regression. In David S. Touretzky, Michael C. Mozer, and Michael E. Hasselmo, editors, Advances in Neural Information Processing Systems 8, pages 514–520, Cambridge, Massachussetts, 1996. The MIT Press. Christopher K. I. Williams, Carl Edward Rasmussen, Anton Schwaighofer, and Volker Tresp. Observations of the Nystr¨ m method for Gaussiam process prediction. Technical report, University o of Edinburgh, Edinburgh, Scotland, 2002. 1958 S PARSE A PPROXIMATE G AUSSIAN P ROCESS R EGRESSION Christopher K. I. Williams and Mathias Seeger. Using the Nystr¨ m method to speed up kernel o machines. In Todd K. Leen, Thomas G. Dietterich, and Volker Tresp, editors, Advances in Neural Information Processing Systems 13, pages 682–688, Cambridge, Massachussetts, 2001. The MIT Press. David Wipf, Jason Palmer, and Bhaskar Rao. Perspectives on sparse Bayesian learning. In Sebastian Thrun, Lawrence Saul, and Bernhard Sch¨ lkopf, editors, Advances in Neural Information o Processing Systems 16, Cambridge, Massachussetts, 2004. The MIT Press. 1959</p><p>3 0.30570161 <a title="62-lsi-3" href="./jmlr-2005-Gaussian_Processes_for_Ordinal_Regression.html">36 jmlr-2005-Gaussian Processes for Ordinal Regression</a></p>
<p>Author: Wei Chu, Zoubin Ghahramani</p><p>Abstract: We present a probabilistic kernel approach to ordinal regression based on Gaussian processes. A threshold model that generalizes the probit function is used as the likelihood function for ordinal variables. Two inference techniques, based on the Laplace approximation and the expectation propagation algorithm respectively, are derived for hyperparameter learning and model selection. We compare these two Gaussian process approaches with a previous ordinal regression method based on support vector machines on some benchmark and real-world data sets, including applications of ordinal regression to collaborative ﬁltering and gene expression analysis. Experimental results on these data sets verify the usefulness of our approach. Keywords: Gaussian processes, ordinal regression, approximate Bayesian inference, collaborative ﬁltering, gene expression analysis, feature selection</p><p>4 0.29815644 <a title="62-lsi-4" href="./jmlr-2005-Variational_Message_Passing.html">71 jmlr-2005-Variational Message Passing</a></p>
<p>Author: John Winn, Christopher M. Bishop</p><p>Abstract: Bayesian inference is now widely established as one of the principal foundations for machine learning. In practice, exact inference is rarely possible, and so a variety of approximation techniques have been developed, one of the most widely used being a deterministic framework called variational inference. In this paper we introduce Variational Message Passing (VMP), a general purpose algorithm for applying variational inference to Bayesian Networks. Like belief propagation, VMP proceeds by sending messages between nodes in the network and updating posterior beliefs using local operations at each node. Each such update increases a lower bound on the log evidence (unless already at a local maximum). In contrast to belief propagation, VMP can be applied to a very general class of conjugate-exponential models because it uses a factorised variational approximation. Furthermore, by introducing additional variational parameters, VMP can be applied to models containing non-conjugate distributions. The VMP framework also allows the lower bound to be evaluated, and this can be used both for model comparison and for detection of convergence. Variational message passing has been implemented in the form of a general purpose inference engine called VIBES (‘Variational Inference for BayEsian networkS’) which allows models to be speciﬁed graphically and then solved variationally without recourse to coding. Keywords: Bayesian networks, variational inference, message passing</p><p>5 0.29067102 <a title="62-lsi-5" href="./jmlr-2005-Assessing_Approximate_Inference_for_Binary_Gaussian_Process_Classification.html">14 jmlr-2005-Assessing Approximate Inference for Binary Gaussian Process Classification</a></p>
<p>Author: Malte Kuss, Carl Edward Rasmussen</p><p>Abstract: Gaussian process priors can be used to deﬁne ﬂexible, probabilistic classiﬁcation models. Unfortunately exact Bayesian inference is analytically intractable and various approximation techniques have been proposed. In this work we review and compare Laplace’s method and Expectation Propagation for approximate Bayesian inference in the binary Gaussian process classiﬁcation model. We present a comprehensive comparison of the approximations, their predictive performance and marginal likelihood estimates to results obtained by MCMC sampling. We explain theoretically and corroborate empirically the advantages of Expectation Propagation compared to Laplace’s method. Keywords: Gaussian process priors, probabilistic classiﬁcation, Laplace’s approximation, expectation propagation, marginal likelihood, evidence, MCMC</p><p>6 0.24070737 <a title="62-lsi-6" href="./jmlr-2005-Learning_the_Kernel_with_Hyperkernels_%C2%A0%C2%A0%C2%A0%C2%A0%28Kernel_Machines_Section%29.html">49 jmlr-2005-Learning the Kernel with Hyperkernels     (Kernel Machines Section)</a></p>
<p>7 0.23935707 <a title="62-lsi-7" href="./jmlr-2005-A_Bayesian_Model_for_Supervised_Clustering_with_the_Dirichlet_Process_Prior.html">2 jmlr-2005-A Bayesian Model for Supervised Clustering with the Dirichlet Process Prior</a></p>
<p>8 0.23840429 <a title="62-lsi-8" href="./jmlr-2005-Fast_Kernel_Classifiers_with_Online_and_Active_Learning.html">33 jmlr-2005-Fast Kernel Classifiers with Online and Active Learning</a></p>
<p>9 0.23749529 <a title="62-lsi-9" href="./jmlr-2005-Active_Learning_to_Recognize_Multiple_Types_of_Plankton.html">9 jmlr-2005-Active Learning to Recognize Multiple Types of Plankton</a></p>
<p>10 0.21184792 <a title="62-lsi-10" href="./jmlr-2005-Denoising_Source_Separation.html">25 jmlr-2005-Denoising Source Separation</a></p>
<p>11 0.2065551 <a title="62-lsi-11" href="./jmlr-2005-Information_Bottleneck_for_Gaussian_Variables.html">39 jmlr-2005-Information Bottleneck for Gaussian Variables</a></p>
<p>12 0.18974204 <a title="62-lsi-12" href="./jmlr-2005-Semigroup_Kernels_on_Measures.html">64 jmlr-2005-Semigroup Kernels on Measures</a></p>
<p>13 0.18615255 <a title="62-lsi-13" href="./jmlr-2005-Learning_Multiple_Tasks_with_Kernel_Methods.html">45 jmlr-2005-Learning Multiple Tasks with Kernel Methods</a></p>
<p>14 0.1834621 <a title="62-lsi-14" href="./jmlr-2005-Diffusion_Kernels_on_Statistical_Manifolds.html">26 jmlr-2005-Diffusion Kernels on Statistical Manifolds</a></p>
<p>15 0.17721023 <a title="62-lsi-15" href="./jmlr-2005-Kernel_Methods_for_Measuring_Independence.html">41 jmlr-2005-Kernel Methods for Measuring Independence</a></p>
<p>16 0.16579089 <a title="62-lsi-16" href="./jmlr-2005-Matrix_Exponentiated_Gradient_Updates_for_On-line_Learning_and_Bregman_Projection.html">55 jmlr-2005-Matrix Exponentiated Gradient Updates for On-line Learning and Bregman Projection</a></p>
<p>17 0.16533105 <a title="62-lsi-17" href="./jmlr-2005-Prioritization_Methods_for_Accelerating_MDP_Solvers.html">61 jmlr-2005-Prioritization Methods for Accelerating MDP Solvers</a></p>
<p>18 0.15973203 <a title="62-lsi-18" href="./jmlr-2005-Inner_Product_Spaces_for_Bayesian_Networks.html">40 jmlr-2005-Inner Product Spaces for Bayesian Networks</a></p>
<p>19 0.15826745 <a title="62-lsi-19" href="./jmlr-2005-Expectation_Consistent_Approximate_Inference.html">32 jmlr-2005-Expectation Consistent Approximate Inference</a></p>
<p>20 0.15441731 <a title="62-lsi-20" href="./jmlr-2005-Learning_a_Mahalanobis_Metric_from_Equivalence_Constraints.html">46 jmlr-2005-Learning a Mahalanobis Metric from Equivalence Constraints</a></p>
<br/>
<h2>similar papers computed by <a title="lda-model" href="../home/jmlr2005_lda.html">lda model</a></h2><h3>lda for this paper:</h3><p>topicId topicWeight</p>
<p>[(13, 0.017), (17, 0.014), (19, 0.024), (36, 0.595), (37, 0.041), (42, 0.014), (43, 0.018), (52, 0.07), (59, 0.024), (70, 0.034), (88, 0.057), (90, 0.014)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 0.91059244 <a title="62-lda-1" href="./jmlr-2005-Probabilistic_Non-linear_Principal_Component_Analysis_with_Gaussian_Process_Latent_Variable_Models.html">62 jmlr-2005-Probabilistic Non-linear Principal Component Analysis with Gaussian Process Latent Variable Models</a></p>
<p>Author: Neil Lawrence</p><p>Abstract: Summarising a high dimensional data set with a low dimensional embedding is a standard approach for exploring its structure. In this paper we provide an overview of some existing techniques for discovering such embeddings. We then introduce a novel probabilistic interpretation of principal component analysis (PCA) that we term dual probabilistic PCA (DPPCA). The DPPCA model has the additional advantage that the linear mappings from the embedded space can easily be nonlinearised through Gaussian processes. We refer to this model as a Gaussian process latent variable model (GP-LVM). Through analysis of the GP-LVM objective function, we relate the model to popular spectral techniques such as kernel PCA and multidimensional scaling. We then review a practical algorithm for GP-LVMs in the context of large data sets and develop it to also handle discrete valued data and missing attributes. We demonstrate the model on a range of real-world and artiﬁcially generated data sets. Keywords: Gaussian processes, latent variable models, principal component analysis, spectral methods, unsupervised learning, visualisation</p><p>2 0.83724207 <a title="62-lda-2" href="./jmlr-2005-Inner_Product_Spaces_for_Bayesian_Networks.html">40 jmlr-2005-Inner Product Spaces for Bayesian Networks</a></p>
<p>Author: Atsuyoshi Nakamura, Michael Schmitt, Niels Schmitt, Hans Ulrich Simon</p><p>Abstract: Bayesian networks have become one of the major models used for statistical inference. We study the question whether the decisions computed by a Bayesian network can be represented within a low-dimensional inner product space. We focus on two-label classiﬁcation tasks over the Boolean domain. As main results we establish upper and lower bounds on the dimension of the inner product space for Bayesian networks with an explicitly given (full or reduced) parameter collection. In particular, these bounds are tight up to a factor of 2. For some nontrivial cases of Bayesian networks we even determine the exact values of this dimension. We further consider logistic autoregressive Bayesian networks and show that every sufﬁciently expressive inner product space must have dimension at least Ω(n2 ), where n is the number of network nodes. We also derive the bound 2Ω(n) for an artiﬁcial variant of this network, thereby demonstrating the limits of our approach and raising an interesting open question. As a major technical contribution, this work reveals combinatorial and algebraic structures within Bayesian networks such that known methods for the derivation of lower bounds on the dimension of inner product spaces can be brought into play. Keywords: Bayesian network, inner product space, embedding, linear arrangement, Euclidean dimension</p><p>3 0.39866593 <a title="62-lda-3" href="./jmlr-2005-Variational_Message_Passing.html">71 jmlr-2005-Variational Message Passing</a></p>
<p>Author: John Winn, Christopher M. Bishop</p><p>Abstract: Bayesian inference is now widely established as one of the principal foundations for machine learning. In practice, exact inference is rarely possible, and so a variety of approximation techniques have been developed, one of the most widely used being a deterministic framework called variational inference. In this paper we introduce Variational Message Passing (VMP), a general purpose algorithm for applying variational inference to Bayesian Networks. Like belief propagation, VMP proceeds by sending messages between nodes in the network and updating posterior beliefs using local operations at each node. Each such update increases a lower bound on the log evidence (unless already at a local maximum). In contrast to belief propagation, VMP can be applied to a very general class of conjugate-exponential models because it uses a factorised variational approximation. Furthermore, by introducing additional variational parameters, VMP can be applied to models containing non-conjugate distributions. The VMP framework also allows the lower bound to be evaluated, and this can be used both for model comparison and for detection of convergence. Variational message passing has been implemented in the form of a general purpose inference engine called VIBES (‘Variational Inference for BayEsian networkS’) which allows models to be speciﬁed graphically and then solved variationally without recourse to coding. Keywords: Bayesian networks, variational inference, message passing</p><p>4 0.37254977 <a title="62-lda-4" href="./jmlr-2005-Learning_the_Kernel_with_Hyperkernels_%C2%A0%C2%A0%C2%A0%C2%A0%28Kernel_Machines_Section%29.html">49 jmlr-2005-Learning the Kernel with Hyperkernels     (Kernel Machines Section)</a></p>
<p>Author: Cheng Soon Ong, Alexander J. Smola, Robert C. Williamson</p><p>Abstract: This paper addresses the problem of choosing a kernel suitable for estimation with a support vector machine, hence further automating machine learning. This goal is achieved by deﬁning a reproducing kernel Hilbert space on the space of kernels itself. Such a formulation leads to a statistical estimation problem similar to the problem of minimizing a regularized risk functional. We state the equivalent representer theorem for the choice of kernels and present a semideﬁnite programming formulation of the resulting optimization problem. Several recipes for constructing hyperkernels are provided, as well as the details of common machine learning problems. Experimental results for classiﬁcation, regression and novelty detection on UCI data show the feasibility of our approach. Keywords: learning the kernel, capacity control, kernel methods, support vector machines, representer theorem, semideﬁnite programming</p><p>5 0.37239087 <a title="62-lda-5" href="./jmlr-2005-Frames%2C_Reproducing_Kernels%2C_Regularization_and_Learning.html">35 jmlr-2005-Frames, Reproducing Kernels, Regularization and Learning</a></p>
<p>Author: Alain Rakotomamonjy,  Stéphane Canu</p><p>Abstract: This work deals with a method for building a reproducing kernel Hilbert space (RKHS) from a Hilbert space with frame elements having special properties. Conditions on existence and a method of construction are given. Then, these RKHS are used within the framework of regularization theory for function approximation. Implications on semiparametric estimation are discussed and a multiscale scheme of regularization is also proposed. Results on toy and real-world approximation problems illustrate the effectiveness of such methods. Keywords: regularization, kernel, frames, wavelets</p><p>6 0.37071249 <a title="62-lda-6" href="./jmlr-2005-Learning_Module_Networks.html">44 jmlr-2005-Learning Module Networks</a></p>
<p>7 0.36994162 <a title="62-lda-7" href="./jmlr-2005-Managing_Diversity_in_Regression_Ensembles.html">54 jmlr-2005-Managing Diversity in Regression Ensembles</a></p>
<p>8 0.35829434 <a title="62-lda-8" href="./jmlr-2005-Gaussian_Processes_for_Ordinal_Regression.html">36 jmlr-2005-Gaussian Processes for Ordinal Regression</a></p>
<p>9 0.35534021 <a title="62-lda-9" href="./jmlr-2005-Separating_a_Real-Life_Nonlinear_Image_Mixture.html">65 jmlr-2005-Separating a Real-Life Nonlinear Image Mixture</a></p>
<p>10 0.35130236 <a title="62-lda-10" href="./jmlr-2005-Expectation_Consistent_Approximate_Inference.html">32 jmlr-2005-Expectation Consistent Approximate Inference</a></p>
<p>11 0.35010585 <a title="62-lda-11" href="./jmlr-2005-Semigroup_Kernels_on_Measures.html">64 jmlr-2005-Semigroup Kernels on Measures</a></p>
<p>12 0.34070322 <a title="62-lda-12" href="./jmlr-2005-Learning_the_Kernel_Function_via_Regularization.html">48 jmlr-2005-Learning the Kernel Function via Regularization</a></p>
<p>13 0.33976072 <a title="62-lda-13" href="./jmlr-2005-Denoising_Source_Separation.html">25 jmlr-2005-Denoising Source Separation</a></p>
<p>14 0.33471176 <a title="62-lda-14" href="./jmlr-2005-Information_Bottleneck_for_Gaussian_Variables.html">39 jmlr-2005-Information Bottleneck for Gaussian Variables</a></p>
<p>15 0.3290326 <a title="62-lda-15" href="./jmlr-2005-Quasi-Geodesic_Neural_Learning_Algorithms_Over_the_Orthogonal_Group%3A_A_Tutorial.html">63 jmlr-2005-Quasi-Geodesic Neural Learning Algorithms Over the Orthogonal Group: A Tutorial</a></p>
<p>16 0.32826817 <a title="62-lda-16" href="./jmlr-2005-Kernel_Methods_for_Measuring_Independence.html">41 jmlr-2005-Kernel Methods for Measuring Independence</a></p>
<p>17 0.32147932 <a title="62-lda-17" href="./jmlr-2005-Learning_Multiple_Tasks_with_Kernel_Methods.html">45 jmlr-2005-Learning Multiple Tasks with Kernel Methods</a></p>
<p>18 0.3134571 <a title="62-lda-18" href="./jmlr-2005-Learning_a_Mahalanobis_Metric_from_Equivalence_Constraints.html">46 jmlr-2005-Learning a Mahalanobis Metric from Equivalence Constraints</a></p>
<p>19 0.30944461 <a title="62-lda-19" href="./jmlr-2005-A_Unifying_View_of_Sparse_Approximate_Gaussian_Process_Regression.html">7 jmlr-2005-A Unifying View of Sparse Approximate Gaussian Process Regression</a></p>
<p>20 0.30542904 <a title="62-lda-20" href="./jmlr-2005-Core_Vector_Machines%3A_Fast_SVM_Training_on_Very_Large_Data_Sets.html">24 jmlr-2005-Core Vector Machines: Fast SVM Training on Very Large Data Sets</a></p>
<br/><br/><br/>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-48522588-1', 'makerhacker.github.io');
ga('send', 'pageview');
</script>

</body>
</html>
