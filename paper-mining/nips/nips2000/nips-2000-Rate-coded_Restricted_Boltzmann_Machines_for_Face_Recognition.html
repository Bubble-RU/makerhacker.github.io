<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>107 nips-2000-Rate-coded Restricted Boltzmann Machines for Face Recognition</title>
</head>

<body>
<p><a title="nips" href="../nips_home.html">nips</a> <a title="nips-2000" href="../home/nips2000_home.html">nips2000</a> <a title="nips-2000-107" href="#">nips2000-107</a> knowledge-graph by maker-knowledge-mining</p><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- maker adsense -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-5027806277543591"
     data-ad-slot="4192012269"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>107 nips-2000-Rate-coded Restricted Boltzmann Machines for Face Recognition</h1>
<br/><p>Source: <a title="nips-2000-107-pdf" href="http://papers.nips.cc/paper/1886-rate-coded-restricted-boltzmann-machines-for-face-recognition.pdf">pdf</a></p><p>Author: Yee Whye Teh, Geoffrey E. Hinton</p><p>Abstract: We describe a neurally-inspired, unsupervised learning algorithm that builds a non-linear generative model for pairs of face images from the same individual. Individuals are then recognized by finding the highest relative probability pair among all pairs that consist of a test image and an image whose identity is known. Our method compares favorably with other methods in the literature. The generative model consists of a single layer of rate-coded, non-linear feature detectors and it has the property that, given a data vector, the true posterior probability distribution over the feature detector activities can be inferred rapidly without iteration or approximation. The weights of the feature detectors are learned by comparing the correlations of pixel intensities and feature activations in two phases: When the network is observing real data and when it is observing reconstructions of real data generated from the feature activations.</p><p>Reference: <a title="nips-2000-107-reference" href="../nips2000_reference/nips-2000-Rate-coded_Restricted_Boltzmann_Machines_for_Face_Recognition_reference.html">text</a></p><br/><h2>Summary: the most important sentenses genereted by tfidf model</h2><p>sentIndex sentText sentNum sentScore</p><p>1 uk  Abstract We describe a neurally-inspired, unsupervised learning algorithm that builds a non-linear generative model for pairs of face images from the same individual. [sent-9, score-0.66]
</p><p>2 Individuals are then recognized by finding the highest relative probability pair among all pairs that consist of a test image and an image whose identity is known. [sent-10, score-0.493]
</p><p>3 The generative model consists of a single layer of rate-coded, non-linear feature detectors and it has the property that, given a data vector, the true posterior probability distribution over the feature detector activities can be inferred rapidly without iteration or approximation. [sent-12, score-0.204]
</p><p>4 The weights of the feature detectors are learned by comparing the correlations of pixel intensities and feature activations in two phases: When the network is observing real data and when it is observing reconstructions of real data generated from the feature activations. [sent-13, score-0.362]
</p><p>5 1 Introduction Face recognition is difficult when the number of individuals is large and the test and training images of an individual differ in expression, pose, lighting or the date on which they were taken. [sent-14, score-0.985]
</p><p>6 We start by describing a new unsupervised learning algorithm for a restricted form of Boltzmann machine [1]. [sent-17, score-0.039]
</p><p>7 We then show how to generalize the generative model and the learning algorithm to deal with real-valued pixel intensities and rate-coded feature detectors. [sent-18, score-0.191]
</p><p>8 We then apply the model to face recognition and compare it to other methods. [sent-19, score-0.307]
</p><p>9 Because there is no explaining away [3], inference in an RBM is much easier than in a general Boltzmann machine or in a causal belief network with one hidden layer. [sent-22, score-0.208]
</p><p>10 There is no need to perform any iteration to determine the activities of the hidden units, as the hidden states, Sj, are conditionally independent given the visible states, Si . [sent-23, score-0.504]
</p><p>11 The distribution of Sj is given by the standard logistic function: p(Sj  = llsi) =  1 1 + exp( _ Li WijSi)  (1)  Conversely, the hidden states of an RBM are marginally dependent so it is easy for an RBM to learn population codes in which units may be highly correlated. [sent-24, score-0.365]
</p><p>12 It is hard to do this in causal belief networks with one hidden layer because the generative model of a causal belief net assumes marginal independence. [sent-25, score-0.374]
</p><p>13 One way to implement this algorithm is to start the network with a data vector on the visible units and then to alternate between updating all of the hidden units in parallel and updating all of the visible units in parallel with Gibbs sampling. [sent-27, score-1.037]
</p><p>14 This learning rule does not work well because it can take a long time to approach equilibrium and the sampling noise in the estimate of < SiSj >Q~ can swamp the gradient. [sent-30, score-0.042]
</p><p>15 A simple way to increase the representational power without changing the inference and learning procedures is to imagine that  each visible unit, i, has 10 replicas which all have identical weights to the hidden units. [sent-33, score-0.49]
</p><p>16 So far as the hidden units are concerned, it makes no difference which particular replicas are turned on: it is only the number of active replicas that counts. [sent-34, score-0.579]
</p><p>17 So a pixel can now have 11 different intensities. [sent-35, score-0.073]
</p><p>18 During reconstruction of the image from the hidden activities, all the replicas can share the computation of the probability, Pi, of turning on, and then we can select n replicas to be on with probability (~)nPi (10 - n)(1-p;). [sent-36, score-0.524]
</p><p>19 We assumed that the visible units can produce up to 10 spikes and the hidden units can produce up to 100 spikes. [sent-43, score-0.64]
</p><p>20 3 by their expected values and we used the expected value of Si when computing the probability of activation of the hidden units. [sent-45, score-0.157]
</p><p>21 However, we continued to use the stochastically chosen integer firing rates of the hidden units when computing the one-step reconstructions of the data, so the hidden activities cannot transmit an unbounded amount of information from the data to the reconstruction. [sent-46, score-0.606]
</p><p>22 A simple way to use RBMrate for face recognition is to train a single model on the training set, and to identify a face by finding the gallery image that produces a hidden activity vector that is most similar to the one produced by the face. [sent-47, score-1.095]
</p><p>23 This is how eigenfaces are used for recognition, but it does not work well because it does not take into account the fact that some variations across faces are important for recognition, while some variations are not. [sent-48, score-0.341]
</p><p>24 To correct this, we instead trained an RBMrate model on pairs of different images of the same individual, and then we used this model of pairs to decide which gallery image is best paired with the test image. [sent-49, score-0.921]
</p><p>25 To account for the fact that the model likes some individual face images more than others, we define the fit between two faces hand 12 as G(h, h) + G(h,h) - G(h,h) - G(h,h) where the goodness score G(VI,V2) is the negative free energy of the image pair VI, V2 under the model. [sent-50, score-0.929]
</p><p>26 However, to preserve symmetry, each pair of images of the same individual VI, V2 in the training set has a reversed pair V2, VI in the set. [sent-52, score-0.573]
</p><p>27 We trained the model with 100 hidden units on 1000 image pairs (500 distinct pairs) for 2000 iterations in batches of 100, with a learning rate of 2. [sent-53, score-0.53]
</p><p>28 One advantage of eigenfaces over correlation is that once the test image has been converted into a vector of eigenface activations, comparisons of test and gallery images can be made in the low-dimensional space of eigenface activations rather than the high-dimensional space of pixel intensities. [sent-56, score-1.278]
</p><p>29 The same applies to our face-pair network, as the goodness score of an image pair is a simple function of the total input received by each hidden unit from each image. [sent-57, score-0.513]
</p><p>30 The total inputs from each gallery image can be precomputed and stored, while the total inputs from a test image only needs to be computed once for comparisons with all gallery images. [sent-58, score-0.752]
</p><p>31 4 The FERET database Our version of the FERET database contained 1002 frontal face images of 429 individuals taken over a period of a few years under varying lighting conditions. [sent-59, score-0.963]
</p><p>32 Of these images, 818 are used as both the gallery and the training set and the remaining 184 are divided into four disjoint test sets: The . [sent-60, score-0.359]
</p><p>33 The training set also includes a further 244 pairs of images that differ only in expression. [sent-65, score-0.465]
</p><p>34 The ildays test set contains 40 images that come from 20 individuals. [sent-66, score-0.432]
</p><p>35 Each of these individuals has two images from the same session in the training set and two images taken in a session 4 days later or earlier in the test set. [sent-67, score-1.157]
</p><p>36 A further 28 individuals were photographed 4 days apart and all 112 of these images are in the training set. [sent-68, score-0.591]
</p><p>37 The ilmonths test set is just like the ~days test set except that the time between sessions was at least three months and different lighting conditions were present in the two sessions. [sent-69, score-0.446]
</p><p>38 A further 36 images of 9 more individuals were included in the training set. [sent-71, score-0.517]
</p><p>39 The ilglasses test set contains 14 images of 7 different individuals. [sent-72, score-0.432]
</p><p>40 Each of these individuals has two images in the training set that were taken in another session on the same day. [sent-73, score-0.604]
</p><p>41 The training and test pairs for an individual differ in that one pair has glasses and the other does not. [sent-74, score-0.489]
</p><p>42 The training set includes a further 24 images, half with glasses and half without, from 6 more individuals. [sent-75, score-0.296]
</p><p>43 The images include the whole head, parts of the shoulder, and background. [sent-76, score-0.282]
</p><p>44 Instead of working with whole images, which contain much irrelevant information, we worked with face images that were normalized as shown in figure 2. [sent-77, score-0.501]
</p><p>45 Masking out all of the background inevitably looses the contour of the face which contains much discriminative information. [sent-78, score-0.37]
</p><p>46 The histogram equalization step removes most lighting effects, but it also removes some relevant information like the skin tone. [sent-79, score-0.335]
</p><p>47 For the best performance, the contour shape and skin tone would have to be used as additional sources of discriminative information. [sent-80, score-0.296]
</p><p>48 5 Comparative results We compared RBMrate with four popular face recognition methods. [sent-81, score-0.307]
</p><p>49 The first and simplest is correlation, which returns the similarity score as the angle between two images represented as vectors of pixel intensities. [sent-82, score-0.484]
</p><p>50 The second method is eigenfaces [5], which first projects the images onto the principal component subspaces, then returns the similarity score as the angle between the projected images. [sent-84, score-0.691]
</p><p>51 Instead of projecting the images onto the subspace of the principal components, which maximizes the variance  . [sent-86, score-0.38]
</p><p>52 15  e  e  10  10  CD  CD  5 0  5  corr  corr  30  100  25  _  ~  . [sent-106, score-0.2]
</p><p>53 e  g  10  CD  Q)  5 0  80  ~ 0  corr  eigen  fisher  oppca RBMrate  60 40 20 0  corr  eigen  fisher  oppca RBMrate  Figure 3: Error rates of all methods on all test sets. [sent-111, score-0.61]
</p><p>54 The bars in each group correspond, from left to right, to the rank-I, rank-2, rank-4, rank-8 and rank-16 error rates. [sent-112, score-0.035]
</p><p>55 The rank-n error rate is the percentage of test images where the n most similar gallery images are all incorrect. [sent-113, score-0.876]
</p><p>56 among the projected images, fisherfaces projects the images onto a subspace which, at the same time, maximizes the between individual variances and minimizes the within individual variances in the training set. [sent-114, score-0.67]
</p><p>57 This method models differences between images of the same individual as a PPCA [8, 9], and differences between images of different individuals as another PPCA. [sent-116, score-0.808]
</p><p>58 Then given a difference of two images, it returns as the similarity score the likelihood ratio of the difference image under the two PPCA models. [sent-117, score-0.248]
</p><p>59 It was the best performing algorithm in the September 1996 FERET test [10]. [sent-118, score-0.158]
</p><p>60 For eigenfaces, we used 199 principal components, omitting the first principal component, as we determined manually that it encodes simply for lighting conditions. [sent-119, score-0.264]
</p><p>61 This improved the recognition performances on all the test sets except for ~exp r ession . [sent-120, score-0.198]
</p><p>62 We used a subspace of dimension 200 for fisherfaces, while we used 10 and 30 dimensional PPCAs for the within-class and between-class model of c5ppca respectively. [sent-121, score-0.045]
</p><p>63 These are the same numbers used by Moghaddam et at and gives the best results in our simulations. [sent-122, score-0.048]
</p><p>64 The number of dimensions or hidden units used by each method was optimized for that particular method for best performance. [sent-123, score-0.379]
</p><p>65 Figure 3 shows the error rates of all five methods on the test sets. [sent-124, score-0.11]
</p><p>66 Correlation and eigenfaces perform poorly on ~expre s s i o n, probably because they do not attempt to ignore the within-individual variations, whereas the other methods do. [sent-126, score-0.244]
</p><p>67 All the models did very poorly on the ~months test set which is unfortunate as this is the test set that is most like real applications. [sent-127, score-0.22]
</p><p>68 RBMrate performed best on ~expre s s i o n, fisherfaces is best on ~days and ~glasses ,while eigenfaces is best on ~months . [sent-128, score-0.477]
</p><p>69 Most human observers cannot find the correct match within these 8. [sent-131, score-0.039]
</p><p>70 Top half: with unconstrained weights; bottom half: with non-negative weight constraints. [sent-134, score-0.039]
</p><p>71 contour produced by masking out all of the background. [sent-135, score-0.141]
</p><p>72 6 Receptive fields learned by RBMrate The top half of figure 5 shows the weights of a few of the hidden units after training. [sent-136, score-0.492]
</p><p>73 All the units encode global features, probably because the image normalization ensures that there are strong long range correlations in pixel intensities. [sent-137, score-0.457]
</p><p>74 Note, however, that the hidden unit activations range from 0 to 100. [sent-141, score-0.282]
</p><p>75 On the left are 4 units exhibiting interesting features and on the right are 4 units chosen at random. [sent-142, score-0.463]
</p><p>76 The top unit of the first column seems to be encoding the presence of mustache in both faces. [sent-143, score-0.086]
</p><p>77 The bottom unit seems to be coding for prominent right eyebrows in both faces. [sent-144, score-0.086]
</p><p>78 Note that these are facial features which often remain constant across images of the same individual. [sent-145, score-0.397]
</p><p>79 In the second column are two features which seem to encode for different facial expressions in the two faces. [sent-146, score-0.154]
</p><p>80 The right side of the top unit encodes a smile while the left side is expressionless. [sent-147, score-0.082]
</p><p>81 So the network has discovered some features which are fairly constant across images in the same class, and some features which can differ substantially within a class. [sent-149, score-0.498]
</p><p>82 Inspired by [11], we tried to enforce local features by restricting the weights to be non-  negative. [sent-150, score-0.154]
</p><p>83 This is achieved by resetting negative weights to zero after each weight update. [sent-151, score-0.074]
</p><p>84 The bottom half of figure 5 shows some of the hidden receptive fields learned. [sent-152, score-0.283]
</p><p>85 Except for the 4 features on the left, all other features are local and code for features like mouth shape changes (third column) and eyes and cheeks (fourth column). [sent-153, score-0.282]
</p><p>86 The 4 features on the left are much more global and clearly capture the fact that the direction of the lighting can differfor two images of the same person. [sent-154, score-0.555]
</p><p>87 Unfortunately, constraining the weights to be non-negative strongly limits the representational power of RBMrate and makes it worse than all the other methods on all the test sets. [sent-155, score-0.184]
</p><p>88 7  Conclusions  We have introduced a new method for face recognition based on a non-linear generative model. [sent-156, score-0.386]
</p><p>89 The generative model can be very complex, yet retains the efficiency required for applications. [sent-157, score-0.079]
</p><p>90 Performance on the FERET database is comparable to popular methods. [sent-158, score-0.058]
</p><p>91 However, unlike other methods based on linear models, there is plenty of room for further development using prior knowledge to constrain the weights or additional layers of hidden units to model the correlations of feature detector activities. [sent-159, score-0.474]
</p><p>92 Eigenfaces versus fisherfaces: recognition using class specific linear projection. [sent-206, score-0.088]
</p>
<br/>
<h2>similar papers computed by tfidf model</h2><h3>tfidf for this paper:</h3><p>wordName wordTfidf (topN-words)</p>
<p>[('rbmrate', 0.347), ('images', 0.282), ('face', 0.219), ('gallery', 0.202), ('eigenfaces', 0.188), ('individuals', 0.188), ('units', 0.174), ('feret', 0.173), ('lighting', 0.158), ('hidden', 0.157), ('rbm', 0.149), ('fisherfaces', 0.145), ('visible', 0.135), ('replicas', 0.124), ('image', 0.119), ('test', 0.11), ('boltzmann', 0.1), ('corr', 0.1), ('sisj', 0.1), ('score', 0.088), ('recognition', 0.088), ('half', 0.087), ('ppca', 0.087), ('session', 0.087), ('skin', 0.087), ('moghaddam', 0.084), ('pairs', 0.08), ('features', 0.08), ('generative', 0.079), ('activations', 0.078), ('sj', 0.078), ('glasses', 0.075), ('weights', 0.074), ('days', 0.074), ('pixel', 0.073), ('months', 0.068), ('pair', 0.065), ('contrastive', 0.063), ('faces', 0.063), ('reconstructions', 0.063), ('contour', 0.06), ('database', 0.058), ('eigen', 0.058), ('eigenface', 0.058), ('expre', 0.058), ('nths', 0.058), ('oppca', 0.058), ('oval', 0.058), ('phillips', 0.058), ('reversed', 0.058), ('differ', 0.056), ('individual', 0.056), ('probably', 0.056), ('activities', 0.055), ('gibbs', 0.055), ('principal', 0.053), ('causal', 0.051), ('cd', 0.051), ('discriminative', 0.051), ('hinton', 0.05), ('tone', 0.05), ('explorations', 0.05), ('mcclelland', 0.05), ('microstructure', 0.05), ('best', 0.048), ('unit', 0.047), ('training', 0.047), ('subspace', 0.045), ('variations', 0.045), ('rumelhart', 0.045), ('removes', 0.045), ('vi', 0.044), ('produced', 0.044), ('parallel', 0.044), ('si', 0.044), ('equilibrium', 0.042), ('eyes', 0.042), ('september', 0.042), ('gatsby', 0.041), ('returns', 0.041), ('contains', 0.04), ('pixels', 0.04), ('bottom', 0.039), ('column', 0.039), ('intensities', 0.039), ('observers', 0.039), ('alternating', 0.039), ('projects', 0.039), ('divergence', 0.039), ('restricted', 0.039), ('goodness', 0.037), ('masking', 0.037), ('qo', 0.037), ('layer', 0.036), ('facial', 0.035), ('left', 0.035), ('correlations', 0.035), ('states', 0.034), ('detector', 0.034), ('fisher', 0.034)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 1.0000007 <a title="107-tfidf-1" href="./nips-2000-Rate-coded_Restricted_Boltzmann_Machines_for_Face_Recognition.html">107 nips-2000-Rate-coded Restricted Boltzmann Machines for Face Recognition</a></p>
<p>Author: Yee Whye Teh, Geoffrey E. Hinton</p><p>Abstract: We describe a neurally-inspired, unsupervised learning algorithm that builds a non-linear generative model for pairs of face images from the same individual. Individuals are then recognized by finding the highest relative probability pair among all pairs that consist of a test image and an image whose identity is known. Our method compares favorably with other methods in the literature. The generative model consists of a single layer of rate-coded, non-linear feature detectors and it has the property that, given a data vector, the true posterior probability distribution over the feature detector activities can be inferred rapidly without iteration or approximation. The weights of the feature detectors are learned by comparing the correlations of pixel intensities and feature activations in two phases: When the network is observing real data and when it is observing reconstructions of real data generated from the feature activations.</p><p>2 0.3904123 <a title="107-tfidf-2" href="./nips-2000-Recognizing_Hand-written_Digits_Using_Hierarchical_Products_of_Experts.html">108 nips-2000-Recognizing Hand-written Digits Using Hierarchical Products of Experts</a></p>
<p>Author: Guy Mayraz, Geoffrey E. Hinton</p><p>Abstract: The product of experts learning procedure [1] can discover a set of stochastic binary features that constitute a non-linear generative model of handwritten images of digits. The quality of generative models learned in this way can be assessed by learning a separate model for each class of digit and then comparing the unnormalized probabilities of test images under the 10 different class-specific models. To improve discriminative performance, it is helpful to learn a hierarchy of separate models for each digit class. Each model in the hierarchy has one layer of hidden units and the nth level model is trained on data that consists of the activities of the hidden units in the already trained (n - l)th level model. After training, each level produces a separate, unnormalized log probabilty score. With a three-level hierarchy for each of the 10 digit classes, a test image produces 30 scores which can be used as inputs to a supervised, logistic classification network that is trained on separate data. On the MNIST database, our system is comparable with current state-of-the-art discriminative methods, demonstrating that the product of experts learning procedure can produce effective generative models of high-dimensional data. 1 Learning products of stochastic binary experts Hinton [1] describes a learning algorithm for probabilistic generative models that are composed of a number of experts. Each expert specifies a probability distribution over the visible variables and the experts are combined by multiplying these distributions together and renormalizing. (1) where d is a data vector in a discrete space, Om is all the parameters of individual model m, Pm(dIOm) is the probability of d under model m, and c is an index over all possible vectors in the data space. A Restricted Boltzmann machine [2, 3] is a special case of a product of experts in which each expert is a single, binary stochastic hidden unit that has symmetrical connections to a set of visible units, and connections between the hidden units are forbidden. Inference in an RBM is much easier than in a general Boltzmann machine and it is also much easier than in a causal belief net because there is no explaining away. There is therefore no need to perform any iteration to determine the activities of the hidden units. The hidden states, Sj , are conditionally independent given the visible states, Si, and the distribution of Sj is given by the standard logistic function : 1 p(Sj = 1) = (2) 1 + exp( - Li WijSi) Conversely, the hidden states of an RBM are marginally dependent so it is easy for an RBM to learn population codes in which units may be highly correlated. It is hard to do this in causal belief nets with one hidden layer because the generative model of a causal belief net assumes marginal independence. An RBM can be trained using the standard Boltzmann machine learning algorithm which follows a noisy but unbiased estimate of the gradient of the log likelihood of the data. One way to implement this algorithm is to start the network with a data vector on the visible units and then to alternate between updating all of the hidden units in parallel and updating all of the visible units in parallel. Each update picks a binary state for a unit from its posterior distribution given the current states of all the units in the other set. If this alternating Gibbs sampling is run to equilibrium, there is a very simple way to update the weights so as to minimize the Kullback-Leibler divergence, QOIIQoo, between the data distribution, QO, and the equilibrium distribution of fantasies over the visible units, Qoo, produced by the RBM [4]: flWij oc QO - Q~ (3) where < SiSj >Qo is the expected value of SiSj when data is clamped on the visible units and the hidden states are sampled from their conditional distribution given the data, and Q ~ is the expected value of SiSj after prolonged Gibbs sampling. This learning rule does not work well because it can take a long time to approach thermal equilibrium and the sampling noise in the estimate of  Q ~ can swamp the gradient. [1] shows that it is far more effective to minimize the difference between QOllQoo and Q111Qoo where Q1 is the distribution of the one-step reconstructions of the data that are produced by first picking binary hidden states from their conditional distribution given the data and then picking binary visible states from their conditional distribution given the hidden states. The exact gradient of this</p><p>3 0.18023469 <a title="107-tfidf-3" href="./nips-2000-A_Comparison_of_Image_Processing_Techniques_for_Visual_Speech_Recognition_Applications.html">2 nips-2000-A Comparison of Image Processing Techniques for Visual Speech Recognition Applications</a></p>
<p>Author: Michael S. Gray, Terrence J. Sejnowski, Javier R. Movellan</p><p>Abstract: We examine eight different techniques for developing visual representations in machine vision tasks. In particular we compare different versions of principal component and independent component analysis in combination with stepwise regression methods for variable selection. We found that local methods, based on the statistics of image patches, consistently outperformed global methods based on the statistics of entire images. This result is consistent with previous work on emotion and facial expression recognition. In addition, the use of a stepwise regression technique for selecting variables and regions of interest substantially boosted performance. 1</p><p>4 0.12958838 <a title="107-tfidf-4" href="./nips-2000-Discovering_Hidden_Variables%3A_A_Structure-Based_Approach.html">41 nips-2000-Discovering Hidden Variables: A Structure-Based Approach</a></p>
<p>Author: Gal Elidan, Noam Lotner, Nir Friedman, Daphne Koller</p><p>Abstract: A serious problem in learning probabilistic models is the presence of hidden variables. These variables are not observed, yet interact with several of the observed variables. As such, they induce seemingly complex dependencies among the latter. In recent years, much attention has been devoted to the development of algorithms for learning parameters, and in some cases structure, in the presence of hidden variables. In this paper, we address the related problem of detecting hidden variables that interact with the observed variables. This problem is of interest both for improving our understanding of the domain and as a preliminary step that guides the learning procedure towards promising models. A very natural approach is to search for</p><p>5 0.12733179 <a title="107-tfidf-5" href="./nips-2000-Emergence_of_Movement_Sensitive_Neurons%27_Properties_by_Learning_a_Sparse_Code_for_Natural_Moving_Images.html">45 nips-2000-Emergence of Movement Sensitive Neurons' Properties by Learning a Sparse Code for Natural Moving Images</a></p>
<p>Author: Rafal Bogacz, Malcolm W. Brown, Christophe G. Giraud-Carrier</p><p>Abstract: Olshausen & Field demonstrated that a learning algorithm that attempts to generate a sparse code for natural scenes develops a complete family of localised, oriented, bandpass receptive fields, similar to those of 'simple cells' in VI. This paper describes an algorithm which finds a sparse code for sequences of images that preserves information about the input. This algorithm when trained on natural video sequences develops bases representing the movement in particular directions with particular speeds, similar to the receptive fields of the movement-sensitive cells observed in cortical visual areas. Furthermore, in contrast to previous approaches to learning direction selectivity, the timing of neuronal activity encodes the phase of the movement, so the precise timing of spikes is crucially important to the information encoding.</p><p>6 0.11239491 <a title="107-tfidf-6" href="./nips-2000-Using_Free_Energies_to_Represent_Q-values_in_a_Multiagent_Reinforcement_Learning_Task.html">142 nips-2000-Using Free Energies to Represent Q-values in a Multiagent Reinforcement Learning Task</a></p>
<p>7 0.088298485 <a title="107-tfidf-7" href="./nips-2000-Shape_Context%3A_A_New_Descriptor_for_Shape_Matching_and_Object_Recognition.html">117 nips-2000-Shape Context: A New Descriptor for Shape Matching and Object Recognition</a></p>
<p>8 0.08708398 <a title="107-tfidf-8" href="./nips-2000-The_Manhattan_World_Assumption%3A_Regularities_in_Scene_Statistics_which_Enable_Bayesian_Inference.html">135 nips-2000-The Manhattan World Assumption: Regularities in Scene Statistics which Enable Bayesian Inference</a></p>
<p>9 0.084671088 <a title="107-tfidf-9" href="./nips-2000-Partially_Observable_SDE_Models_for_Image_Sequence_Recognition_Tasks.html">98 nips-2000-Partially Observable SDE Models for Image Sequence Recognition Tasks</a></p>
<p>10 0.079635039 <a title="107-tfidf-10" href="./nips-2000-Redundancy_and_Dimensionality_Reduction_in_Sparse-Distributed_Representations_of_Natural_Objects_in_Terms_of_Their_Local_Features.html">109 nips-2000-Redundancy and Dimensionality Reduction in Sparse-Distributed Representations of Natural Objects in Terms of Their Local Features</a></p>
<p>11 0.079208985 <a title="107-tfidf-11" href="./nips-2000-Propagation_Algorithms_for_Variational_Bayesian_Learning.html">106 nips-2000-Propagation Algorithms for Variational Bayesian Learning</a></p>
<p>12 0.079077736 <a title="107-tfidf-12" href="./nips-2000-Position_Variance%2C_Recurrence_and_Perceptual_Learning.html">102 nips-2000-Position Variance, Recurrence and Perceptual Learning</a></p>
<p>13 0.078890413 <a title="107-tfidf-13" href="./nips-2000-Feature_Correspondence%3A_A_Markov_Chain_Monte_Carlo_Approach.html">53 nips-2000-Feature Correspondence: A Markov Chain Monte Carlo Approach</a></p>
<p>14 0.076961145 <a title="107-tfidf-14" href="./nips-2000-Learning_Joint_Statistical_Models_for_Audio-Visual_Fusion_and_Segregation.html">78 nips-2000-Learning Joint Statistical Models for Audio-Visual Fusion and Segregation</a></p>
<p>15 0.076074488 <a title="107-tfidf-15" href="./nips-2000-A_Tighter_Bound_for_Graphical_Models.html">13 nips-2000-A Tighter Bound for Graphical Models</a></p>
<p>16 0.076064594 <a title="107-tfidf-16" href="./nips-2000-One_Microphone_Source_Separation.html">96 nips-2000-One Microphone Source Separation</a></p>
<p>17 0.07601691 <a title="107-tfidf-17" href="./nips-2000-Accumulator_Networks%3A_Suitors_of_Local_Probability_Propagation.html">15 nips-2000-Accumulator Networks: Suitors of Local Probability Propagation</a></p>
<p>18 0.073909797 <a title="107-tfidf-18" href="./nips-2000-A_Productive%2C_Systematic_Framework_for_the_Representation_of_Visual_Structure.html">10 nips-2000-A Productive, Systematic Framework for the Representation of Visual Structure</a></p>
<p>19 0.071529284 <a title="107-tfidf-19" href="./nips-2000-Beyond_Maximum_Likelihood_and_Density_Estimation%3A_A_Sample-Based_Criterion_for_Unsupervised_Learning_of_Complex_Models.html">31 nips-2000-Beyond Maximum Likelihood and Density Estimation: A Sample-Based Criterion for Unsupervised Learning of Complex Models</a></p>
<p>20 0.069051191 <a title="107-tfidf-20" href="./nips-2000-Incorporating_Second-Order_Functional_Knowledge_for_Better_Option_Pricing.html">69 nips-2000-Incorporating Second-Order Functional Knowledge for Better Option Pricing</a></p>
<br/>
<h2>similar papers computed by <a title="lsi-model" href="../home/nips2000_lsi.html">lsi model</a></h2><h3>lsi for this paper:</h3><p>topicId topicWeight</p>
<p>[(0, 0.267), (1, -0.117), (2, 0.136), (3, 0.033), (4, 0.056), (5, 0.03), (6, 0.185), (7, -0.079), (8, 0.194), (9, 0.062), (10, 0.069), (11, -0.481), (12, 0.227), (13, -0.067), (14, 0.035), (15, 0.09), (16, -0.011), (17, 0.006), (18, -0.131), (19, -0.185), (20, 0.012), (21, 0.019), (22, -0.037), (23, 0.088), (24, 0.011), (25, 0.075), (26, -0.041), (27, -0.01), (28, -0.015), (29, 0.016), (30, -0.021), (31, -0.039), (32, -0.018), (33, 0.004), (34, 0.099), (35, -0.045), (36, -0.009), (37, -0.057), (38, -0.039), (39, 0.037), (40, 0.036), (41, 0.009), (42, 0.057), (43, 0.038), (44, 0.033), (45, 0.068), (46, -0.026), (47, -0.014), (48, 0.002), (49, 0.001)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 0.96889031 <a title="107-lsi-1" href="./nips-2000-Rate-coded_Restricted_Boltzmann_Machines_for_Face_Recognition.html">107 nips-2000-Rate-coded Restricted Boltzmann Machines for Face Recognition</a></p>
<p>Author: Yee Whye Teh, Geoffrey E. Hinton</p><p>Abstract: We describe a neurally-inspired, unsupervised learning algorithm that builds a non-linear generative model for pairs of face images from the same individual. Individuals are then recognized by finding the highest relative probability pair among all pairs that consist of a test image and an image whose identity is known. Our method compares favorably with other methods in the literature. The generative model consists of a single layer of rate-coded, non-linear feature detectors and it has the property that, given a data vector, the true posterior probability distribution over the feature detector activities can be inferred rapidly without iteration or approximation. The weights of the feature detectors are learned by comparing the correlations of pixel intensities and feature activations in two phases: When the network is observing real data and when it is observing reconstructions of real data generated from the feature activations.</p><p>2 0.88358897 <a title="107-lsi-2" href="./nips-2000-Recognizing_Hand-written_Digits_Using_Hierarchical_Products_of_Experts.html">108 nips-2000-Recognizing Hand-written Digits Using Hierarchical Products of Experts</a></p>
<p>Author: Guy Mayraz, Geoffrey E. Hinton</p><p>Abstract: The product of experts learning procedure [1] can discover a set of stochastic binary features that constitute a non-linear generative model of handwritten images of digits. The quality of generative models learned in this way can be assessed by learning a separate model for each class of digit and then comparing the unnormalized probabilities of test images under the 10 different class-specific models. To improve discriminative performance, it is helpful to learn a hierarchy of separate models for each digit class. Each model in the hierarchy has one layer of hidden units and the nth level model is trained on data that consists of the activities of the hidden units in the already trained (n - l)th level model. After training, each level produces a separate, unnormalized log probabilty score. With a three-level hierarchy for each of the 10 digit classes, a test image produces 30 scores which can be used as inputs to a supervised, logistic classification network that is trained on separate data. On the MNIST database, our system is comparable with current state-of-the-art discriminative methods, demonstrating that the product of experts learning procedure can produce effective generative models of high-dimensional data. 1 Learning products of stochastic binary experts Hinton [1] describes a learning algorithm for probabilistic generative models that are composed of a number of experts. Each expert specifies a probability distribution over the visible variables and the experts are combined by multiplying these distributions together and renormalizing. (1) where d is a data vector in a discrete space, Om is all the parameters of individual model m, Pm(dIOm) is the probability of d under model m, and c is an index over all possible vectors in the data space. A Restricted Boltzmann machine [2, 3] is a special case of a product of experts in which each expert is a single, binary stochastic hidden unit that has symmetrical connections to a set of visible units, and connections between the hidden units are forbidden. Inference in an RBM is much easier than in a general Boltzmann machine and it is also much easier than in a causal belief net because there is no explaining away. There is therefore no need to perform any iteration to determine the activities of the hidden units. The hidden states, Sj , are conditionally independent given the visible states, Si, and the distribution of Sj is given by the standard logistic function : 1 p(Sj = 1) = (2) 1 + exp( - Li WijSi) Conversely, the hidden states of an RBM are marginally dependent so it is easy for an RBM to learn population codes in which units may be highly correlated. It is hard to do this in causal belief nets with one hidden layer because the generative model of a causal belief net assumes marginal independence. An RBM can be trained using the standard Boltzmann machine learning algorithm which follows a noisy but unbiased estimate of the gradient of the log likelihood of the data. One way to implement this algorithm is to start the network with a data vector on the visible units and then to alternate between updating all of the hidden units in parallel and updating all of the visible units in parallel. Each update picks a binary state for a unit from its posterior distribution given the current states of all the units in the other set. If this alternating Gibbs sampling is run to equilibrium, there is a very simple way to update the weights so as to minimize the Kullback-Leibler divergence, QOIIQoo, between the data distribution, QO, and the equilibrium distribution of fantasies over the visible units, Qoo, produced by the RBM [4]: flWij oc QO - Q~ (3) where < SiSj >Qo is the expected value of SiSj when data is clamped on the visible units and the hidden states are sampled from their conditional distribution given the data, and Q ~ is the expected value of SiSj after prolonged Gibbs sampling. This learning rule does not work well because it can take a long time to approach thermal equilibrium and the sampling noise in the estimate of  Q ~ can swamp the gradient. [1] shows that it is far more effective to minimize the difference between QOllQoo and Q111Qoo where Q1 is the distribution of the one-step reconstructions of the data that are produced by first picking binary hidden states from their conditional distribution given the data and then picking binary visible states from their conditional distribution given the hidden states. The exact gradient of this</p><p>3 0.47961259 <a title="107-lsi-3" href="./nips-2000-A_Comparison_of_Image_Processing_Techniques_for_Visual_Speech_Recognition_Applications.html">2 nips-2000-A Comparison of Image Processing Techniques for Visual Speech Recognition Applications</a></p>
<p>Author: Michael S. Gray, Terrence J. Sejnowski, Javier R. Movellan</p><p>Abstract: We examine eight different techniques for developing visual representations in machine vision tasks. In particular we compare different versions of principal component and independent component analysis in combination with stepwise regression methods for variable selection. We found that local methods, based on the statistics of image patches, consistently outperformed global methods based on the statistics of entire images. This result is consistent with previous work on emotion and facial expression recognition. In addition, the use of a stepwise regression technique for selecting variables and regions of interest substantially boosted performance. 1</p><p>4 0.45029268 <a title="107-lsi-4" href="./nips-2000-Using_Free_Energies_to_Represent_Q-values_in_a_Multiagent_Reinforcement_Learning_Task.html">142 nips-2000-Using Free Energies to Represent Q-values in a Multiagent Reinforcement Learning Task</a></p>
<p>Author: Brian Sallans, Geoffrey E. Hinton</p><p>Abstract: The problem of reinforcement learning in large factored Markov decision processes is explored. The Q-value of a state-action pair is approximated by the free energy of a product of experts network. Network parameters are learned on-line using a modified SARSA algorithm which minimizes the inconsistency of the Q-values of consecutive state-action pairs. Actions are chosen based on the current value estimates by fixing the current state and sampling actions from the network using Gibbs sampling. The algorithm is tested on a co-operative multi-agent task. The product of experts model is found to perform comparably to table-based Q-Iearning for small instances of the task, and continues to perform well when the problem becomes too large for a table-based representation.</p><p>5 0.43269467 <a title="107-lsi-5" href="./nips-2000-Discovering_Hidden_Variables%3A_A_Structure-Based_Approach.html">41 nips-2000-Discovering Hidden Variables: A Structure-Based Approach</a></p>
<p>Author: Gal Elidan, Noam Lotner, Nir Friedman, Daphne Koller</p><p>Abstract: A serious problem in learning probabilistic models is the presence of hidden variables. These variables are not observed, yet interact with several of the observed variables. As such, they induce seemingly complex dependencies among the latter. In recent years, much attention has been devoted to the development of algorithms for learning parameters, and in some cases structure, in the presence of hidden variables. In this paper, we address the related problem of detecting hidden variables that interact with the observed variables. This problem is of interest both for improving our understanding of the domain and as a preliminary step that guides the learning procedure towards promising models. A very natural approach is to search for</p><p>6 0.40987983 <a title="107-lsi-6" href="./nips-2000-Overfitting_in_Neural_Nets%3A_Backpropagation%2C_Conjugate_Gradient%2C_and_Early_Stopping.html">97 nips-2000-Overfitting in Neural Nets: Backpropagation, Conjugate Gradient, and Early Stopping</a></p>
<p>7 0.3953492 <a title="107-lsi-7" href="./nips-2000-Emergence_of_Movement_Sensitive_Neurons%27_Properties_by_Learning_a_Sparse_Code_for_Natural_Moving_Images.html">45 nips-2000-Emergence of Movement Sensitive Neurons' Properties by Learning a Sparse Code for Natural Moving Images</a></p>
<p>8 0.39090511 <a title="107-lsi-8" href="./nips-2000-The_Manhattan_World_Assumption%3A_Regularities_in_Scene_Statistics_which_Enable_Bayesian_Inference.html">135 nips-2000-The Manhattan World Assumption: Regularities in Scene Statistics which Enable Bayesian Inference</a></p>
<p>9 0.34800172 <a title="107-lsi-9" href="./nips-2000-Redundancy_and_Dimensionality_Reduction_in_Sparse-Distributed_Representations_of_Natural_Objects_in_Terms_of_Their_Local_Features.html">109 nips-2000-Redundancy and Dimensionality Reduction in Sparse-Distributed Representations of Natural Objects in Terms of Their Local Features</a></p>
<p>10 0.33337739 <a title="107-lsi-10" href="./nips-2000-Partially_Observable_SDE_Models_for_Image_Sequence_Recognition_Tasks.html">98 nips-2000-Partially Observable SDE Models for Image Sequence Recognition Tasks</a></p>
<p>11 0.32808325 <a title="107-lsi-11" href="./nips-2000-Structure_Learning_in_Human_Causal_Induction.html">127 nips-2000-Structure Learning in Human Causal Induction</a></p>
<p>12 0.30138758 <a title="107-lsi-12" href="./nips-2000-Feature_Correspondence%3A_A_Markov_Chain_Monte_Carlo_Approach.html">53 nips-2000-Feature Correspondence: A Markov Chain Monte Carlo Approach</a></p>
<p>13 0.28713673 <a title="107-lsi-13" href="./nips-2000-Accumulator_Networks%3A_Suitors_of_Local_Probability_Propagation.html">15 nips-2000-Accumulator Networks: Suitors of Local Probability Propagation</a></p>
<p>14 0.27797145 <a title="107-lsi-14" href="./nips-2000-A_Productive%2C_Systematic_Framework_for_the_Representation_of_Visual_Structure.html">10 nips-2000-A Productive, Systematic Framework for the Representation of Visual Structure</a></p>
<p>15 0.27216285 <a title="107-lsi-15" href="./nips-2000-Beyond_Maximum_Likelihood_and_Density_Estimation%3A_A_Sample-Based_Criterion_for_Unsupervised_Learning_of_Complex_Models.html">31 nips-2000-Beyond Maximum Likelihood and Density Estimation: A Sample-Based Criterion for Unsupervised Learning of Complex Models</a></p>
<p>16 0.27044624 <a title="107-lsi-16" href="./nips-2000-Improved_Output_Coding_for_Classification_Using_Continuous_Relaxation.html">68 nips-2000-Improved Output Coding for Classification Using Continuous Relaxation</a></p>
<p>17 0.26867324 <a title="107-lsi-17" href="./nips-2000-Shape_Context%3A_A_New_Descriptor_for_Shape_Matching_and_Object_Recognition.html">117 nips-2000-Shape Context: A New Descriptor for Shape Matching and Object Recognition</a></p>
<p>18 0.26412404 <a title="107-lsi-18" href="./nips-2000-Color_Opponency_Constitutes_a_Sparse_Representation_for_the_Chromatic_Structure_of_Natural_Scenes.html">32 nips-2000-Color Opponency Constitutes a Sparse Representation for the Chromatic Structure of Natural Scenes</a></p>
<p>19 0.25950685 <a title="107-lsi-19" href="./nips-2000-High-temperature_Expansions_for_Learning_Models_of_Nonnegative_Data.html">64 nips-2000-High-temperature Expansions for Learning Models of Nonnegative Data</a></p>
<p>20 0.25851306 <a title="107-lsi-20" href="./nips-2000-One_Microphone_Source_Separation.html">96 nips-2000-One Microphone Source Separation</a></p>
<br/>
<h2>similar papers computed by <a title="lda-model" href="../home/nips2000_lda.html">lda model</a></h2><h3>lda for this paper:</h3><p>topicId topicWeight</p>
<p>[(10, 0.024), (17, 0.175), (32, 0.025), (33, 0.05), (36, 0.024), (38, 0.014), (46, 0.222), (52, 0.072), (55, 0.041), (62, 0.033), (65, 0.026), (67, 0.057), (75, 0.019), (76, 0.031), (79, 0.01), (81, 0.036), (90, 0.034), (91, 0.022), (97, 0.012)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 0.8390817 <a title="107-lda-1" href="./nips-2000-Rate-coded_Restricted_Boltzmann_Machines_for_Face_Recognition.html">107 nips-2000-Rate-coded Restricted Boltzmann Machines for Face Recognition</a></p>
<p>Author: Yee Whye Teh, Geoffrey E. Hinton</p><p>Abstract: We describe a neurally-inspired, unsupervised learning algorithm that builds a non-linear generative model for pairs of face images from the same individual. Individuals are then recognized by finding the highest relative probability pair among all pairs that consist of a test image and an image whose identity is known. Our method compares favorably with other methods in the literature. The generative model consists of a single layer of rate-coded, non-linear feature detectors and it has the property that, given a data vector, the true posterior probability distribution over the feature detector activities can be inferred rapidly without iteration or approximation. The weights of the feature detectors are learned by comparing the correlations of pixel intensities and feature activations in two phases: When the network is observing real data and when it is observing reconstructions of real data generated from the feature activations.</p><p>2 0.64358497 <a title="107-lda-2" href="./nips-2000-Recognizing_Hand-written_Digits_Using_Hierarchical_Products_of_Experts.html">108 nips-2000-Recognizing Hand-written Digits Using Hierarchical Products of Experts</a></p>
<p>Author: Guy Mayraz, Geoffrey E. Hinton</p><p>Abstract: The product of experts learning procedure [1] can discover a set of stochastic binary features that constitute a non-linear generative model of handwritten images of digits. The quality of generative models learned in this way can be assessed by learning a separate model for each class of digit and then comparing the unnormalized probabilities of test images under the 10 different class-specific models. To improve discriminative performance, it is helpful to learn a hierarchy of separate models for each digit class. Each model in the hierarchy has one layer of hidden units and the nth level model is trained on data that consists of the activities of the hidden units in the already trained (n - l)th level model. After training, each level produces a separate, unnormalized log probabilty score. With a three-level hierarchy for each of the 10 digit classes, a test image produces 30 scores which can be used as inputs to a supervised, logistic classification network that is trained on separate data. On the MNIST database, our system is comparable with current state-of-the-art discriminative methods, demonstrating that the product of experts learning procedure can produce effective generative models of high-dimensional data. 1 Learning products of stochastic binary experts Hinton [1] describes a learning algorithm for probabilistic generative models that are composed of a number of experts. Each expert specifies a probability distribution over the visible variables and the experts are combined by multiplying these distributions together and renormalizing. (1) where d is a data vector in a discrete space, Om is all the parameters of individual model m, Pm(dIOm) is the probability of d under model m, and c is an index over all possible vectors in the data space. A Restricted Boltzmann machine [2, 3] is a special case of a product of experts in which each expert is a single, binary stochastic hidden unit that has symmetrical connections to a set of visible units, and connections between the hidden units are forbidden. Inference in an RBM is much easier than in a general Boltzmann machine and it is also much easier than in a causal belief net because there is no explaining away. There is therefore no need to perform any iteration to determine the activities of the hidden units. The hidden states, Sj , are conditionally independent given the visible states, Si, and the distribution of Sj is given by the standard logistic function : 1 p(Sj = 1) = (2) 1 + exp( - Li WijSi) Conversely, the hidden states of an RBM are marginally dependent so it is easy for an RBM to learn population codes in which units may be highly correlated. It is hard to do this in causal belief nets with one hidden layer because the generative model of a causal belief net assumes marginal independence. An RBM can be trained using the standard Boltzmann machine learning algorithm which follows a noisy but unbiased estimate of the gradient of the log likelihood of the data. One way to implement this algorithm is to start the network with a data vector on the visible units and then to alternate between updating all of the hidden units in parallel and updating all of the visible units in parallel. Each update picks a binary state for a unit from its posterior distribution given the current states of all the units in the other set. If this alternating Gibbs sampling is run to equilibrium, there is a very simple way to update the weights so as to minimize the Kullback-Leibler divergence, QOIIQoo, between the data distribution, QO, and the equilibrium distribution of fantasies over the visible units, Qoo, produced by the RBM [4]: flWij oc QO - Q~ (3) where < SiSj >Qo is the expected value of SiSj when data is clamped on the visible units and the hidden states are sampled from their conditional distribution given the data, and Q ~ is the expected value of SiSj after prolonged Gibbs sampling. This learning rule does not work well because it can take a long time to approach thermal equilibrium and the sampling noise in the estimate of  Q ~ can swamp the gradient. [1] shows that it is far more effective to minimize the difference between QOllQoo and Q111Qoo where Q1 is the distribution of the one-step reconstructions of the data that are produced by first picking binary hidden states from their conditional distribution given the data and then picking binary visible states from their conditional distribution given the hidden states. The exact gradient of this</p><p>3 0.63364726 <a title="107-lda-3" href="./nips-2000-A_Comparison_of_Image_Processing_Techniques_for_Visual_Speech_Recognition_Applications.html">2 nips-2000-A Comparison of Image Processing Techniques for Visual Speech Recognition Applications</a></p>
<p>Author: Michael S. Gray, Terrence J. Sejnowski, Javier R. Movellan</p><p>Abstract: We examine eight different techniques for developing visual representations in machine vision tasks. In particular we compare different versions of principal component and independent component analysis in combination with stepwise regression methods for variable selection. We found that local methods, based on the statistics of image patches, consistently outperformed global methods based on the statistics of entire images. This result is consistent with previous work on emotion and facial expression recognition. In addition, the use of a stepwise regression technique for selecting variables and regions of interest substantially boosted performance. 1</p><p>4 0.62451118 <a title="107-lda-4" href="./nips-2000-Text_Classification_using_String_Kernels.html">130 nips-2000-Text Classification using String Kernels</a></p>
<p>Author: Huma Lodhi, John Shawe-Taylor, Nello Cristianini, Christopher J. C. H. Watkins</p><p>Abstract: We introduce a novel kernel for comparing two text documents. The kernel is an inner product in the feature space consisting of all subsequences of length k. A subsequence is any ordered sequence of k characters occurring in the text though not necessarily contiguously. The subsequences are weighted by an exponentially decaying factor of their full length in the text, hence emphasising those occurrences which are close to contiguous. A direct computation of this feature vector would involve a prohibitive amount of computation even for modest values of k, since the dimension of the feature space grows exponentially with k. The paper describes how despite this fact the inner product can be efficiently evaluated by a dynamic programming technique. A preliminary experimental comparison of the performance of the kernel compared with a standard word feature space kernel [6] is made showing encouraging results. 1</p><p>5 0.62171578 <a title="107-lda-5" href="./nips-2000-Kernel_Expansions_with_Unlabeled_Examples.html">74 nips-2000-Kernel Expansions with Unlabeled Examples</a></p>
<p>Author: Martin Szummer, Tommi Jaakkola</p><p>Abstract: Modern classification applications necessitate supplementing the few available labeled examples with unlabeled examples to improve classification performance. We present a new tractable algorithm for exploiting unlabeled examples in discriminative classification. This is achieved essentially by expanding the input vectors into longer feature vectors via both labeled and unlabeled examples. The resulting classification method can be interpreted as a discriminative kernel density estimate and is readily trained via the EM algorithm, which in this case is both discriminative and achieves the optimal solution. We provide, in addition, a purely discriminative formulation of the estimation problem by appealing to the maximum entropy framework. We demonstrate that the proposed approach requires very few labeled examples for high classification accuracy.</p><p>6 0.62066346 <a title="107-lda-6" href="./nips-2000-Learning_Segmentation_by_Random_Walks.html">79 nips-2000-Learning Segmentation by Random Walks</a></p>
<p>7 0.61728311 <a title="107-lda-7" href="./nips-2000-Color_Opponency_Constitutes_a_Sparse_Representation_for_the_Chromatic_Structure_of_Natural_Scenes.html">32 nips-2000-Color Opponency Constitutes a Sparse Representation for the Chromatic Structure of Natural Scenes</a></p>
<p>8 0.61709011 <a title="107-lda-8" href="./nips-2000-A_Linear_Programming_Approach_to_Novelty_Detection.html">4 nips-2000-A Linear Programming Approach to Novelty Detection</a></p>
<p>9 0.61481774 <a title="107-lda-9" href="./nips-2000-Foundations_for_a_Circuit_Complexity_Theory_of_Sensory_Processing.html">56 nips-2000-Foundations for a Circuit Complexity Theory of Sensory Processing</a></p>
<p>10 0.61407089 <a title="107-lda-10" href="./nips-2000-Sparse_Representation_for_Gaussian_Process_Models.html">122 nips-2000-Sparse Representation for Gaussian Process Models</a></p>
<p>11 0.60994011 <a title="107-lda-11" href="./nips-2000-The_Kernel_Gibbs_Sampler.html">133 nips-2000-The Kernel Gibbs Sampler</a></p>
<p>12 0.60978723 <a title="107-lda-12" href="./nips-2000-Convergence_of_Large_Margin_Separable_Linear_Classification.html">37 nips-2000-Convergence of Large Margin Separable Linear Classification</a></p>
<p>13 0.60848689 <a title="107-lda-13" href="./nips-2000-The_Manhattan_World_Assumption%3A_Regularities_in_Scene_Statistics_which_Enable_Bayesian_Inference.html">135 nips-2000-The Manhattan World Assumption: Regularities in Scene Statistics which Enable Bayesian Inference</a></p>
<p>14 0.60685444 <a title="107-lda-14" href="./nips-2000-Gaussianization.html">60 nips-2000-Gaussianization</a></p>
<p>15 0.60071635 <a title="107-lda-15" href="./nips-2000-Constrained_Independent_Component_Analysis.html">36 nips-2000-Constrained Independent Component Analysis</a></p>
<p>16 0.60028982 <a title="107-lda-16" href="./nips-2000-Propagation_Algorithms_for_Variational_Bayesian_Learning.html">106 nips-2000-Propagation Algorithms for Variational Bayesian Learning</a></p>
<p>17 0.59963411 <a title="107-lda-17" href="./nips-2000-Partially_Observable_SDE_Models_for_Image_Sequence_Recognition_Tasks.html">98 nips-2000-Partially Observable SDE Models for Image Sequence Recognition Tasks</a></p>
<p>18 0.59906906 <a title="107-lda-18" href="./nips-2000-Regularized_Winnow_Methods.html">111 nips-2000-Regularized Winnow Methods</a></p>
<p>19 0.59850007 <a title="107-lda-19" href="./nips-2000-A_Productive%2C_Systematic_Framework_for_the_Representation_of_Visual_Structure.html">10 nips-2000-A Productive, Systematic Framework for the Representation of Visual Structure</a></p>
<p>20 0.59746158 <a title="107-lda-20" href="./nips-2000-On_a_Connection_between_Kernel_PCA_and_Metric_Multidimensional_Scaling.html">95 nips-2000-On a Connection between Kernel PCA and Metric Multidimensional Scaling</a></p>
<br/><br/><br/>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-48522588-1', 'makerhacker.github.io');
ga('send', 'pageview');
</script>

</body>
</html>
