<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>42 nips-2002-Bias-Optimal Incremental Problem Solving</title>
</head>

<body>
<p><a title="nips" href="../nips_home.html">nips</a> <a title="nips-2002" href="../home/nips2002_home.html">nips2002</a> <a title="nips-2002-42" href="../nips2002/nips-2002-Bias-Optimal_Incremental_Problem_Solving.html">nips2002-42</a> <a title="nips-2002-42-reference" href="#">nips2002-42-reference</a> knowledge-graph by maker-knowledge-mining</p><h1>42 nips-2002-Bias-Optimal Incremental Problem Solving</h1>
<br/><p>Source: <a title="nips-2002-42-pdf" href="http://papers.nips.cc/paper/2299-bias-optimal-incremental-problem-solving.pdf">pdf</a></p><p>Author: Jürgen Schmidhuber</p><p>Abstract: Given is a problem sequence and a probability distribution (the bias) on programs computing solution candidates. We present an optimally fast way of incrementally solving each task in the sequence. Bias shifts are computed by program preﬁxes that modify the distribution on their sufﬁxes by reusing successful code for previous tasks (stored in non-modiﬁable memory). No tested program gets more runtime than its probability times the total search time. In illustrative experiments, ours becomes the ﬁrst general system to learn a universal solver for arbitrary disk Towers of Hanoi tasks (minimal solution size ). It demonstrates the advantages of incremental learning by proﬁting from previously solved, simpler tasks involving samples of a simple context free language.   ¦ ¤ ¢ §¥£¡ 1 Brief Introduction to Optimal Universal Search Consider an asymptotically optimal method for tasks with quickly veriﬁable solutions: ¦ ¦  ©  £ £¨ © © ©  © ¦ ¦ ¦   Method 1.1 (L SEARCH ) View the -th binary string as a potential program for a universal Turing machine. Given some problem, for all do: every steps on average execute (if possible) one instruction of the -th program candidate, until one of the programs has computed a solution.   !     © © © ¢</p><br/>
<h2>reference text</h2><p>[1] C. W. Anderson. Learning and Problem Solving with Multilayer Connectionist Systems. PhD thesis, University of Massachusetts, Dept. of Comp. and Inf. Sci., 1986.</p>
<p>[2] N. L. Cramer. A representation for the adaptive generation of simple sequential programs. In J.J. Grefenstette, editor, Proceedings of an International Conference on Genetic Algorithms and Their Applications, Carnegie-Mellon University, July 24-26, 1985, Hillsdale NJ, 1985. Lawrence Erlbaum Associates.</p>
<p>[3] M. Hutter. The fastest and shortest algorithm for all well-deﬁned problems. International Journal of Foundations of Computer Science, 13(3):431–443, 2002.</p>
<p>[4] L.P. Kaelbling, M.L. Littman, and A.W. Moore. Reinforcement learning: a survey. Journal of AI research, 4:237–285, 1996.</p>
<p>[5] P. Langley. Learning to search: from weak methods to domain-speciﬁc heuristics. Cognitive Science, 9:217–260, 1985.</p>
<p>[6] L. A. Levin. Universal sequential search problems. Problems of Information Transmission, 9(3):265–266, 1973.</p>
<p>[7] M. Li and P. M. B. Vit´ nyi. An Introduction to Kolmogorov Complexity and its Applications a (2nd edition). Springer, 1997.</p>
<p>[8] C. H. Moore and G. C. Leach. FORTH - a language for interactive computing, 1970. http://www.ultratechnology.com.</p>
<p>[9] J. Schmidhuber. Optimal ordered problem solver. Technical Report IDSIA-12-02, arXiv:cs.AI/0207097 v1, IDSIA, Manno-Lugano, Switzerland, July 2002.</p>
<p>[10] J. Schmidhuber, J. Zhao, and M. Wiering. Shifting inductive bias with success-story algorithm, adaptive Levin search, and incremental self-improvement. Machine Learning, 28:105–130, 1997.</p>
<p>[11] R.J. Solomonoff. An application of algorithmic probability to problems in artiﬁcial intelligence. In L. N. Kanal and J. F. Lemmer, editors, Uncertainty in Artiﬁcial Intelligence, pages 473–491. Elsevier Science Publishers, 1986.</p>
<br/>
<br/><br/><br/>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-48522588-1', 'makerhacker.github.io');
ga('send', 'pageview');
</script>

</body>
</html>
