<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>13 iccv-2013-A General Two-Step Approach to Learning-Based Hashing</title>
</head>

<body>
<p><a title="iccv" href="../iccv_home.html">iccv</a> <a title="iccv-2013" href="../home/iccv2013_home.html">iccv2013</a> <a title="iccv-2013-13" href="#">iccv2013-13</a> knowledge-graph by maker-knowledge-mining</p><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- maker adsense -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-5027806277543591"
     data-ad-slot="4192012269"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>13 iccv-2013-A General Two-Step Approach to Learning-Based Hashing</h1>
<br/><p>Source: <a title="iccv-2013-13-pdf" href="http://www.cv-foundation.org/openaccess/content_iccv_2013/papers/Lin_A_General_Two-Step_2013_ICCV_paper.pdf">pdf</a></p><p>Author: Guosheng Lin, Chunhua Shen, David Suter, Anton van_den_Hengel</p><p>Abstract: Most existing approaches to hashing apply a single form of hash function, and an optimization process which is typically deeply coupled to this specific form. This tight coupling restricts the flexibility of the method to respond to the data, and can result in complex optimization problems that are difficult to solve. Here we propose a flexible yet simple framework that is able to accommodate different types of loss functions and hash functions. This framework allows a number of existing approaches to hashing to be placed in context, and simplifies the development of new problemspecific hashing methods. Our framework decomposes the hashing learning problem into two steps: hash bit learning and hash function learning based on the learned bits. The first step can typically be formulated as binary quadratic problems, and the second step can be accomplished by training standard binary classifiers. Both problems have been extensively studied in the literature. Our extensive experiments demonstrate that the proposed framework is effective, flexible and outperforms the state-of-the-art.</p><p>Reference: <a title="iccv-2013-13-reference" href="../iccv2013_reference/iccv-2013-A_General_Two-Step_Approach_to_Learning-Based_Hashing_reference.html">text</a></p><br/><h2>Summary: the most important sentenses genereted by tfidf model</h2><p>sentIndex sentText sentNum sentScore</p><p>1 Here we propose a flexible yet simple framework that is able to accommodate different types of loss functions and hash functions. [sent-3, score-1.048]
</p><p>2 This framework allows a number of existing approaches to hashing to be placed in context, and simplifies the development of new problemspecific hashing methods. [sent-4, score-0.881]
</p><p>3 Our framework decomposes the hashing learning problem into two steps: hash bit learning and hash function learning based on the learned bits. [sent-5, score-1.806]
</p><p>4 The first step can typically be formulated as binary quadratic problems, and the second step can be accomplished by training standard binary classifiers. [sent-6, score-0.291]
</p><p>5 Introduction  Recently hashing methods have been widely used for a variety of applications, but have been particularly successful when applied to approximate nearest neighbor search. [sent-10, score-0.42]
</p><p>6 Hashing methods construct a set of hash functions that map the original high-dimensional data into a compact binary space. [sent-11, score-0.872]
</p><p>7 The resulting binary codes enable fast similarity search on the basis ofthe Hamming distance between codes. [sent-12, score-0.321]
</p><p>8 In general, hash functions are generated with the aim of preserving some notion of similarity between data points. [sent-15, score-0.775]
</p><p>9 One of the seminal approaches in this vein is locality-sensitive hashing (LSH) [2], which randomly generates hash functions to approximate cosine similarity. [sent-16, score-1.173]
</p><p>10 In this category, a number of methods have been proposed, for example: spectral hashing (SPH) [15], multi-dimension spectral hashing (MDSH) [14], iterative quantization (ITQ) [3] and inductive manifold hashing [11]. [sent-22, score-1.414]
</p><p>11 These methods do not rely on labeled data and are thus categorized as unsupervised hashing methods. [sent-23, score-0.462]
</p><p>12 Recent works include supervised hashing with ker-  nels (KSH) [8], minimal loss hashing (MLH) [10], supervised binary reconstructive embeddings (BRE) [5], semisupervised sequential projection learning hashing (SPLH) [13] and column generation hashing [7], etc. [sent-25, score-2.251]
</p><p>13 Loss functions for hashing are typically defined on the basis of the Hamming distance or Hamming affinity of similar and dissimilar data pairs. [sent-26, score-0.786]
</p><p>14 Hamming affinity is calculated by the inner product of two binary codes (a binary code takes a value of {−1, 1}). [sent-27, score-0.606]
</p><p>15 Existing methods thus tend to optimize a single form of hash functions, the parameters of which are directly optimized against the overall loss function. [sent-28, score-0.832]
</p><p>16 The common forms of hash functions are linear perceptron functions (MLH, SPLH, LSH), kernel functions (KSH), eigenfunctions (SPH, MDSH). [sent-29, score-1.199]
</p><p>17 The optimization procedure is then coupled with the selected family of hash function. [sent-30, score-0.673]
</p><p>18 Different types of hash functions offer a trade-off between testing time and ranking accuracy. [sent-31, score-0.81]
</p><p>19 As an example, the loss functions in MDSH, KSH and BRE all take a similar form that aims to minimize the difference between the Hamming affinity (or distance) and the ground truth of data pairs. [sent-34, score-0.548]
</p><p>20 However, the optimization procedures used in these methods are coupled with the form of hash functions (eigenfunctions, kernel functions) and thus  different optimization techniques are needed. [sent-35, score-0.911]
</p><p>21 Self-Taught Hashing (STH) [16] is a method which decomposes the learning procedure into two steps: binary code generating and hash function learning. [sent-36, score-0.85]
</p><p>22 We extend this idea and propose a general two-step approach to hashing of which STH can be seen as a specific example. [sent-37, score-0.42]
</p><p>23 Our framework, however, is able to accommodate many different loss functions defined on the Hamming affinity of data pairs, such as the loss function used in KSH, BRE or MLH. [sent-39, score-0.818]
</p><p>24 This more general family of loss functions may consider both similar and dissimilar data pairs. [sent-40, score-0.402]
</p><p>25 In order to produce effective binary codes in this first step, we develop a new technique based on coordinate descent. [sent-41, score-0.312]
</p><p>26 We show that at each iteration of coordinate descent, we can formulate the optimization problem of any Hamming affinity loss as a binary quadratic problem. [sent-42, score-0.66]
</p><p>27 This formulation unifies different types of objective functions into the same optimization problem, which significantly simplifies the optimization effort. [sent-43, score-0.288]
</p><p>28 (1) We propose a flexible hashing framework that decomposes the learning procedure into two steps: binary codes inference step and hash function learning step. [sent-45, score-1.411]
</p><p>29 This decom-  position simplifies the problem and enables the use of different types of loss functions and simplifies the hash function learning problem into a standard binary classification problem. [sent-46, score-1.248]
</p><p>30 An arbitrary classifier, such as linear or kernel support vector machines (SVM), boosting, neural networks, may thus be adopted to train the hash functions. [sent-47, score-0.666]
</p><p>31 (2) For binary code inference, we show that optimization using different types of loss functions (e. [sent-48, score-0.603]
</p><p>32 , loss functions in KSH, BRE, MLH) can be solved as a series of binary quadratic problems. [sent-50, score-0.539]
</p><p>33 2 loss, exponential loss, hinge loss) defined on Hamming affinity of data pairs can be equivalently converted into a standard quadratic function. [sent-54, score-0.328]
</p><p>34 Based on this key observation, we propose a general block coordinate decent method that is able to incorporate many different types of loss functions in a unified manner. [sent-55, score-0.529]
</p><p>35 To show the flexibility, we evaluate our method using different types of loss functions and different formats of hash functions (linear SVM, kernel SVM, Adaboost with decision stumps, etc). [sent-58, score-1.206]
</p><p>36 xn} ⊂ Rd, the goal of hashing is to learn a set of hash functions that are able to preserve some notion of similarity between data  points. [sent-64, score-1.218]
</p><p>37 In this case yij is the (i, j)-th element of the matrix Y, which is an affinity value of the data pair (xi, xj). [sent-66, score-0.342]
</p><p>38 In the case of unsupervised learning, yij can be defined as the Euclidean distance or Gaussian affinity on data points. [sent-68, score-0.391]
</p><p>39 Φ(·) is a set of m hash functions: Φ(·) = [h1(·) , h2 (·) , . [sent-69, score-0.609]
</p><p>40 The output of the hash functions are m-bit binary codes: Φ(x) ∈ {−1, 1}m. [sent-73, score-0.872]
</p><p>41 (1)  Here δij ∈ {0, 1} indicates whether the relation between two data points is defined, and L(Φ(xi) , Φ(xj) ; yij) is a loss function that measures the how well the binary codes match the expected affinity (or distance) yij . [sent-77, score-0.844]
</p><p>42 Many different types of loss functions L(·) have been devised, and will be discussed in detail in the next section. [sent-78, score-0.396]
</p><p>43 Most existing methods try to directly optimize objective (1) in order to learn the parameters of hash functions [5, 8, 10, 14]. [sent-79, score-0.753]
</p><p>44 This inevitably means that the optimization process is tightly coupled to the form of hash functions used, which makes it non-trivial to extend a method to use another different format of hash functions. [sent-80, score-1.426]
</p><p>45 Following the idea of STH [16], we decompose the learning procedure into two steps: the first step for binary code inference and the second step for hash function learning. [sent-82, score-0.839]
</p><p>46 : Z ∈ {−1,1}m×n,  (2)  where Z is the matrix of m-bit binary codes for all data points, and zi is the binary code vector corresponding to i-th data point. [sent-87, score-0.52]
</p><p>47 The second step is to learn hash functions based on the binary codes obtained in the first step, which is achieved by solving the optimization problem: n  mΦ(i·n)i? [sent-88, score-1.064]
</p><p>48 To learn the k-th hash function hk (·), the optimization can be written: n  mhk(i·n)i? [sent-92, score-0.669]
</p><p>49 (·, ·) is an loss function defined on two codes; zi,k is the binary code corresponding to the i-th data point and the k-th bit. [sent-96, score-0.416]
</p><p>50 Clearly, the above optimization is a binary classification problem which is to minimize a kind of loss given the binary labels. [sent-97, score-0.498]
</p><p>51 As in classification, one  22555533  Algorithm 1Block coordinate decent for learning binary codes (Step-1) 1: Input: affinity matrix Y, bit length m, number of cyclic iteration r. [sent-100, score-0.701]
</p><p>52 , m 5: Solve the binary quadratic problem (BQP) in (13) to obtain the binary codes of t-th bit. [sent-105, score-0.446]
</p><p>53 6: Update the codes of the t-th bit in the code matrix Z. [sent-106, score-0.283]
</p><p>54 9: Output: the matrix of binary codes Z can also use a convex surrogate to replace the zero-one loss. [sent-108, score-0.314]
</p><p>55 Typical surrogate loss functions are hinge loss, logistic loss, etc. [sent-109, score-0.417]
</p><p>56 The resulting classifier is the hash function that we aim to learn. [sent-110, score-0.632]
</p><p>57 For example, we can learn perceptron hash functions by training a linear SVM. [sent-112, score-0.825]
</p><p>58 The linear perceptron hash function has the form:  (w? [sent-113, score-0.704]
</p><p>59 (5) We could also train, for example, an RBF-kernel SVM, or Adaboost as hash functions. [sent-115, score-0.609]
</p><p>60 Here we describe a kernel hash function that is learned using a linear SVM on kernel-transferred features (referred to as SVM-KF). [sent-116, score-0.689]
</p><p>61 The hash function learned by SVM-KF has a form as follows:  h(x) = sign ? [sent-117, score-0.632]
</p><p>62 We evaluate variety of different kinds of hash function in the Experiments Section below. [sent-128, score-0.632]
</p><p>63 These tests show that Kernel hash functions often offer better ranking precision but require much more evaluation time than linear perceptron hash functions. [sent-129, score-1.434]
</p><p>64 The hash functions learned by SVMKF represents a trade-off between kernel SVM and linear SVM. [sent-130, score-0.81]
</p><p>65 The method proposed here is labeled Two-Step Hashing (TSH), the steps are as follows: •  •  Step-1 : Solving the optimization problem in (2) using block coordinate decent (Algorithm 1) to obtain binary codes for each training data point. [sent-131, score-0.439]
</p><p>66 Step-2: Solving the binary classification problem in (4) for each bit based on the binary codes obtained at Step-1 . [sent-132, score-0.452]
</p><p>67 Solving binary quadratic problems Optimizing (2) in Step-1 for the entire binary code matrix can be difficult. [sent-134, score-0.36]
</p><p>68 Moreover, we show that at each iteration, any pairwise Hamming affinity (or distance) based loss can be equivalently formulated as a binary quadratic  problem. [sent-136, score-0.588]
</p><p>69 z(k)∈ {−1,1}n,  (7)  where lk is the loss function defined on the k-th bit: lk (zi,k , zj,k) = L(zi,k , zj,k , z¯ i , z¯ j ; yij ) . [sent-144, score-0.49]
</p><p>70 Based on the following proposition, we are able to rewrite any Hamming affinity (or distance) based loss function L(·) into a standard quadratic problem. [sent-150, score-0.484]
</p><p>71 For any loss function l(z1, z2) that is defined on a pair of binary input variables z1, z2 ∈ {− 1, 1} and l(1, 1) = l(− 1, 1) , l(1, 1) = l(1, 1), we can define a quadratic function g(z1, z2) that is equal to l(z1, z2). [sent-152, score-0.441]
</p><p>72 (9)  (10) Here l(11), l(−11) are constants, l(11) is the loss output on identical input pair: l(11) = l(1, 1), and l(−11) is the loss output on distinct input pair: l(−11) = l(−1, 1). [sent-157, score-0.446]
</p><p>73 Any hash loss function l(·, ·) which is defined on the Hamming affinity between, or Hamming distance of, data −  −  22555544  pairs is able to meet the requirement that: l(1, 1) = l(−1, −1) , l(1, −1) = l(1, −1). [sent-167, score-1.082]
</p><p>74 Here we describe a selection of such loss functions, most of which arise from recently proposed hashing methods. [sent-197, score-0.643]
</p><p>75 We evaluate these loss functions in the Experiments Section below. [sent-198, score-0.367]
</p><p>76 If not specified, yij = 1if the data pair is similar, and yij = −1 if the data pair is dissimilar. [sent-200, score-0.324]
</p><p>77 TSH-KSH The KSH loss function is based on Hamming affinity using ? [sent-202, score-0.408]
</p><p>78 MDSH also uses a similar form of loss function (weighted Hamming affinity instead): LKSH(zi, zj) = (z? [sent-204, score-0.408]
</p><p>79 (17) Table 2: Training time (in seconds) for TSH using different loss functions, and several other supervised methods on 3 datasets. [sent-208, score-0.297]
</p><p>80 Note that the second step of learning the hash functions can be easily parallelised. [sent-211, score-0.772]
</p><p>81 Here d¯ is the average Euclidean distance of top 100 nearing neighbours and t is 22555555  Table 1: Results (using hash codes of 32 bits) of TSH using different loss functions, and a selection of other supervised and unsupervised methods on 3 datasets. [sent-228, score-1.128]
</p><p>82 The results show that Step-1 of our method is able to generate effective binary codes that outperforms those of competing methods on the training data. [sent-230, score-0.297]
</p><p>83 If not specified, our method TSH use SVM with RBF kernel as hash functions. [sent-243, score-0.666]
</p><p>84 Following the same setting as other hash methods [8, 13], we generate pseudo-labels for supervised methods according to the ? [sent-253, score-0.683]
</p><p>85 In detail, a data point is labelled as  a relevant neighbour to the query if it lies in the top 2 perlowing a common setting in many supervised hashing methods [5, 8, 10], we randomly select 2000 examples as testing queries, and the rest is served as database. [sent-255, score-0.522]
</p><p>86 Using different loss functions We evaluate the performance of our method TSH using different loss functions on 3 datasets: LabelMe, MNIST, CIFAR10. [sent-260, score-0.734]
</p><p>87 STHs-RBF is the STHs method using RBF kernel hash functions. [sent-264, score-0.666]
</p><p>88 Our method also uses SVM with RBF kernel as hash functions. [sent-265, score-0.666]
</p><p>89 This demonstrates the effectiveness of coordinate descent based hashing codes learning procedure (Step 1of our framework). [sent-275, score-0.632]
</p><p>90 Compared to STHs-RBF, even though we are using the same formate of hash function, our overall objective function and the bit-wise binary code inference algorithm may be more effective. [sent-276, score-0.82]
</p><p>91 Notice that in the second step, learning hash functions by binary classification can be easily paralleled which would make our method even more efficient. [sent-296, score-0.891]
</p><p>92 (satD−minoserpCb120864 08BinaryT S coH d−eRKLS16FtleBuVmnMgpth(enum24brofits)32  Figure 5: Code compression time using different hash functions. [sent-299, score-0.609]
</p><p>93 Using different hash functions We evaluate our method using different hash functions. [sent-304, score-1.362]
</p><p>94 The hash functions are SVM with RBF kernel (TSH-RBF), linear SVM with kernel transferred feature (TSH-KF), linear SVM (TSH-LSVM), Adaboost with decision-stump (TSH-Stump, 2000 iterations). [sent-305, score-0.886]
</p><p>95 The testing time for different hash functions are shown in Fig. [sent-308, score-0.781]
</p><p>96 It shows that the kernel hash functions (TSH-RBF and TSH-KF) achieve best performance in similarity search. [sent-310, score-0.832]
</p><p>97 However, the testing of linear hash functions is much faster than kernel hash functions. [sent-311, score-1.447]
</p><p>98 Conclusion We have shown that it is possible to place a wide variety of learning-based hashing methods into a unified framework, and that doing so provides insights into the strengths, weaknesses, and commonality between various competing methods. [sent-327, score-0.42]
</p><p>99 One of the key insights is the fact that the code generation and hash function learning processes may be seen as separate steps, and that the latter may accurately be formulated as a classification problem. [sent-328, score-0.702]
</p><p>100 Iterative quantization: a procrustean approach to learning binary codes for large-scale image retrieval. [sent-356, score-0.293]
</p>
<br/>
<h2>similar papers computed by tfidf model</h2><h3>tfidf for this paper:</h3><p>wordName wordTfidf (topN-words)</p>
<p>[('hash', 0.609), ('hashing', 0.42), ('ksh', 0.225), ('loss', 0.223), ('hamming', 0.176), ('yij', 0.162), ('affinity', 0.162), ('codes', 0.155), ('functions', 0.144), ('mdsh', 0.137), ('binary', 0.119), ('bre', 0.111), ('mlh', 0.098), ('tsh', 0.088), ('splh', 0.087), ('supervised', 0.074), ('perceptron', 0.072), ('lableme', 0.069), ('zj', 0.062), ('rbf', 0.061), ('bit', 0.059), ('bqp', 0.059), ('zi', 0.058), ('kernel', 0.057), ('cyclic', 0.053), ('quadratic', 0.053), ('spectral', 0.051), ('code', 0.051), ('decent', 0.05), ('mnist', 0.05), ('mz', 0.048), ('itq', 0.045), ('sph', 0.045), ('svm', 0.043), ('az', 0.043), ('unsupervised', 0.042), ('lk', 0.041), ('simplifies', 0.041), ('hengel', 0.04), ('labelme', 0.04), ('dh', 0.04), ('proposition', 0.039), ('bres', 0.039), ('izj', 0.039), ('spher', 0.039), ('sths', 0.039), ('relaxation', 0.038), ('shen', 0.038), ('coordinate', 0.038), ('reconstructive', 0.038), ('exponential', 0.037), ('optimization', 0.037), ('kin', 0.037), ('sth', 0.036), ('dissimilar', 0.035), ('lsh', 0.033), ('ijl', 0.032), ('klsh', 0.032), ('equivalently', 0.031), ('den', 0.03), ('adaboost', 0.03), ('decomposes', 0.029), ('types', 0.029), ('eigenfunctions', 0.029), ('testing', 0.028), ('tiny', 0.028), ('bits', 0.028), ('coupling', 0.028), ('hinge', 0.028), ('iteration', 0.028), ('coupled', 0.027), ('quantization', 0.026), ('inductive', 0.026), ('distance', 0.025), ('embeddings', 0.024), ('able', 0.023), ('function', 0.023), ('picked', 0.023), ('similarity', 0.022), ('surrogate', 0.022), ('reformulated', 0.022), ('block', 0.022), ('datasets', 0.021), ('retrieved', 0.021), ('kernelized', 0.021), ('accommodate', 0.02), ('elastic', 0.02), ('written', 0.019), ('transferred', 0.019), ('truth', 0.019), ('learning', 0.019), ('embedding', 0.019), ('spherical', 0.019), ('par', 0.019), ('inference', 0.018), ('steps', 0.018), ('matrix', 0.018), ('kulis', 0.018), ('pairs', 0.017), ('agh', 0.017)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 1.0000001 <a title="13-tfidf-1" href="./iccv-2013-A_General_Two-Step_Approach_to_Learning-Based_Hashing.html">13 iccv-2013-A General Two-Step Approach to Learning-Based Hashing</a></p>
<p>Author: Guosheng Lin, Chunhua Shen, David Suter, Anton van_den_Hengel</p><p>Abstract: Most existing approaches to hashing apply a single form of hash function, and an optimization process which is typically deeply coupled to this specific form. This tight coupling restricts the flexibility of the method to respond to the data, and can result in complex optimization problems that are difficult to solve. Here we propose a flexible yet simple framework that is able to accommodate different types of loss functions and hash functions. This framework allows a number of existing approaches to hashing to be placed in context, and simplifies the development of new problemspecific hashing methods. Our framework decomposes the hashing learning problem into two steps: hash bit learning and hash function learning based on the learned bits. The first step can typically be formulated as binary quadratic problems, and the second step can be accomplished by training standard binary classifiers. Both problems have been extensively studied in the literature. Our extensive experiments demonstrate that the proposed framework is effective, flexible and outperforms the state-of-the-art.</p><p>2 0.65272909 <a title="13-tfidf-2" href="./iccv-2013-Large-Scale_Video_Hashing_via_Structure_Learning.html">229 iccv-2013-Large-Scale Video Hashing via Structure Learning</a></p>
<p>Author: Guangnan Ye, Dong Liu, Jun Wang, Shih-Fu Chang</p><p>Abstract: Recently, learning based hashing methods have become popular for indexing large-scale media data. Hashing methods map high-dimensional features to compact binary codes that are efficient to match and robust in preserving original similarity. However, most of the existing hashing methods treat videos as a simple aggregation of independent frames and index each video through combining the indexes of frames. The structure information of videos, e.g., discriminative local visual commonality and temporal consistency, is often neglected in the design of hash functions. In this paper, we propose a supervised method that explores the structure learning techniques to design efficient hash functions. The proposed video hashing method formulates a minimization problem over a structure-regularized empirical loss. In particular, the structure regularization exploits the common local visual patterns occurring in video frames that are associated with the same semantic class, and simultaneously preserves the temporal consistency over successive frames from the same video. We show that the minimization objective can be efficiently solved by an Acceler- ated Proximal Gradient (APG) method. Extensive experiments on two large video benchmark datasets (up to around 150K video clips with over 12 million frames) show that the proposed method significantly outperforms the state-ofthe-art hashing methods.</p><p>3 0.55869091 <a title="13-tfidf-3" href="./iccv-2013-Complementary_Projection_Hashing.html">83 iccv-2013-Complementary Projection Hashing</a></p>
<p>Author: Zhongming Jin, Yao Hu, Yue Lin, Debing Zhang, Shiding Lin, Deng Cai, Xuelong Li</p><p>Abstract: Recently, hashing techniques have been widely applied to solve the approximate nearest neighbors search problem in many vision applications. Generally, these hashing approaches generate 2c buckets, where c is the length of the hash code. A good hashing method should satisfy the following two requirements: 1) mapping the nearby data points into the same bucket or nearby (measured by xue long l i opt . ac . cn @ a(a)b(b) the Hamming distance) buckets. 2) all the data points are evenly distributed among all the buckets. In this paper, we propose a novel algorithm named Complementary Projection Hashing (CPH) to find the optimal hashing functions which explicitly considers the above two requirements. Specifically, CPHaims at sequentiallyfinding a series ofhyperplanes (hashing functions) which cross the sparse region of the data. At the same time, the data points are evenly distributed in the hypercubes generated by these hyperplanes. The experiments comparing with the state-of-the-art hashing methods demonstrate the effectiveness of the proposed method.</p><p>4 0.5420593 <a title="13-tfidf-4" href="./iccv-2013-Learning_Hash_Codes_with_Listwise_Supervision.html">239 iccv-2013-Learning Hash Codes with Listwise Supervision</a></p>
<p>Author: Jun Wang, Wei Liu, Andy X. Sun, Yu-Gang Jiang</p><p>Abstract: Hashing techniques have been intensively investigated in the design of highly efficient search engines for largescale computer vision applications. Compared with prior approximate nearest neighbor search approaches like treebased indexing, hashing-based search schemes have prominent advantages in terms of both storage and computational efficiencies. Moreover, the procedure of devising hash functions can be easily incorporated into sophisticated machine learning tools, leading to data-dependent and task-specific compact hash codes. Therefore, a number of learning paradigms, ranging from unsupervised to supervised, have been applied to compose appropriate hash functions. How- ever, most of the existing hash function learning methods either treat hash function design as a classification problem or generate binary codes to satisfy pairwise supervision, and have not yet directly optimized the search accuracy. In this paper, we propose to leverage listwise supervision into a principled hash function learning framework. In particular, the ranking information is represented by a set of rank triplets that can be used to assess the quality of ranking. Simple linear projection-based hash functions are solved efficiently through maximizing the ranking quality over the training data. We carry out experiments on large image datasets with size up to one million and compare with the state-of-the-art hashing techniques. The extensive results corroborate that our learned hash codes via listwise supervision can provide superior search accuracy without incurring heavy computational overhead.</p><p>5 0.52912039 <a title="13-tfidf-5" href="./iccv-2013-Supervised_Binary_Hash_Code_Learning_with_Jensen_Shannon_Divergence.html">409 iccv-2013-Supervised Binary Hash Code Learning with Jensen Shannon Divergence</a></p>
<p>Author: Lixin Fan</p><p>Abstract: This paper proposes to learn binary hash codes within a statistical learning framework, in which an upper bound of the probability of Bayes decision errors is derived for different forms of hash functions and a rigorous proof of the convergence of the upper bound is presented. Consequently, minimizing such an upper bound leads to consistent performance improvements of existing hash code learning algorithms, regardless of whether original algorithms are unsupervised or supervised. This paper also illustrates a fast hash coding method that exploits simple binary tests to achieve orders of magnitude improvement in coding speed as compared to projection based methods.</p><p>6 0.14182793 <a title="13-tfidf-6" href="./iccv-2013-A_Scalable_Unsupervised_Feature_Merging_Approach_to_Efficient_Dimensionality_Reduction_of_High-Dimensional_Visual_Data.html">29 iccv-2013-A Scalable Unsupervised Feature Merging Approach to Efficient Dimensionality Reduction of High-Dimensional Visual Data</a></p>
<p>7 0.14127606 <a title="13-tfidf-7" href="./iccv-2013-Stable_Hyper-pooling_and_Query_Expansion_for_Event_Detection.html">400 iccv-2013-Stable Hyper-pooling and Query Expansion for Event Detection</a></p>
<p>8 0.13912387 <a title="13-tfidf-8" href="./iccv-2013-What_is_the_Most_EfficientWay_to_Select_Nearest_Neighbor_Candidates_for_Fast_Approximate_Nearest_Neighbor_Search%3F.html">450 iccv-2013-What is the Most EfficientWay to Select Nearest Neighbor Candidates for Fast Approximate Nearest Neighbor Search?</a></p>
<p>9 0.13155113 <a title="13-tfidf-9" href="./iccv-2013-Random_Grids%3A_Fast_Approximate_Nearest_Neighbors_and_Range_Searching_for_Image_Search.html">337 iccv-2013-Random Grids: Fast Approximate Nearest Neighbors and Range Searching for Image Search</a></p>
<p>10 0.10660149 <a title="13-tfidf-10" href="./iccv-2013-Fast_Subspace_Search_via_Grassmannian_Based_Hashing.html">162 iccv-2013-Fast Subspace Search via Grassmannian Based Hashing</a></p>
<p>11 0.079349756 <a title="13-tfidf-11" href="./iccv-2013-Fast_Neighborhood_Graph_Search_Using_Cartesian_Concatenation.html">159 iccv-2013-Fast Neighborhood Graph Search Using Cartesian Concatenation</a></p>
<p>12 0.07798969 <a title="13-tfidf-12" href="./iccv-2013-Joint_Inverted_Indexing.html">221 iccv-2013-Joint Inverted Indexing</a></p>
<p>13 0.067035243 <a title="13-tfidf-13" href="./iccv-2013-Point-Based_3D_Reconstruction_of_Thin_Objects.html">319 iccv-2013-Point-Based 3D Reconstruction of Thin Objects</a></p>
<p>14 0.058890995 <a title="13-tfidf-14" href="./iccv-2013-A_Framework_for_Shape_Analysis_via_Hilbert_Space_Embedding.html">10 iccv-2013-A Framework for Shape Analysis via Hilbert Space Embedding</a></p>
<p>15 0.054079879 <a title="13-tfidf-15" href="./iccv-2013-Joint_Learning_of_Discriminative_Prototypes_and_Large_Margin_Nearest_Neighbor_Classifiers.html">222 iccv-2013-Joint Learning of Discriminative Prototypes and Large Margin Nearest Neighbor Classifiers</a></p>
<p>16 0.051162921 <a title="13-tfidf-16" href="./iccv-2013-Domain_Adaptive_Classification.html">123 iccv-2013-Domain Adaptive Classification</a></p>
<p>17 0.048003424 <a title="13-tfidf-17" href="./iccv-2013-Semi-supervised_Robust_Dictionary_Learning_via_Efficient_l-Norms_Minimization.html">384 iccv-2013-Semi-supervised Robust Dictionary Learning via Efficient l-Norms Minimization</a></p>
<p>18 0.047972836 <a title="13-tfidf-18" href="./iccv-2013-Unsupervised_Random_Forest_Manifold_Alignment_for_Lipreading.html">437 iccv-2013-Unsupervised Random Forest Manifold Alignment for Lipreading</a></p>
<p>19 0.047758441 <a title="13-tfidf-19" href="./iccv-2013-Learning_Graphs_to_Match.html">238 iccv-2013-Learning Graphs to Match</a></p>
<p>20 0.047130402 <a title="13-tfidf-20" href="./iccv-2013-Quantize_and_Conquer%3A_A_Dimensionality-Recursive_Solution_to_Clustering%2C_Vector_Quantization%2C_and_Image_Retrieval.html">333 iccv-2013-Quantize and Conquer: A Dimensionality-Recursive Solution to Clustering, Vector Quantization, and Image Retrieval</a></p>
<br/>
<h2>similar papers computed by <a title="lsi-model" href="../home/iccv2013_lsi.html">lsi model</a></h2><h3>lsi for this paper:</h3><p>topicId topicWeight</p>
<p>[(0, 0.133), (1, 0.088), (2, -0.092), (3, -0.113), (4, -0.075), (5, 0.437), (6, 0.01), (7, 0.012), (8, -0.326), (9, 0.2), (10, -0.32), (11, 0.159), (12, -0.038), (13, -0.223), (14, -0.017), (15, 0.055), (16, -0.167), (17, 0.212), (18, -0.203), (19, 0.08), (20, -0.005), (21, 0.088), (22, 0.037), (23, 0.015), (24, 0.047), (25, -0.019), (26, -0.047), (27, 0.006), (28, -0.014), (29, -0.006), (30, 0.026), (31, 0.012), (32, 0.011), (33, 0.006), (34, -0.041), (35, 0.004), (36, -0.008), (37, 0.014), (38, -0.026), (39, -0.008), (40, -0.021), (41, -0.01), (42, -0.004), (43, -0.021), (44, -0.002), (45, 0.008), (46, 0.008), (47, 0.007), (48, -0.025), (49, -0.02)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 0.96177357 <a title="13-lsi-1" href="./iccv-2013-A_General_Two-Step_Approach_to_Learning-Based_Hashing.html">13 iccv-2013-A General Two-Step Approach to Learning-Based Hashing</a></p>
<p>Author: Guosheng Lin, Chunhua Shen, David Suter, Anton van_den_Hengel</p><p>Abstract: Most existing approaches to hashing apply a single form of hash function, and an optimization process which is typically deeply coupled to this specific form. This tight coupling restricts the flexibility of the method to respond to the data, and can result in complex optimization problems that are difficult to solve. Here we propose a flexible yet simple framework that is able to accommodate different types of loss functions and hash functions. This framework allows a number of existing approaches to hashing to be placed in context, and simplifies the development of new problemspecific hashing methods. Our framework decomposes the hashing learning problem into two steps: hash bit learning and hash function learning based on the learned bits. The first step can typically be formulated as binary quadratic problems, and the second step can be accomplished by training standard binary classifiers. Both problems have been extensively studied in the literature. Our extensive experiments demonstrate that the proposed framework is effective, flexible and outperforms the state-of-the-art.</p><p>2 0.95461756 <a title="13-lsi-2" href="./iccv-2013-Complementary_Projection_Hashing.html">83 iccv-2013-Complementary Projection Hashing</a></p>
<p>Author: Zhongming Jin, Yao Hu, Yue Lin, Debing Zhang, Shiding Lin, Deng Cai, Xuelong Li</p><p>Abstract: Recently, hashing techniques have been widely applied to solve the approximate nearest neighbors search problem in many vision applications. Generally, these hashing approaches generate 2c buckets, where c is the length of the hash code. A good hashing method should satisfy the following two requirements: 1) mapping the nearby data points into the same bucket or nearby (measured by xue long l i opt . ac . cn @ a(a)b(b) the Hamming distance) buckets. 2) all the data points are evenly distributed among all the buckets. In this paper, we propose a novel algorithm named Complementary Projection Hashing (CPH) to find the optimal hashing functions which explicitly considers the above two requirements. Specifically, CPHaims at sequentiallyfinding a series ofhyperplanes (hashing functions) which cross the sparse region of the data. At the same time, the data points are evenly distributed in the hypercubes generated by these hyperplanes. The experiments comparing with the state-of-the-art hashing methods demonstrate the effectiveness of the proposed method.</p><p>3 0.93729419 <a title="13-lsi-3" href="./iccv-2013-Learning_Hash_Codes_with_Listwise_Supervision.html">239 iccv-2013-Learning Hash Codes with Listwise Supervision</a></p>
<p>Author: Jun Wang, Wei Liu, Andy X. Sun, Yu-Gang Jiang</p><p>Abstract: Hashing techniques have been intensively investigated in the design of highly efficient search engines for largescale computer vision applications. Compared with prior approximate nearest neighbor search approaches like treebased indexing, hashing-based search schemes have prominent advantages in terms of both storage and computational efficiencies. Moreover, the procedure of devising hash functions can be easily incorporated into sophisticated machine learning tools, leading to data-dependent and task-specific compact hash codes. Therefore, a number of learning paradigms, ranging from unsupervised to supervised, have been applied to compose appropriate hash functions. How- ever, most of the existing hash function learning methods either treat hash function design as a classification problem or generate binary codes to satisfy pairwise supervision, and have not yet directly optimized the search accuracy. In this paper, we propose to leverage listwise supervision into a principled hash function learning framework. In particular, the ranking information is represented by a set of rank triplets that can be used to assess the quality of ranking. Simple linear projection-based hash functions are solved efficiently through maximizing the ranking quality over the training data. We carry out experiments on large image datasets with size up to one million and compare with the state-of-the-art hashing techniques. The extensive results corroborate that our learned hash codes via listwise supervision can provide superior search accuracy without incurring heavy computational overhead.</p><p>4 0.89411891 <a title="13-lsi-4" href="./iccv-2013-Supervised_Binary_Hash_Code_Learning_with_Jensen_Shannon_Divergence.html">409 iccv-2013-Supervised Binary Hash Code Learning with Jensen Shannon Divergence</a></p>
<p>Author: Lixin Fan</p><p>Abstract: This paper proposes to learn binary hash codes within a statistical learning framework, in which an upper bound of the probability of Bayes decision errors is derived for different forms of hash functions and a rigorous proof of the convergence of the upper bound is presented. Consequently, minimizing such an upper bound leads to consistent performance improvements of existing hash code learning algorithms, regardless of whether original algorithms are unsupervised or supervised. This paper also illustrates a fast hash coding method that exploits simple binary tests to achieve orders of magnitude improvement in coding speed as compared to projection based methods.</p><p>5 0.87333685 <a title="13-lsi-5" href="./iccv-2013-Large-Scale_Video_Hashing_via_Structure_Learning.html">229 iccv-2013-Large-Scale Video Hashing via Structure Learning</a></p>
<p>Author: Guangnan Ye, Dong Liu, Jun Wang, Shih-Fu Chang</p><p>Abstract: Recently, learning based hashing methods have become popular for indexing large-scale media data. Hashing methods map high-dimensional features to compact binary codes that are efficient to match and robust in preserving original similarity. However, most of the existing hashing methods treat videos as a simple aggregation of independent frames and index each video through combining the indexes of frames. The structure information of videos, e.g., discriminative local visual commonality and temporal consistency, is often neglected in the design of hash functions. In this paper, we propose a supervised method that explores the structure learning techniques to design efficient hash functions. The proposed video hashing method formulates a minimization problem over a structure-regularized empirical loss. In particular, the structure regularization exploits the common local visual patterns occurring in video frames that are associated with the same semantic class, and simultaneously preserves the temporal consistency over successive frames from the same video. We show that the minimization objective can be efficiently solved by an Acceler- ated Proximal Gradient (APG) method. Extensive experiments on two large video benchmark datasets (up to around 150K video clips with over 12 million frames) show that the proposed method significantly outperforms the state-ofthe-art hashing methods.</p><p>6 0.43996206 <a title="13-lsi-6" href="./iccv-2013-A_Scalable_Unsupervised_Feature_Merging_Approach_to_Efficient_Dimensionality_Reduction_of_High-Dimensional_Visual_Data.html">29 iccv-2013-A Scalable Unsupervised Feature Merging Approach to Efficient Dimensionality Reduction of High-Dimensional Visual Data</a></p>
<p>7 0.39047179 <a title="13-lsi-7" href="./iccv-2013-What_is_the_Most_EfficientWay_to_Select_Nearest_Neighbor_Candidates_for_Fast_Approximate_Nearest_Neighbor_Search%3F.html">450 iccv-2013-What is the Most EfficientWay to Select Nearest Neighbor Candidates for Fast Approximate Nearest Neighbor Search?</a></p>
<p>8 0.33496898 <a title="13-lsi-8" href="./iccv-2013-Joint_Inverted_Indexing.html">221 iccv-2013-Joint Inverted Indexing</a></p>
<p>9 0.29485062 <a title="13-lsi-9" href="./iccv-2013-Stable_Hyper-pooling_and_Query_Expansion_for_Event_Detection.html">400 iccv-2013-Stable Hyper-pooling and Query Expansion for Event Detection</a></p>
<p>10 0.24803853 <a title="13-lsi-10" href="./iccv-2013-Random_Grids%3A_Fast_Approximate_Nearest_Neighbors_and_Range_Searching_for_Image_Search.html">337 iccv-2013-Random Grids: Fast Approximate Nearest Neighbors and Range Searching for Image Search</a></p>
<p>11 0.24119276 <a title="13-lsi-11" href="./iccv-2013-Fast_Neighborhood_Graph_Search_Using_Cartesian_Concatenation.html">159 iccv-2013-Fast Neighborhood Graph Search Using Cartesian Concatenation</a></p>
<p>12 0.2214905 <a title="13-lsi-12" href="./iccv-2013-Fix_Structured_Learning_of_2013_ICCV_paper_k2opt.pdf.html">171 iccv-2013-Fix Structured Learning of 2013 ICCV paper k2opt.pdf</a></p>
<p>13 0.21764775 <a title="13-lsi-13" href="./iccv-2013-Neighbor-to-Neighbor_Search_for_Fast_Coding_of_Feature_Vectors.html">287 iccv-2013-Neighbor-to-Neighbor Search for Fast Coding of Feature Vectors</a></p>
<p>14 0.21092661 <a title="13-lsi-14" href="./iccv-2013-Quadruplet-Wise_Image_Similarity_Learning.html">332 iccv-2013-Quadruplet-Wise Image Similarity Learning</a></p>
<p>15 0.20165233 <a title="13-lsi-15" href="./iccv-2013-Recursive_Estimation_of_the_Stein_Center_of_SPD_Matrices_and_Its_Applications.html">347 iccv-2013-Recursive Estimation of the Stein Center of SPD Matrices and Its Applications</a></p>
<p>16 0.20155308 <a title="13-lsi-16" href="./iccv-2013-Large-Scale_Image_Annotation_by_Efficient_and_Robust_Kernel_Metric_Learning.html">227 iccv-2013-Large-Scale Image Annotation by Efficient and Robust Kernel Metric Learning</a></p>
<p>17 0.19745968 <a title="13-lsi-17" href="./iccv-2013-Learning_to_Rank_Using_Privileged_Information.html">248 iccv-2013-Learning to Rank Using Privileged Information</a></p>
<p>18 0.19658121 <a title="13-lsi-18" href="./iccv-2013-Detecting_Irregular_Curvilinear_Structures_in_Gray_Scale_and_Color_Imagery_Using_Multi-directional_Oriented_Flux.html">112 iccv-2013-Detecting Irregular Curvilinear Structures in Gray Scale and Color Imagery Using Multi-directional Oriented Flux</a></p>
<p>19 0.18657315 <a title="13-lsi-19" href="./iccv-2013-From_Semi-supervised_to_Transfer_Counting_of_Crowds.html">178 iccv-2013-From Semi-supervised to Transfer Counting of Crowds</a></p>
<p>20 0.1822554 <a title="13-lsi-20" href="./iccv-2013-Abnormal_Event_Detection_at_150_FPS_in_MATLAB.html">34 iccv-2013-Abnormal Event Detection at 150 FPS in MATLAB</a></p>
<br/>
<h2>similar papers computed by <a title="lda-model" href="../home/iccv2013_lda.html">lda model</a></h2><h3>lda for this paper:</h3><p>topicId topicWeight</p>
<p>[(2, 0.549), (7, 0.037), (26, 0.037), (31, 0.03), (42, 0.063), (64, 0.022), (73, 0.012), (77, 0.016), (89, 0.11), (98, 0.015)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 0.90130186 <a title="13-lda-1" href="./iccv-2013-A_General_Two-Step_Approach_to_Learning-Based_Hashing.html">13 iccv-2013-A General Two-Step Approach to Learning-Based Hashing</a></p>
<p>Author: Guosheng Lin, Chunhua Shen, David Suter, Anton van_den_Hengel</p><p>Abstract: Most existing approaches to hashing apply a single form of hash function, and an optimization process which is typically deeply coupled to this specific form. This tight coupling restricts the flexibility of the method to respond to the data, and can result in complex optimization problems that are difficult to solve. Here we propose a flexible yet simple framework that is able to accommodate different types of loss functions and hash functions. This framework allows a number of existing approaches to hashing to be placed in context, and simplifies the development of new problemspecific hashing methods. Our framework decomposes the hashing learning problem into two steps: hash bit learning and hash function learning based on the learned bits. The first step can typically be formulated as binary quadratic problems, and the second step can be accomplished by training standard binary classifiers. Both problems have been extensively studied in the literature. Our extensive experiments demonstrate that the proposed framework is effective, flexible and outperforms the state-of-the-art.</p><p>2 0.88360643 <a title="13-lda-2" href="./iccv-2013-Offline_Mobile_Instance_Retrieval_with_a_Small_Memory_Footprint.html">294 iccv-2013-Offline Mobile Instance Retrieval with a Small Memory Footprint</a></p>
<p>Author: Jayaguru Panda, Michael S. Brown, C.V. Jawahar</p><p>Abstract: Existing mobile image instance retrieval applications assume a network-based usage where image features are sent to a server to query an online visual database. In this scenario, there are no restrictions on the size of the visual database. This paper, however, examines how to perform this same task offline, where the entire visual index must reside on the mobile device itself within a small memory footprint. Such solutions have applications on location recognition and product recognition. Mobile instance retrieval requires a significant reduction in the visual index size. To achieve this, we describe a set of strategies that can reduce the visual index up to 60-80 compared to a scatannd raerddu iens tthaen vceis rueatrli ienvdaelx xim upple tom 6en0t-8at0io ×n found on ddte osk atops or servers. While our proposed reduction steps affect the overall mean Average Precision (mAP), they are able to maintain a good Precision for the top K results (PK). We argue that for such offline application, maintaining a good PK is sufficient. The effectiveness of this approach is demonstrated on several standard databases. A working application designed for a remote historical site is also presented. This application is able to reduce an 50,000 image index structure to 25 MBs while providing a precision of 97% for P10 and 100% for P1.</p><p>3 0.84529841 <a title="13-lda-3" href="./iccv-2013-Visual_Semantic_Complex_Network_for_Web_Images.html">446 iccv-2013-Visual Semantic Complex Network for Web Images</a></p>
<p>Author: Shi Qiu, Xiaogang Wang, Xiaoou Tang</p><p>Abstract: This paper proposes modeling the complex web image collections with an automatically generated graph structure called visual semantic complex network (VSCN). The nodes on this complex network are clusters of images with both visual and semantic consistency, called semantic concepts. These nodes are connected based on the visual and semantic correlations. Our VSCN with 33, 240 concepts is generated from a collection of 10 million web images. 1 A great deal of valuable information on the structures of the web image collections can be revealed by exploring the VSCN, such as the small-world behavior, concept community, indegree distribution, hubs, and isolated concepts. It not only helps us better understand the web image collections at a macroscopic level, but also has many important practical applications. This paper presents two application examples: content-based image retrieval and image browsing. Experimental results show that the VSCN leads to significant improvement on both the precision of image retrieval (over 200%) and user experience for image browsing.</p><p>4 0.83418989 <a title="13-lda-4" href="./iccv-2013-Revisiting_Example_Dependent_Cost-Sensitive_Learning_with_Decision_Trees.html">352 iccv-2013-Revisiting Example Dependent Cost-Sensitive Learning with Decision Trees</a></p>
<p>Author: Oisin Mac Aodha, Gabriel J. Brostow</p><p>Abstract: Typical approaches to classification treat class labels as disjoint. For each training example, it is assumed that there is only one class label that correctly describes it, and that all other labels are equally bad. We know however, that good and bad labels are too simplistic in many scenarios, hurting accuracy. In the realm of example dependent costsensitive learning, each label is instead a vector representing a data point’s affinity for each of the classes. At test time, our goal is not to minimize the misclassification rate, but to maximize that affinity. We propose a novel example dependent cost-sensitive impurity measure for decision trees. Our experiments show that this new impurity measure improves test performance while still retaining the fast test times of standard classification trees. We compare our approach to classification trees and other cost-sensitive methods on three computer vision problems, tracking, descriptor matching, and optical flow, and show improvements in all three domains.</p><p>5 0.82194161 <a title="13-lda-5" href="./iccv-2013-Handling_Uncertain_Tags_in_Visual_Recognition.html">191 iccv-2013-Handling Uncertain Tags in Visual Recognition</a></p>
<p>Author: Arash Vahdat, Greg Mori</p><p>Abstract: Gathering accurate training data for recognizing a set of attributes or tags on images or videos is a challenge. Obtaining labels via manual effort or from weakly-supervised data typically results in noisy training labels. We develop the FlipSVM, a novel algorithm for handling these noisy, structured labels. The FlipSVM models label noise by “flipping ” labels on training examples. We show empirically that the FlipSVM is effective on images-and-attributes and video tagging datasets.</p><p>6 0.80606872 <a title="13-lda-6" href="./iccv-2013-Improving_Graph_Matching_via_Density_Maximization.html">214 iccv-2013-Improving Graph Matching via Density Maximization</a></p>
<p>7 0.80533773 <a title="13-lda-7" href="./iccv-2013-Learning_View-Invariant_Sparse_Representations_for_Cross-View_Action_Recognition.html">244 iccv-2013-Learning View-Invariant Sparse Representations for Cross-View Action Recognition</a></p>
<p>8 0.76855201 <a title="13-lda-8" href="./iccv-2013-Salient_Region_Detection_by_UFO%3A_Uniqueness%2C_Focusness_and_Objectness.html">374 iccv-2013-Salient Region Detection by UFO: Uniqueness, Focusness and Objectness</a></p>
<p>9 0.71249151 <a title="13-lda-9" href="./iccv-2013-Learning_Hash_Codes_with_Listwise_Supervision.html">239 iccv-2013-Learning Hash Codes with Listwise Supervision</a></p>
<p>10 0.69268274 <a title="13-lda-10" href="./iccv-2013-Face_Recognition_Using_Face_Patch_Networks.html">153 iccv-2013-Face Recognition Using Face Patch Networks</a></p>
<p>11 0.69206834 <a title="13-lda-11" href="./iccv-2013-Supervised_Binary_Hash_Code_Learning_with_Jensen_Shannon_Divergence.html">409 iccv-2013-Supervised Binary Hash Code Learning with Jensen Shannon Divergence</a></p>
<p>12 0.68189985 <a title="13-lda-12" href="./iccv-2013-Complementary_Projection_Hashing.html">83 iccv-2013-Complementary Projection Hashing</a></p>
<p>13 0.67122406 <a title="13-lda-13" href="./iccv-2013-Pose_Estimation_and_Segmentation_of_People_in_3D_Movies.html">322 iccv-2013-Pose Estimation and Segmentation of People in 3D Movies</a></p>
<p>14 0.66095418 <a title="13-lda-14" href="./iccv-2013-Large-Scale_Video_Hashing_via_Structure_Learning.html">229 iccv-2013-Large-Scale Video Hashing via Structure Learning</a></p>
<p>15 0.6130479 <a title="13-lda-15" href="./iccv-2013-Person_Re-identification_by_Salience_Matching.html">313 iccv-2013-Person Re-identification by Salience Matching</a></p>
<p>16 0.61279863 <a title="13-lda-16" href="./iccv-2013-Learning_to_Rank_Using_Privileged_Information.html">248 iccv-2013-Learning to Rank Using Privileged Information</a></p>
<p>17 0.60721475 <a title="13-lda-17" href="./iccv-2013-SYM-FISH%3A_A_Symmetry-Aware_Flip_Invariant_Sketch_Histogram_Shape_Descriptor.html">368 iccv-2013-SYM-FISH: A Symmetry-Aware Flip Invariant Sketch Histogram Shape Descriptor</a></p>
<p>18 0.60330957 <a title="13-lda-18" href="./iccv-2013-Class-Specific_Simplex-Latent_Dirichlet_Allocation_for_Image_Classification.html">73 iccv-2013-Class-Specific Simplex-Latent Dirichlet Allocation for Image Classification</a></p>
<p>19 0.59890807 <a title="13-lda-19" href="./iccv-2013-Semantic-Aware_Co-indexing_for_Image_Retrieval.html">378 iccv-2013-Semantic-Aware Co-indexing for Image Retrieval</a></p>
<p>20 0.58891588 <a title="13-lda-20" href="./iccv-2013-Video_Synopsis_by_Heterogeneous_Multi-source_Correlation.html">443 iccv-2013-Video Synopsis by Heterogeneous Multi-source Correlation</a></p>
<br/><br/><br/>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-48522588-1', 'makerhacker.github.io');
ga('send', 'pageview');
</script>

</body>
</html>
