<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>228 iccv-2013-Large-Scale Multi-resolution Surface Reconstruction from RGB-D Sequences</title>
</head>

<body>
<p><a title="iccv" href="../iccv_home.html">iccv</a> <a title="iccv-2013" href="../home/iccv2013_home.html">iccv2013</a> <a title="iccv-2013-228" href="../iccv2013/iccv-2013-Large-Scale_Multi-resolution_Surface_Reconstruction_from_RGB-D_Sequences.html">iccv2013-228</a> <a title="iccv-2013-228-reference" href="#">iccv2013-228-reference</a> knowledge-graph by maker-knowledge-mining</p><h1>228 iccv-2013-Large-Scale Multi-resolution Surface Reconstruction from RGB-D Sequences</h1>
<br/><p>Source: <a title="iccv-2013-228-pdf" href="http://www.cv-foundation.org/openaccess/content_iccv_2013/papers/Steinbrucker_Large-Scale_Multi-resolution_Surface_2013_ICCV_paper.pdf">pdf</a></p><p>Author: Frank Steinbr√ºcker, Christian Kerl, Daniel Cremers</p><p>Abstract: We propose a method to generate highly detailed, textured 3D models of large environments from RGB-D sequences. Our system runs in real-time on a standard desktop PC with a state-of-the-art graphics card. To reduce the memory consumption, we fuse the acquired depth maps and colors in a multi-scale octree representation of a signed distance function. To estimate the camera poses, we construct a pose graph and use dense image alignment to determine the relative pose between pairs of frames. We add edges between nodes when we detect loop-closures and optimize the pose graph to correct for long-term drift. Our implementation is highly parallelized on graphics hardware to achieve real-time performance. More specifically, we can reconstruct, store, and continuously update a colored 3D model of an entire corridor of nine rooms at high levels of detail in real-time on a single GPU with 2.5GB.</p><br/>
<h2>reference text</h2><br/>
<br/><br/><br/>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-48522588-1', 'makerhacker.github.io');
ga('send', 'pageview');
</script>

</body>
</html>
