<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>175 acl-2012-Semi-supervised Dependency Parsing using Lexical Affinities</title>
</head>

<body>
<p><a title="acl" href="../acl_home.html">acl</a> <a title="acl-2012" href="../home/acl2012_home.html">acl2012</a> <a title="acl-2012-175" href="#">acl2012-175</a> knowledge-graph by maker-knowledge-mining</p><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- maker adsense -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-5027806277543591"
     data-ad-slot="4192012269"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>175 acl-2012-Semi-supervised Dependency Parsing using Lexical Affinities</h1>
<br/><p>Source: <a title="acl-2012-175-pdf" href="http://aclweb.org/anthology//P/P12/P12-1082.pdf">pdf</a></p><p>Author: Seyed Abolghasem Mirroshandel ; Alexis Nasr ; Joseph Le Roux</p><p>Abstract: Treebanks are not large enough to reliably model precise lexical phenomena. This deficiency provokes attachment errors in the parsers trained on such data. We propose in this paper to compute lexical affinities, on large corpora, for specific lexico-syntactic configurations that are hard to disambiguate and introduce the new information in a parser. Experiments on the French Treebank showed a relative decrease ofthe error rate of 7. 1% Labeled Accuracy Score yielding the best parsing results on this treebank.</p><p>Reference: <a title="acl-2012-175-reference" href="../acl2012_reference/acl-2012-Semi-supervised_Dependency_Parsing_using_Lexical_Affinities_reference.html">text</a></p><br/><h2>Summary: the most important sentenses genereted by tfidf model</h2><p>sentIndex sentText sentNum sentScore</p><p>1 We propose in this paper to compute lexical affinities, on large corpora, for specific lexico-syntactic configurations that are hard to disambiguate and introduce the new information in a parser. [sent-13, score-0.416]
</p><p>2 While this  amount of data seems reasonable for learning syn-  tactic phenomena and, to some extent, very frequent lexical phenomena involving closed parts of speech (POS), it proves inadequate when modeling lexical dependencies between open POS, such as nouns, verbs and adjectives. [sent-17, score-0.468]
</p><p>3 The raw corpus is first parsed and the computed lexical affinities between lemmas, in specific lexico-syntactic configurations, are then injected back in the parser. [sent-20, score-0.403]
</p><p>4 fr ) is, as mentioned above, a better modeling of bilexical dependencies and the second is a method to adapt a parser to new domains. [sent-22, score-0.374]
</p><p>5 In section 3, we describe the parser that we use in our experiments and give a detailed description of the frequent attachment er-  rors. [sent-25, score-0.333]
</p><p>6 Section 4 describes how lexical affinities between lemmas are calculated and their impact is then evaluated with respect to the attachment errors made by the parser. [sent-26, score-0.494]
</p><p>7 Section 5 describes three ways to integrate the lexical affinities in the parser and reports the results obtained with the three methods. [sent-27, score-0.556]
</p><p>8 2  Previous Work  Coping with lexical sparsity of treebanks using raw corpora has been an active direction of research for many years. [sent-28, score-0.235]
</p><p>9 The word occurrences of the training treebank are then replaced by their cluster identifier and a new parser is trained on the transformed treebank. [sent-30, score-0.403]
</p><p>10 Based on the counts produced, lexical affinity scores are computed. [sent-41, score-0.48]
</p><p>11 Our work departs from those approaches by the fact that we do not extract the lexical information directly on a raw corpus, but we first parse it and then extract the co-occurrences on the parse trees, based on some predetermined lexico-syntactic patterns. [sent-44, score-0.339]
</p><p>12 , 2003; Sagae and Tsujii, 2007) where a parser is first trained on a treebank and then used to parse a large raw corpus. [sent-50, score-0.471]
</p><p>13 The parses produced are then added to the initial treebank and a new parser is trained. [sent-51, score-0.465]
</p><p>14 The main difference between these approaches and ours is that we do not directly add the output of the parser to the training corpus, but extract precise lexical information that is then re-injected in the parser. [sent-52, score-0.431]
</p><p>15 , 2009) is quite close to our work: instead ofadding new parses to the treebank, the occurrence of simple interesting subtrees are detected in the parses and introduced as new features in the parser. [sent-54, score-0.222]
</p><p>16 The way we introduce lexical affinity measures in the parser, in 5. [sent-55, score-0.472]
</p><p>17 1, shares some ideas with (Anguiano and Candito, 2011), who modify some attachments in the parser output, based on lexical information. [sent-56, score-0.531]
</p><p>18 The main difference is that we only take attachments that appear in an n-best parse list into account, while 778  they consider the first best parse and compute all potential alternative attachments, that may not actually occur in the n-best forests. [sent-57, score-0.321]
</p><p>19 3  The Parser  The parser used in this work is the second order graph based parser (McDonald et al. [sent-58, score-0.508]
</p><p>20 The parser was trained on the French Treebank (Abeill e´ et al. [sent-61, score-0.254]
</p><p>21 The parser gave state of the art results for parsing of French, reported in table 2. [sent-67, score-0.331]
</p><p>22 In this figure, x axis shows the error types and y axis shows the error ratio of the related error type (numberto otfal e rnroumrsb oefr t ohfe e srpreorcisfic type). [sent-75, score-0.327]
</p><p>23 We define an error type by the POS tag of the governor and the POS tag of the dependent. [sent-76, score-0.38]
</p><p>24 The shape of the curve shows that concentrating on some specific frequent errors in order to increase the parser accuracy is a good strategy. [sent-78, score-0.35]
</p><p>25 Error Type  Figure 1: Distribution of the types of errors Table 3 gives a finer description of the most common types of error made by the parser. [sent-79, score-0.21]
</p><p>26 Here we define more precise patterns for errors, where some lexical values are specified (for prepositions) and, in some cases, the nature of the dependency is taken  into account. [sent-80, score-0.282]
</p><p>27 The third one displays the accuracy for this type of dependency (the number of dependencies of this type correctly analyzed by the parser divided by the total number of dependencies of this type). [sent-84, score-0.599]
</p><p>28 The fourth column shows the contribution of the errors made on this type of dependency to the global error rate. [sent-85, score-0.369]
</p><p>29 The last column associates a name with some of the error types that will prove useful in the remainder of the paper to refer to the error type. [sent-86, score-0.247]
</p><p>30 The first one concerns very common dependencies that have a high accuracy but, due to their frequency, hurt the global error rate of the parser. [sent-88, score-0.274]
</p><p>31 n Wobjheecnt replacing variables g and d in C respectively with eat and oyster, we obtain the fully specified lexico syn-  →obj  tactic pattern(V, eat) (N, oyster), that we call an instantiated configuration. [sent-104, score-0.245]
</p><p>32 In the perspective of increasing a parser performances, there is no point in computing lexical affinity scores between words that appear in a configuration for which the parser never makes mistakes. [sent-110, score-1.171]
</p><p>33 The creation ofthe lexical resource is a three stage process. [sent-111, score-0.287]
</p><p>34 The first step is the definition of configurations, the second one is the collection of raw counts from the machine parsed corpora and the third one is the computation of lexical affinities based on the raw counts. [sent-112, score-0.485]
</p><p>35 1 Computing Lexical Affinities A set of 9 configurations have been defined. [sent-116, score-0.246]
</p><p>36 The list of the 9 configurations is described in Table 4. [sent-118, score-0.246]
</p><p>37 As one can see on this table, configurations are usually simple, made up of one or two dependencies. [sent-119, score-0.296]
</p><p>38 Linguistically, configurations OBJ  and SBJ concern subject and object attachments, configuration ADJ is related to attachments of adjectives to nouns and configurations NdeN, VdeN, VaN, and NaN indicate prepositional attachments. [sent-120, score-0.865]
</p><p>39 The computation of the number of occurrences of an instantiated configuration in the corpus is quite  straightforward, it consists in traversing the dependency trees produced by the parser and detect the occurrences of this configuration. [sent-123, score-0.84]
</p><p>40 05  Table 5: sizes of the corpora used to gather lexical counts ered for every lemma lits number of occurrences as governor (resp. [sent-127, score-0.542]
</p><p>41 dependent) of configuration C in the corpus, noted C(C, l, ∗) (resp. [sent-128, score-0.228]
</p><p>42 configuration Cw wlli tahs lemma lg as a governor and lemma ld as a dependent, noted C(C, lg, ld). [sent-130, score-0.826]
</p><p>43 This score should reflect the tendency of lg and ld to appear together in configuration C. [sent-132, score-0.483]
</p><p>44 It should be maximal if when-  ever lg occurs as the governor of configuration C, the dependent position is occupied by ld and, symmetrically, if whenever ld occurs as the dependent of configuration C, the governor position is occupied by lg. [sent-133, score-1.456]
</p><p>45 2 Evaluation Lexical affinities were computed on three corpora of slightly different genres. [sent-139, score-0.202]
</p><p>46 Then the lexical resource was built, based on the 9 configurations described in table 4. [sent-144, score-0.533]
</p><p>47 The lexical resource has been evaluated on FTB DEV with respect to two measures: coverage and correction rate, described in the next two sections. [sent-145, score-0.455]
</p><p>48 1 Coverage Coverage measures the instantiated configurations present in the evaluation corpus that are in the resource. [sent-148, score-0.347]
</p><p>49 Last column represents the coverage of the training corpus (the lexical resource is extracted on the training corpus) and the last line represents the same quantities computed on all configurations. [sent-151, score-0.459]
</p><p>50 Table 6 shows two interesting results: firstly the  high variability of coverage with respect to configurations, and secondly the low coverage when the lexical resource is computed on the training corpus, this fact being consistent with the conclusions of (Bikel, 2004). [sent-152, score-0.493]
</p><p>51 A parser trained on a treebank cannot be expected to reliably select the correct governor in lexically sensitive cases. [sent-153, score-0.58]
</p><p>52 2 Correction Rate While coverage measures how many instantiated configurations that occur in the treebank are actu-  ally present in the lexical resource, it does not measure if the information present in the lexical resource can actually help correcting the errors made by the parser. [sent-156, score-1.045]
</p><p>53 Given a word d present in a sentence S and a configuration C, the set of all potential governors of d in configuration C, in all the n-best parses produced by the parser is computed. [sent-158, score-0.918]
</p><p>54 Ideally, G should not be the set of governors in theI dne-ablelsy,t parses u buldt tnhoet s bete o thf aell s possible governors for d in sentence S. [sent-166, score-0.242]
</p><p>55 Let us note GH the governor of d in the (first) best parse produced and GR the governor of d in the correct parse. [sent-168, score-0.605]
</p><p>56 parENC inACEgthe  governor of a word produced by the parser (GH), in the reference parse (GR) and according to the lexical resource (GL). [sent-172, score-0.899]
</p><p>57 In scenarios CC and CE, the parser did not make a mistake (the first letter, C, stands for correct). [sent-173, score-0.29]
</p><p>58 In scenario CC, the lexical affinity score was compatible with the choice of the parser or the lexical resource did not select any candidate. [sent-174, score-1.009]
</p><p>59 In scenario CE, the lexical resource introduced an error. [sent-175, score-0.287]
</p><p>60 In scenarios EC and EE, the parser made an error. [sent-176, score-0.34]
</p><p>61 In EC, the error was corrected by the lexical resource while in EE, it wasn’t. [sent-177, score-0.384]
</p><p>62 Either because the lexical resource  candidate was not the correct governor or it was unspecified. [sent-178, score-0.534]
</p><p>63 The last case, NA, indicates that the correct governor does not appear in any of the n-best parses. [sent-179, score-0.247]
</p><p>64 Technically this case could be integrated in EE (an error made by the parser was not corrected by the lexical resource) but we chose to keep it apart since it represents a case where the right solution could not be found in the n-best parse list (the correct governor is not a member of set G). [sent-180, score-0.849]
</p><p>65 We compute CR for this configuration in the following way: CR  =  =  old error noulmdb eerrro -r n neuwm eberrror number nEC − nCE nEE nEC nNA  +  +  n−  +  n+  n  When CR is equal to 0, the correction did not have any impact on the error rate. [sent-182, score-0.541]
</p><p>66 CR for each configuration is reported in table 8. [sent-184, score-0.228]
</p><p>67 Results for PP attachments VdeN, VaN and NaN are quite good (a CR of 75% for a given configuration, as VdeN indicates that the number of errors on such a configuration is decreased by 25%). [sent-188, score-0.515]
</p><p>68 It is interesting to note that the parser behaves quite badly on these attachments: their accuracy (as reported in table 3) is, respectively 74. [sent-189, score-0.372]
</p><p>69 On the other hand, some attachments like configuration ADJ and NdeN, for which the parser showed very  good accuracy (96. [sent-194, score-0.66]
</p><p>70 In such cases, taking into account lexical affinity creates new errors. [sent-197, score-0.484]
</p><p>71 1One can note, that contrary to coverage, CR does not measure a characteristic of the lexical resource alone, but the lexical resource combined with a parser. [sent-198, score-0.574]
</p><p>72 782 On average, using the lexical resource with this simple strategy of systematically replacing GH with GL allows to decrease by 20% the errors made on our 9 configurations and by 2. [sent-199, score-0.68]
</p><p>73 Ideally, we would like to take into account only non ambiguous sentences, for which the parser outputs a single parse hypothesis, hopefully the good one. [sent-203, score-0.416]
</p><p>74 Another solution would be to select sentences for which the parser has a high confidence, using confidence measures as proposed in (S ´anchez-S a´ez et al. [sent-205, score-0.337]
</p><p>75 Given the n best parses of a sentence and a dependency δ, present in at least one of the n best parses, let us note C(δ) the number of occurrences of δ in tlehet n b neostte parse s thete. [sent-209, score-0.299]
</p><p>76 It is computed as follows:  AM(δ) = 1 −C(nδ) An ambiguity measure of 0 indicates that δ is non ambiguous in the set of the n best parses (the word that constitutes the dependent in δ is attached to the word that constitutes the governor in δ in all the nbest analyses). [sent-211, score-0.551]
</p><p>77 When n gets large enough this measure approximates the non ambiguity of a dependency in a given sentence. [sent-212, score-0.21]
</p><p>78 Ambiguity measure is used to filter the data when counting the number of occurrences of a configuration: only occurrences that are made of dependencies δ such that AM(δ) ≤ τ are taken into account. [sent-213, score-0.275]
</p><p>79 The results of coverage and CR given above were computed for τ equal to 1, which means that, when collecting counts, all the dependencies are taken into account whatever their ambiguity is. [sent-215, score-0.349]
</p><p>80 FTB DEV  for  5  Integrating Lexical Affinity in the Parser  We have devised three methods for taking into account lexical affinity scores in the parser. [sent-222, score-0.484]
</p><p>81 The first two are post-processing methods, that take as input the n-best parses produced by the parser and modify some attachments with respect to the information given by the lexical resource. [sent-223, score-0.663]
</p><p>82 The third method introduces the lexical affinity scores as new features in the parsing model. [sent-224, score-0.512]
</p><p>83 Once GL is identified, one can replace the choice of the parser (GH) with GL. [sent-236, score-0.287]
</p><p>84 This method is quite crude since it does not take into account the confi-  dence the parser has in the solution proposed. [sent-237, score-0.345]
</p><p>85 2 that CR was very low for configurations for which the parser achieves good accuracy. [sent-240, score-0.5]
</p><p>86 In order to introduce the parser confidence in the final choice of a governor, we compute C(GH) and 783 C(GL) which respectively represent the number of tCim(Ges GH and GL appear as the governor of configuration C. [sent-241, score-0.846]
</p><p>87 4, which means that the errors made on the nine configurations are now decreased by 40%. [sent-252, score-0.396]
</p><p>88 4 Table 10: Correction Rate on FTB DEV when taking into account parser confidence. [sent-266, score-0.303]
</p><p>89 Recall that the parser we are using is based on a second order model, which means that the score of a dependency depends on some neighboring ones. [sent-272, score-0.324]
</p><p>90 Since  with the post processing method only a subset of the dependencies are modified, the resulting parse is inconsistent: the score of some dependencies is computed on the basis of other dependencies that have been modified. [sent-273, score-0.426]
</p><p>91 3 Feature Based Method In the feature based method, new features are added to the parser that rely on lexical affinity scores. [sent-281, score-0.689]
</p><p>92 These features are of the following form: hC, lg, ld, δC(s)i, where C is a configuration num-  ber, s is the (lsex)iic,a wl affinity score (s = s(C, lg, ld)) and δc(·) is a discretization function. [sent-282, score-0.531]
</p><p>93 Disc(·r)et iisza ati doins coref ttihzea tlieoxnic fauln affinity scores is necessary in order to fight against data sparseness. [sent-283, score-0.303]
</p><p>94 The number of new features added to the parser is equal to PC B(C) where C is a configuration and B(C) is Pthe number of bins for configuration C. [sent-292, score-0.805]
</p><p>95 The three methods outperformed the baseline (the state of the art parser for French which is a second 784 order graph based method) (Bohnet, 2010). [sent-296, score-0.254]
</p><p>96 The best performances were obtained by the Double Parsing method that achieved a labeled relative error reduction of 7, 1% on predicted POS tags, yielding the best parsing results on the French Treebank. [sent-297, score-0.227]
</p><p>97 4436 Table 11: Parser accuracy on FTB TEST using the standard parser (BL) the post processing method (PP), the double parsing method (DP) and the feature based method. [sent-337, score-0.477]
</p><p>98 6  Conclusion  Computing lexical affinities, on large corpora, for specific lexico-syntactic configurations that are hard to disambiguate has shown to be an effective way to increase the performances of a parser. [sent-338, score-0.431]
</p><p>99 We have proposed in this paper one method to compute lexical affinity scores as well as three ways to introduce this new information in a parser. [sent-339, score-0.473]
</p><p>100 Dependency parsing and domain adaptation with lr models and parser ensembles. [sent-502, score-0.331]
</p>
<br/>
<h2>similar papers computed by tfidf model</h2><h3>tfidf for this paper:</h3><p>wordName wordTfidf (topN-words)</p>
<p>[('affinity', 0.303), ('parser', 0.254), ('governor', 0.247), ('configurations', 0.246), ('configuration', 0.228), ('gh', 0.208), ('cr', 0.199), ('gl', 0.189), ('affinities', 0.17), ('resource', 0.155), ('lg', 0.152), ('attachments', 0.145), ('ftb', 0.133), ('lexical', 0.132), ('candito', 0.113), ('french', 0.103), ('ld', 0.103), ('error', 0.097), ('ambiguity', 0.096), ('bins', 0.095), ('parses', 0.09), ('nasr', 0.087), ('oyster', 0.087), ('coverage', 0.087), ('dependencies', 0.085), ('correction', 0.081), ('attachment', 0.079), ('treebank', 0.079), ('parsing', 0.077), ('governors', 0.076), ('post', 0.07), ('dependency', 0.07), ('occurrences', 0.07), ('parse', 0.069), ('raw', 0.069), ('mirroshandel', 0.065), ('vden', 0.065), ('abeill', 0.065), ('weka', 0.065), ('instantiated', 0.064), ('errors', 0.063), ('eat', 0.061), ('obj', 0.061), ('rate', 0.059), ('binning', 0.057), ('crabb', 0.057), ('performances', 0.053), ('column', 0.053), ('roux', 0.052), ('made', 0.05), ('account', 0.049), ('lemma', 0.048), ('cc', 0.047), ('confidence', 0.046), ('nakov', 0.046), ('precise', 0.045), ('counts', 0.045), ('denis', 0.044), ('non', 0.044), ('anguiano', 0.043), ('behaves', 0.043), ('lexico', 0.043), ('macaon', 0.043), ('nden', 0.043), ('nec', 0.043), ('subranges', 0.043), ('tactic', 0.043), ('double', 0.043), ('quite', 0.042), ('produced', 0.042), ('dependent', 0.042), ('gr', 0.04), ('compute', 0.038), ('bohnet', 0.038), ('agence', 0.038), ('self', 0.038), ('phenomena', 0.038), ('decreased', 0.037), ('des', 0.037), ('measures', 0.037), ('scenarios', 0.036), ('pos', 0.036), ('type', 0.036), ('bilexical', 0.035), ('values', 0.035), ('treebanks', 0.034), ('france', 0.034), ('replacing', 0.034), ('choice', 0.033), ('ee', 0.033), ('accuracy', 0.033), ('hc', 0.032), ('pitler', 0.032), ('pour', 0.032), ('langues', 0.032), ('occupied', 0.032), ('preserves', 0.032), ('computed', 0.032), ('pp', 0.032), ('ec', 0.032)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 0.99999964 <a title="175-tfidf-1" href="./acl-2012-Semi-supervised_Dependency_Parsing_using_Lexical_Affinities.html">175 acl-2012-Semi-supervised Dependency Parsing using Lexical Affinities</a></p>
<p>Author: Seyed Abolghasem Mirroshandel ; Alexis Nasr ; Joseph Le Roux</p><p>Abstract: Treebanks are not large enough to reliably model precise lexical phenomena. This deficiency provokes attachment errors in the parsers trained on such data. We propose in this paper to compute lexical affinities, on large corpora, for specific lexico-syntactic configurations that are hard to disambiguate and introduce the new information in a parser. Experiments on the French Treebank showed a relative decrease ofthe error rate of 7. 1% Labeled Accuracy Score yielding the best parsing results on this treebank.</p><p>2 0.14659804 <a title="175-tfidf-2" href="./acl-2012-Dependency_Hashing_for_n-best_CCG_Parsing.html">71 acl-2012-Dependency Hashing for n-best CCG Parsing</a></p>
<p>Author: Dominick Ng ; James R. Curran</p><p>Abstract: Optimising for one grammatical representation, but evaluating over a different one is a particular challenge for parsers and n-best CCG parsing. We find that this mismatch causes many n-best CCG parses to be semantically equivalent, and describe a hashing technique that eliminates this problem, improving oracle n-best F-score by 0.7% and reranking accuracy by 0.4%. We also present a comprehensive analysis of errors made by the C&C; CCG parser, providing the first breakdown of the impact of implementation decisions, such as supertagging, on parsing accuracy.</p><p>3 0.14635389 <a title="175-tfidf-3" href="./acl-2012-Head-driven_Transition-based_Parsing_with_Top-down_Prediction.html">106 acl-2012-Head-driven Transition-based Parsing with Top-down Prediction</a></p>
<p>Author: Katsuhiko Hayashi ; Taro Watanabe ; Masayuki Asahara ; Yuji Matsumoto</p><p>Abstract: This paper presents a novel top-down headdriven parsing algorithm for data-driven projective dependency analysis. This algorithm handles global structures, such as clause and coordination, better than shift-reduce or other bottom-up algorithms. Experiments on the English Penn Treebank data and the Chinese CoNLL-06 data show that the proposed algorithm achieves comparable results with other data-driven dependency parsing algorithms.</p><p>4 0.13639276 <a title="175-tfidf-4" href="./acl-2012-Utilizing_Dependency_Language_Models_for_Graph-based_Dependency_Parsing_Models.html">213 acl-2012-Utilizing Dependency Language Models for Graph-based Dependency Parsing Models</a></p>
<p>Author: Wenliang Chen ; Min Zhang ; Haizhou Li</p><p>Abstract: Most previous graph-based parsing models increase decoding complexity when they use high-order features due to exact-inference decoding. In this paper, we present an approach to enriching high-orderfeature representations for graph-based dependency parsing models using a dependency language model and beam search. The dependency language model is built on a large-amount of additional autoparsed data that is processed by a baseline parser. Based on the dependency language model, we represent a set of features for the parsing model. Finally, the features are efficiently integrated into the parsing model during decoding using beam search. Our approach has two advantages. Firstly we utilize rich high-order features defined over a view of large scope and additional large raw corpus. Secondly our approach does not increase the decoding complexity. We evaluate the proposed approach on English and Chinese data. The experimental results show that our new parser achieves the best accuracy on the Chinese data and comparable accuracy with the best known systems on the English data.</p><p>5 0.13052225 <a title="175-tfidf-5" href="./acl-2012-A_Comparison_of_Chinese_Parsers_for_Stanford_Dependencies.html">5 acl-2012-A Comparison of Chinese Parsers for Stanford Dependencies</a></p>
<p>Author: Wanxiang Che ; Valentin Spitkovsky ; Ting Liu</p><p>Abstract: Stanford dependencies are widely used in natural language processing as a semanticallyoriented representation, commonly generated either by (i) converting the output of a constituent parser, or (ii) predicting dependencies directly. Previous comparisons of the two approaches for English suggest that starting from constituents yields higher accuracies. In this paper, we re-evaluate both methods for Chinese, using more accurate dependency parsers than in previous work. Our comparison of performance and efficiency across seven popular open source parsers (four constituent and three dependency) shows, by contrast, that recent higher-order graph-based techniques can be more accurate, though somewhat slower, than constituent parsers. We demonstrate also that n-way jackknifing is a useful technique for producing automatic (rather than gold) partof-speech tags to train Chinese dependency parsers. Finally, we analyze the relations produced by both kinds of parsing and suggest which specific parsers to use in practice.</p><p>6 0.12624519 <a title="175-tfidf-6" href="./acl-2012-Higher-order_Constituent_Parsing_and_Parser_Combination.html">109 acl-2012-Higher-order Constituent Parsing and Parser Combination</a></p>
<p>7 0.12113366 <a title="175-tfidf-7" href="./acl-2012-An_Exploration_of_Forest-to-String_Translation%3A_Does_Translation_Help_or_Hurt_Parsing%3F.html">25 acl-2012-An Exploration of Forest-to-String Translation: Does Translation Help or Hurt Parsing?</a></p>
<p>8 0.11964308 <a title="175-tfidf-8" href="./acl-2012-Extracting_Narrative_Timelines_as_Temporal_Dependency_Structures.html">90 acl-2012-Extracting Narrative Timelines as Temporal Dependency Structures</a></p>
<p>9 0.11847926 <a title="175-tfidf-9" href="./acl-2012-Exploiting_Multiple_Treebanks_for_Parsing_with_Quasi-synchronous_Grammars.html">87 acl-2012-Exploiting Multiple Treebanks for Parsing with Quasi-synchronous Grammars</a></p>
<p>10 0.11685137 <a title="175-tfidf-10" href="./acl-2012-Attacking_Parsing_Bottlenecks_with_Unlabeled_Data_and_Relevant_Factorizations.html">30 acl-2012-Attacking Parsing Bottlenecks with Unlabeled Data and Relevant Factorizations</a></p>
<p>11 0.10441691 <a title="175-tfidf-11" href="./acl-2012-Cross-lingual_Parse_Disambiguation_based_on_Semantic_Correspondence.html">63 acl-2012-Cross-lingual Parse Disambiguation based on Semantic Correspondence</a></p>
<p>12 0.099384949 <a title="175-tfidf-12" href="./acl-2012-Fast_Syntactic_Analysis_for_Statistical_Language_Modeling_via_Substructure_Sharing_and_Uptraining.html">95 acl-2012-Fast Syntactic Analysis for Statistical Language Modeling via Substructure Sharing and Uptraining</a></p>
<p>13 0.091334663 <a title="175-tfidf-13" href="./acl-2012-Large-Scale_Syntactic_Language_Modeling_with_Treelets.html">127 acl-2012-Large-Scale Syntactic Language Modeling with Treelets</a></p>
<p>14 0.091093272 <a title="175-tfidf-14" href="./acl-2012-A_Comparative_Study_of_Target_Dependency_Structures_for_Statistical_Machine_Translation.html">4 acl-2012-A Comparative Study of Target Dependency Structures for Statistical Machine Translation</a></p>
<p>15 0.09091758 <a title="175-tfidf-15" href="./acl-2012-Tense_and_Aspect_Error_Correction_for_ESL_Learners_Using_Global_Context.html">192 acl-2012-Tense and Aspect Error Correction for ESL Learners Using Global Context</a></p>
<p>16 0.090433933 <a title="175-tfidf-16" href="./acl-2012-Discriminative_Strategies_to_Integrate_Multiword_Expression_Recognition_and_Parsing.html">75 acl-2012-Discriminative Strategies to Integrate Multiword Expression Recognition and Parsing</a></p>
<p>17 0.08316122 <a title="175-tfidf-17" href="./acl-2012-Grammar_Error_Correction_Using_Pseudo-Error_Sentences_and_Domain_Adaptation.html">103 acl-2012-Grammar Error Correction Using Pseudo-Error Sentences and Domain Adaptation</a></p>
<p>18 0.081234522 <a title="175-tfidf-18" href="./acl-2012-Prediction_of_Learning_Curves_in_Machine_Translation.html">163 acl-2012-Prediction of Learning Curves in Machine Translation</a></p>
<p>19 0.075742535 <a title="175-tfidf-19" href="./acl-2012-Error_Mining_on_Dependency_Trees.html">83 acl-2012-Error Mining on Dependency Trees</a></p>
<p>20 0.075566076 <a title="175-tfidf-20" href="./acl-2012-Capturing_Paradigmatic_and_Syntagmatic_Lexical_Relations%3A_Towards_Accurate_Chinese_Part-of-Speech_Tagging.html">45 acl-2012-Capturing Paradigmatic and Syntagmatic Lexical Relations: Towards Accurate Chinese Part-of-Speech Tagging</a></p>
<br/>
<h2>similar papers computed by <a title="lsi-model" href="../home/acl2012_lsi.html">lsi model</a></h2><h3>lsi for this paper:</h3><p>topicId topicWeight</p>
<p>[(0, -0.217), (1, 0.002), (2, -0.194), (3, -0.122), (4, -0.063), (5, -0.041), (6, 0.033), (7, -0.056), (8, 0.045), (9, -0.016), (10, 0.06), (11, 0.092), (12, -0.001), (13, 0.079), (14, 0.006), (15, 0.001), (16, 0.028), (17, -0.051), (18, -0.106), (19, -0.058), (20, -0.106), (21, -0.106), (22, 0.055), (23, -0.037), (24, 0.061), (25, -0.049), (26, 0.046), (27, 0.023), (28, 0.057), (29, 0.034), (30, -0.01), (31, 0.013), (32, -0.036), (33, 0.009), (34, -0.036), (35, -0.014), (36, 0.019), (37, -0.032), (38, -0.053), (39, -0.033), (40, 0.035), (41, 0.0), (42, 0.022), (43, -0.068), (44, -0.035), (45, -0.128), (46, 0.046), (47, 0.044), (48, -0.016), (49, 0.017)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 0.95925653 <a title="175-lsi-1" href="./acl-2012-Semi-supervised_Dependency_Parsing_using_Lexical_Affinities.html">175 acl-2012-Semi-supervised Dependency Parsing using Lexical Affinities</a></p>
<p>Author: Seyed Abolghasem Mirroshandel ; Alexis Nasr ; Joseph Le Roux</p><p>Abstract: Treebanks are not large enough to reliably model precise lexical phenomena. This deficiency provokes attachment errors in the parsers trained on such data. We propose in this paper to compute lexical affinities, on large corpora, for specific lexico-syntactic configurations that are hard to disambiguate and introduce the new information in a parser. Experiments on the French Treebank showed a relative decrease ofthe error rate of 7. 1% Labeled Accuracy Score yielding the best parsing results on this treebank.</p><p>2 0.77017403 <a title="175-lsi-2" href="./acl-2012-Attacking_Parsing_Bottlenecks_with_Unlabeled_Data_and_Relevant_Factorizations.html">30 acl-2012-Attacking Parsing Bottlenecks with Unlabeled Data and Relevant Factorizations</a></p>
<p>Author: Emily Pitler</p><p>Abstract: Prepositions and conjunctions are two of the largest remaining bottlenecks in parsing. Across various existing parsers, these two categories have the lowest accuracies, and mistakes made have consequences for downstream applications. Prepositions and conjunctions are often assumed to depend on lexical dependencies for correct resolution. As lexical statistics based on the training set only are sparse, unlabeled data can help ameliorate this sparsity problem. By including unlabeled data features into a factorization of the problem which matches the representation of prepositions and conjunctions, we achieve a new state-of-the-art for English dependencies with 93.55% correct attachments on the current standard. Furthermore, conjunctions are attached with an accuracy of 90.8%, and prepositions with an accuracy of 87.4%.</p><p>3 0.69499886 <a title="175-lsi-3" href="./acl-2012-Discriminative_Strategies_to_Integrate_Multiword_Expression_Recognition_and_Parsing.html">75 acl-2012-Discriminative Strategies to Integrate Multiword Expression Recognition and Parsing</a></p>
<p>Author: Matthieu Constant ; Anthony Sigogne ; Patrick Watrin</p><p>Abstract: and Parsing Anthony Sigogne Universit e´ Paris-Est LIGM, CNRS France s igogne @univ-mlv . fr Patrick Watrin Universit e´ de Louvain CENTAL Belgium pat rick .wat rin @ ucl ouvain .be view, their incorporation has also been considered The integration of multiword expressions in a parsing procedure has been shown to improve accuracy in an artificial context where such expressions have been perfectly pre-identified. This paper evaluates two empirical strategies to integrate multiword units in a real constituency parsing context and shows that the results are not as promising as has sometimes been suggested. Firstly, we show that pregrouping multiword expressions before parsing with a state-of-the-art recognizer improves multiword recognition accuracy and unlabeled attachment score. However, it has no statistically significant impact in terms of F-score as incorrect multiword expression recognition has important side effects on parsing. Secondly, integrating multiword expressions in the parser grammar followed by a reranker specific to such expressions slightly improves all evaluation metrics.</p><p>4 0.67836475 <a title="175-lsi-4" href="./acl-2012-Utilizing_Dependency_Language_Models_for_Graph-based_Dependency_Parsing_Models.html">213 acl-2012-Utilizing Dependency Language Models for Graph-based Dependency Parsing Models</a></p>
<p>Author: Wenliang Chen ; Min Zhang ; Haizhou Li</p><p>Abstract: Most previous graph-based parsing models increase decoding complexity when they use high-order features due to exact-inference decoding. In this paper, we present an approach to enriching high-orderfeature representations for graph-based dependency parsing models using a dependency language model and beam search. The dependency language model is built on a large-amount of additional autoparsed data that is processed by a baseline parser. Based on the dependency language model, we represent a set of features for the parsing model. Finally, the features are efficiently integrated into the parsing model during decoding using beam search. Our approach has two advantages. Firstly we utilize rich high-order features defined over a view of large scope and additional large raw corpus. Secondly our approach does not increase the decoding complexity. We evaluate the proposed approach on English and Chinese data. The experimental results show that our new parser achieves the best accuracy on the Chinese data and comparable accuracy with the best known systems on the English data.</p><p>5 0.67327493 <a title="175-lsi-5" href="./acl-2012-Exploiting_Multiple_Treebanks_for_Parsing_with_Quasi-synchronous_Grammars.html">87 acl-2012-Exploiting Multiple Treebanks for Parsing with Quasi-synchronous Grammars</a></p>
<p>Author: Zhenghua Li ; Ting Liu ; Wanxiang Che</p><p>Abstract: We present a simple and effective framework for exploiting multiple monolingual treebanks with different annotation guidelines for parsing. Several types of transformation patterns (TP) are designed to capture the systematic annotation inconsistencies among different treebanks. Based on such TPs, we design quasisynchronous grammar features to augment the baseline parsing models. Our approach can significantly advance the state-of-the-art parsing accuracy on two widely used target treebanks (Penn Chinese Treebank 5. 1 and 6.0) using the Chinese Dependency Treebank as the source treebank. The improvements are respectively 1.37% and 1.10% with automatic part-of-speech tags. Moreover, an indirect comparison indicates that our approach also outperforms previous work based on treebank conversion.</p><p>6 0.66836864 <a title="175-lsi-6" href="./acl-2012-Joint_Evaluation_of_Morphological_Segmentation_and_Syntactic_Parsing.html">122 acl-2012-Joint Evaluation of Morphological Segmentation and Syntactic Parsing</a></p>
<p>7 0.66724902 <a title="175-lsi-7" href="./acl-2012-Head-driven_Transition-based_Parsing_with_Top-down_Prediction.html">106 acl-2012-Head-driven Transition-based Parsing with Top-down Prediction</a></p>
<p>8 0.65408599 <a title="175-lsi-8" href="./acl-2012-A_Comparison_of_Chinese_Parsers_for_Stanford_Dependencies.html">5 acl-2012-A Comparison of Chinese Parsers for Stanford Dependencies</a></p>
<p>9 0.65204459 <a title="175-lsi-9" href="./acl-2012-Dependency_Hashing_for_n-best_CCG_Parsing.html">71 acl-2012-Dependency Hashing for n-best CCG Parsing</a></p>
<p>10 0.64007747 <a title="175-lsi-10" href="./acl-2012-Higher-order_Constituent_Parsing_and_Parser_Combination.html">109 acl-2012-Higher-order Constituent Parsing and Parser Combination</a></p>
<p>11 0.63083118 <a title="175-lsi-11" href="./acl-2012-Error_Mining_on_Dependency_Trees.html">83 acl-2012-Error Mining on Dependency Trees</a></p>
<p>12 0.60361218 <a title="175-lsi-12" href="./acl-2012-A_Comparative_Study_of_Target_Dependency_Structures_for_Statistical_Machine_Translation.html">4 acl-2012-A Comparative Study of Target Dependency Structures for Statistical Machine Translation</a></p>
<p>13 0.60181767 <a title="175-lsi-13" href="./acl-2012-Syntactic_Annotations_for_the_Google_Books_NGram_Corpus.html">189 acl-2012-Syntactic Annotations for the Google Books NGram Corpus</a></p>
<p>14 0.59343278 <a title="175-lsi-14" href="./acl-2012-Selective_Sharing_for_Multilingual_Dependency_Parsing.html">172 acl-2012-Selective Sharing for Multilingual Dependency Parsing</a></p>
<p>15 0.59272569 <a title="175-lsi-15" href="./acl-2012-Cross-lingual_Parse_Disambiguation_based_on_Semantic_Correspondence.html">63 acl-2012-Cross-lingual Parse Disambiguation based on Semantic Correspondence</a></p>
<p>16 0.54835957 <a title="175-lsi-16" href="./acl-2012-Large-Scale_Syntactic_Language_Modeling_with_Treelets.html">127 acl-2012-Large-Scale Syntactic Language Modeling with Treelets</a></p>
<p>17 0.52645856 <a title="175-lsi-17" href="./acl-2012-A_Feature-Rich_Constituent_Context_Model_for_Grammar_Induction.html">11 acl-2012-A Feature-Rich Constituent Context Model for Grammar Induction</a></p>
<p>18 0.52364451 <a title="175-lsi-18" href="./acl-2012-Fast_Syntactic_Analysis_for_Statistical_Language_Modeling_via_Substructure_Sharing_and_Uptraining.html">95 acl-2012-Fast Syntactic Analysis for Statistical Language Modeling via Substructure Sharing and Uptraining</a></p>
<p>19 0.48980492 <a title="175-lsi-19" href="./acl-2012-Extracting_Narrative_Timelines_as_Temporal_Dependency_Structures.html">90 acl-2012-Extracting Narrative Timelines as Temporal Dependency Structures</a></p>
<p>20 0.48214722 <a title="175-lsi-20" href="./acl-2012-Robust_Conversion_of_CCG_Derivations_to_Phrase_Structure_Trees.html">170 acl-2012-Robust Conversion of CCG Derivations to Phrase Structure Trees</a></p>
<br/>
<h2>similar papers computed by <a title="lda-model" href="../home/acl2012_lda.html">lda model</a></h2><h3>lda for this paper:</h3><p>topicId topicWeight</p>
<p>[(16, 0.265), (25, 0.019), (26, 0.053), (28, 0.044), (30, 0.054), (37, 0.061), (39, 0.052), (59, 0.016), (71, 0.013), (74, 0.057), (82, 0.016), (84, 0.026), (85, 0.036), (90, 0.095), (92, 0.055), (94, 0.016), (99, 0.05)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 0.74033439 <a title="175-lda-1" href="./acl-2012-Semi-supervised_Dependency_Parsing_using_Lexical_Affinities.html">175 acl-2012-Semi-supervised Dependency Parsing using Lexical Affinities</a></p>
<p>Author: Seyed Abolghasem Mirroshandel ; Alexis Nasr ; Joseph Le Roux</p><p>Abstract: Treebanks are not large enough to reliably model precise lexical phenomena. This deficiency provokes attachment errors in the parsers trained on such data. We propose in this paper to compute lexical affinities, on large corpora, for specific lexico-syntactic configurations that are hard to disambiguate and introduce the new information in a parser. Experiments on the French Treebank showed a relative decrease ofthe error rate of 7. 1% Labeled Accuracy Score yielding the best parsing results on this treebank.</p><p>2 0.70671088 <a title="175-lda-2" href="./acl-2012-Assessing_the_Effect_of_Inconsistent_Assessors_on_Summarization_Evaluation.html">29 acl-2012-Assessing the Effect of Inconsistent Assessors on Summarization Evaluation</a></p>
<p>Author: Karolina Owczarzak ; Peter A. Rankel ; Hoa Trang Dang ; John M. Conroy</p><p>Abstract: We investigate the consistency of human assessors involved in summarization evaluation to understand its effect on system ranking and automatic evaluation techniques. Using Text Analysis Conference data, we measure annotator consistency based on human scoring of summaries for Responsiveness, Readability, and Pyramid scoring. We identify inconsistencies in the data and measure to what extent these inconsistencies affect the ranking of automatic summarization systems. Finally, we examine the stability of automatic metrics (ROUGE and CLASSY) with respect to the inconsistent assessments.</p><p>3 0.50963873 <a title="175-lda-3" href="./acl-2012-Verb_Classification_using_Distributional_Similarity_in_Syntactic_and_Semantic_Structures.html">214 acl-2012-Verb Classification using Distributional Similarity in Syntactic and Semantic Structures</a></p>
<p>Author: Danilo Croce ; Alessandro Moschitti ; Roberto Basili ; Martha Palmer</p><p>Abstract: In this paper, we propose innovative representations for automatic classification of verbs according to mainstream linguistic theories, namely VerbNet and FrameNet. First, syntactic and semantic structures capturing essential lexical and syntactic properties of verbs are defined. Then, we design advanced similarity functions between such structures, i.e., semantic tree kernel functions, for exploiting distributional and grammatical information in Support Vector Machines. The extensive empirical analysis on VerbNet class and frame detection shows that our models capture mean- ingful syntactic/semantic structures, which allows for improving the state-of-the-art.</p><p>4 0.50521493 <a title="175-lda-4" href="./acl-2012-Efficient_Tree-based_Approximation_for_Entailment_Graph_Learning.html">80 acl-2012-Efficient Tree-based Approximation for Entailment Graph Learning</a></p>
<p>Author: Jonathan Berant ; Ido Dagan ; Meni Adler ; Jacob Goldberger</p><p>Abstract: Learning entailment rules is fundamental in many semantic-inference applications and has been an active field of research in recent years. In this paper we address the problem of learning transitive graphs that describe entailment rules between predicates (termed entailment graphs). We first identify that entailment graphs exhibit a “tree-like” property and are very similar to a novel type of graph termed forest-reducible graph. We utilize this property to develop an iterative efficient approximation algorithm for learning the graph edges, where each iteration takes linear time. We compare our approximation algorithm to a recently-proposed state-of-the-art exact algorithm and show that it is more efficient and scalable both theoretically and empirically, while its output quality is close to that given by the optimal solution of the exact algorithm.</p><p>5 0.50119865 <a title="175-lda-5" href="./acl-2012-Learning_Syntactic_Verb_Frames_using_Graphical_Models.html">130 acl-2012-Learning Syntactic Verb Frames using Graphical Models</a></p>
<p>Author: Thomas Lippincott ; Anna Korhonen ; Diarmuid O Seaghdha</p><p>Abstract: We present a novel approach for verb subcategorization lexicons using a simple graphical model. In contrast to previous methods, we show how the model can be trained without parsed input or a predefined subcategorization frame inventory. Our method outperforms the state-of-the-art on a verb clustering task, and is easily trained on arbitrary domains. This quantitative evaluation is com- plemented by a qualitative discussion of verbs and their frames. We discuss the advantages of graphical models for this task, in particular the ease of integrating semantic information about verbs and arguments in a principled fashion. We conclude with future work to augment the approach.</p><p>6 0.50069982 <a title="175-lda-6" href="./acl-2012-Semantic_Parsing_with_Bayesian_Tree_Transducers.html">174 acl-2012-Semantic Parsing with Bayesian Tree Transducers</a></p>
<p>7 0.4999924 <a title="175-lda-7" href="./acl-2012-Cross-lingual_Parse_Disambiguation_based_on_Semantic_Correspondence.html">63 acl-2012-Cross-lingual Parse Disambiguation based on Semantic Correspondence</a></p>
<p>8 0.49958032 <a title="175-lda-8" href="./acl-2012-Modified_Distortion_Matrices_for_Phrase-Based_Statistical_Machine_Translation.html">148 acl-2012-Modified Distortion Matrices for Phrase-Based Statistical Machine Translation</a></p>
<p>9 0.49580035 <a title="175-lda-9" href="./acl-2012-Discriminative_Strategies_to_Integrate_Multiword_Expression_Recognition_and_Parsing.html">75 acl-2012-Discriminative Strategies to Integrate Multiword Expression Recognition and Parsing</a></p>
<p>10 0.4954572 <a title="175-lda-10" href="./acl-2012-Detecting_Semantic_Equivalence_and_Information_Disparity_in_Cross-lingual_Documents.html">72 acl-2012-Detecting Semantic Equivalence and Information Disparity in Cross-lingual Documents</a></p>
<p>11 0.49504939 <a title="175-lda-11" href="./acl-2012-UWN%3A_A_Large_Multilingual_Lexical_Knowledge_Base.html">206 acl-2012-UWN: A Large Multilingual Lexical Knowledge Base</a></p>
<p>12 0.49457276 <a title="175-lda-12" href="./acl-2012-String_Re-writing_Kernel.html">184 acl-2012-String Re-writing Kernel</a></p>
<p>13 0.49453136 <a title="175-lda-13" href="./acl-2012-Modeling_Topic_Dependencies_in_Hierarchical_Text_Categorization.html">146 acl-2012-Modeling Topic Dependencies in Hierarchical Text Categorization</a></p>
<p>14 0.49217558 <a title="175-lda-14" href="./acl-2012-Error_Mining_on_Dependency_Trees.html">83 acl-2012-Error Mining on Dependency Trees</a></p>
<p>15 0.49195397 <a title="175-lda-15" href="./acl-2012-Estimating_Compact_Yet_Rich_Tree_Insertion_Grammars.html">84 acl-2012-Estimating Compact Yet Rich Tree Insertion Grammars</a></p>
<p>16 0.49153453 <a title="175-lda-16" href="./acl-2012-langid.py%3A_An_Off-the-shelf_Language_Identification_Tool.html">219 acl-2012-langid.py: An Off-the-shelf Language Identification Tool</a></p>
<p>17 0.49006477 <a title="175-lda-17" href="./acl-2012-Joint_Feature_Selection_in_Distributed_Stochastic_Learning_for_Large-Scale_Discriminative_Training_in_SMT.html">123 acl-2012-Joint Feature Selection in Distributed Stochastic Learning for Large-Scale Discriminative Training in SMT</a></p>
<p>18 0.48948488 <a title="175-lda-18" href="./acl-2012-Temporally_Anchored_Relation_Extraction.html">191 acl-2012-Temporally Anchored Relation Extraction</a></p>
<p>19 0.4894039 <a title="175-lda-19" href="./acl-2012-Learning_to_Translate_with_Multiple_Objectives.html">136 acl-2012-Learning to Translate with Multiple Objectives</a></p>
<p>20 0.48935097 <a title="175-lda-20" href="./acl-2012-Ecological_Evaluation_of_Persuasive_Messages_Using_Google_AdWords.html">77 acl-2012-Ecological Evaluation of Persuasive Messages Using Google AdWords</a></p>
<br/><br/><br/>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-48522588-1', 'makerhacker.github.io');
ga('send', 'pageview');
</script>

</body>
</html>
