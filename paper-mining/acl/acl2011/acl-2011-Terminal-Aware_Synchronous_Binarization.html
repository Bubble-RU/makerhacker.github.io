<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>296 acl-2011-Terminal-Aware Synchronous Binarization</title>
</head>

<body>
<p><a title="acl" href="../acl_home.html">acl</a> <a title="acl-2011" href="../home/acl2011_home.html">acl2011</a> <a title="acl-2011-296" href="#">acl2011-296</a> knowledge-graph by maker-knowledge-mining</p><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- maker adsense -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-5027806277543591"
     data-ad-slot="4192012269"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>296 acl-2011-Terminal-Aware Synchronous Binarization</h1>
<br/><p>Source: <a title="acl-2011-296-pdf" href="http://aclweb.org/anthology//P/P11/P11-2070.pdf">pdf</a></p><p>Author: Licheng Fang ; Tagyoung Chung ; Daniel Gildea</p><p>Abstract: We present an SCFG binarization algorithm that combines the strengths of early terminal matching on the source language side and early language model integration on the target language side. We also examine how different strategies of target-side terminal attachment during binarization can significantly affect translation quality.</p><p>Reference: <a title="acl-2011-296-reference" href="../acl2011_reference/acl-2011-Terminal-Aware_Synchronous_Binarization_reference.html">text</a></p><br/><h2>Summary: the most important sentenses genereted by tfidf model</h2><p>sentIndex sentText sentNum sentScore</p><p>1 We also examine how different strategies of target-side terminal attachment during binarization can significantly affect translation quality. [sent-2, score-0.882]
</p><p>2 1 Introduction Synchronous context-free grammars (SCFG) are behind most syntax-based machine translation models. [sent-3, score-0.031]
</p><p>3 Efficient machine translation decoding with an SCFG requires converting the grammar into a binarized form, either explicitly, as in synchronous binarization (Zhang et al. [sent-4, score-1.139]
</p><p>4 , 2006), where virtual nonterminals are generated for binarization, or implicitly, as in Earley parsing (Earley, 1970), where dotted items are used. [sent-5, score-0.267]
</p><p>5 Given a source-side binarized SCFG with terminal set T and nonterminal set N, the time complexity ofdecoding a sentence oflength n w tiimthe a m-gram language model is (Venugopal et al. [sent-6, score-0.448]
</p><p>6 SCFG binarization serves two important goals: •  •  Parsing complexity for unbinarized SCFG grows exponentially w foitrh tuhneb innuamrizbeedr o Sf nonterminals on the right-hand side of grammar rules. [sent-8, score-0.947]
</p><p>7 Binarization ensures cubic time decoding in terms of input sentence length. [sent-9, score-0.095]
</p><p>8 401 In machine translation, integrating language Imno dmela cshtiatnees as early as possible i sn gess leanntgiuala gtoe reducing search errors. [sent-10, score-0.091]
</p><p>9 , 2006) enables the decoder to incorporate language model scores as soon as a binarized rule is applied. [sent-12, score-0.362]
</p><p>10 In this paper, we examine a CYK-like synchronous binarization algorithm that integrates a novel criterion in a unified semiring parsing framework. [sent-13, score-1.107]
</p><p>11 The criterion we present has explicit consideration of source-side terminals. [sent-14, score-0.027]
</p><p>12 In general, terminals in a rule have a lower probability of being matched given a sentence, and therefore have the effect of “anchoring” a rule and limiting its possible application points. [sent-15, score-0.402]
</p><p>13 Hopkins and Langmead (2010) formalized this concept as the scope of a rule. [sent-16, score-0.087]
</p><p>14 The scope of a rule can be calculated by counting the number of adjacent nonterminal pairs and boundary nonterminals. [sent-18, score-0.352]
</p><p>15 Building on the concept of scope, we define a cost function that estimates the expected number of hyperedges to be built when a particular binarization tree is applied to unseen data. [sent-20, score-1.091]
</p><p>16 This effectively puts hard-to-match derivations at the bottom of the binarization tree, which enables the decoder to decide early on whether an unbinarized rule  can be built or not. [sent-21, score-1.067]
</p><p>17 We also investigate a better way to handle targetside terminals during binarization. [sent-22, score-0.167]
</p><p>18 In theory, different strategies should produce equivalent translation results. [sent-23, score-0.066]
</p><p>19 However, because decoding always involves Proceedings ofP thoer t4l9atnhd A, Onrnuegaoln M,e Jeuntineg 19 o-f2 t4h,e 2 A0s1s1o. [sent-24, score-0.049]
</p><p>20 i ac t2io0n11 fo Ar Cssoocmiaptuiotanti foonra Clo Lminpguutiast i ocns:aslh Loirntpgaupisetrics , pages 401–406,  Number of rgiht-hand-sdie  nontermniasl  Figure 1: Rule Statistics pruning, we show that different strategies do have a significant effect in translation quality. [sent-26, score-0.066]
</p><p>21 Other works investigating alternative binarization  methods mostly focus on the effect of nonterminal sharing. [sent-27, score-0.902]
</p><p>22 (2009) also proposed a CYKlike algorithm for synchronous binarization. [sent-29, score-0.183]
</p><p>23 Apparently the lack of virtual nonterminal sharing in their decoder caused heavy competition between virtual nonterminals, and they created a cost function to “diversify” binarization trees, which is equivalent to minimizing nonterminal sharing. [sent-30, score-1.666]
</p><p>24 (2009b) used a greedy method to maximize virtual nonterminal sharing on the source side during the -LM parsing phase. [sent-32, score-0.474]
</p><p>25 They show that effective source-side binarization can improve the efficiency of parsing SCFG. [sent-33, score-0.767]
</p><p>26 However, their method works only on the source side, and synchronous binarization is put off to the +LM decoding phase (DeNero et al. [sent-34, score-0.974]
</p><p>27 Although these ideas all lead to faster decoding and reduced search errors, there can be conflicts in the constraints each of them has on the form of rules and accommodating all of them can be a challenge. [sent-36, score-0.132]
</p><p>28 In this paper, we present a cubic time algorithm to find the best binarization tree, given the conflicting constraints. [sent-37, score-0.801]
</p><p>29 2  The Binarization Algorithm  An SCFG rule is synchronously binarizable if when simultaneously binarizing source and target sides, virtual nonterminals created by binarizations always have contiguous spans on both sides (Huang, 2007). [sent-38, score-0.859]
</p><p>30 Tj [−k, 1j ]d +o c(hi, k, ji) Tt [←i, j T] ←i,k m] +in( TT[k[i,, j ]] ,+ +t) c T[i,j]  ←  min(T[i,j],t)  Even with the synchronous binarization constraint, many possible binarizations exist. [sent-60, score-0.948]
</p><p>31 Analysis of our Chinese-English parallel corpus has shown that the majority of synchronously binarizable rules with arity smaller than 4 are monotonic, i. [sent-61, score-0.384]
</p><p>32 , the target-side  nonterminal permutation is either strictly increasing or decreasing (See Figure 1). [sent-63, score-0.17]
</p><p>33 For monotonic rules, any source-side binarization is also a permissible synchronous binarization. [sent-64, score-1.014]
</p><p>34 The binarization problem can be formulated as a semiring parsing (Goodman, 1999) problem. [sent-65, score-0.863]
</p><p>35 We define a cost function that considers different binarization criteria. [sent-66, score-0.928]
</p><p>36 A CYK-like algorithm can be used to find the best binarization tree according to the cost function. [sent-67, score-0.99]
</p><p>37 Consider an SCFG rule X → hγ, αi, wcohsetre fu γ atniodn α Cstoannsdid feorr atnhe S source slied eX a n→d t hhγe, tαari-, get side. [sent-68, score-0.211]
</p><p>38 Let B(γ) be the set of all possible binarization trees for γ. [sent-69, score-0.732]
</p><p>39 With the cost function c defined over hyperedges in a binarization tree t, the optimal binarization tree is  tˆ  ˆt = at∈rgBm(γin)Xc(h) where c(h) is the cost of a hyperedge h in t. [sent-70, score-2.156]
</p><p>40 hi, k, ji denotes a hyperedge h that conngeorctisth tmhe 1 spans (i, k) naontde (k, j) etroe tdhgee span (i, j). [sent-72, score-0.31]
</p><p>41 cinit is the initialization for the cost function c. [sent-73, score-0.196]
</p><p>42 We can recover the optimal source-side binarization tree  by augmenting the algorithm with back pointers. [sent-74, score-0.846]
</p><p>43 Binarized rules are generated by iterating over the nodes in the optimal binarization tree, while attaching unaligned target-side terminals. [sent-75, score-0.785]
</p><p>44 At each tree node, we generate a virtual nonterminal symbol by concatenating the source span it dominates. [sent-76, score-0.514]
</p><p>45 We define the cost function c(h) to be a tuple of component cost functions: c(h) = (c1(h) , c2 (h) , . [sent-77, score-0.41]
</p><p>46 If the (min, +) operators on each component cost satisfy the semiring properties, the cost tuple is also a semiring. [sent-86, score-0.517]
</p><p>47 Next, we describe our cost functions and how we handle target-side terminals. [sent-87, score-0.168]
</p><p>48 1 Synchronous Binarization as a Cost We use a binary cost b to indicate whether a binarization tree is a permissible synchronous binarization. [sent-89, score-1.206]
</p><p>49 Given a hyperedge hi, k, ji,we say k is apermissible split nofa thhyep span (i, j) i,fj ain, dw only ikf tishea spans (i, k) and (k, j) are both synchronously binarizable and the span (i, j) covers a consecutive sequence of non-  terminals on the target side. [sent-90, score-0.918]
</p><p>50 A span is synchronously binarizable if and only if the span is of length one, or a permissible split of the span exists. [sent-91, score-0.707]
</p><p>51 The cost b is defined as:  VP →  [ pPrPop [o提se出 a [ J J N NNN]]1 ]2]2P,P  The source side of the first binarized rule “[]1 → JJ NN, propose a JJ NN” contains a very frequent nonterminal sequence “JJ NN”. [sent-92, score-0.707]
</p><p>52 If one were to parse with the binarized rule, and if the virtual nonterminal [] 1 has been built, the parser needs to continue following the binarization tree in order to determine whether the original rule would be matched. [sent-93, score-1.405]
</p><p>53 Furthermore, having two consecutive nonterminals adds to complexity since the parser needs to test each split point. [sent-94, score-0.158]
</p><p>54 The following binarization is equally valid but integrates terminals early:  VP →  [ pPrPop [ o提se出 a J J ] 1 NNNN]]2 P,P  Here, the first binarized rule “[]1 → 提 出 JJ, propose a JJ” anchors on a terminal and enables earlier  pruning of the original rule. [sent-95, score-1.362]
</p><p>55 ewsThtanhtuibsmi nsbaer eiazolafitz heoydn-  binit(i) = T  Under this configuration, the semiring operators (min, +) defined for the cost b are (∨, ∧). [sent-98, score-0.303]
</p><p>56 Using b as t(mhei nfir,s+t )co dsetf finuendct fioorn t hine tchoes ct bo astr feu (n∨c,ti∧o)n. [sent-99, score-0.051]
</p><p>57 tuple guarantees that we will find a tree that is a synchronously binarized if one exists. [sent-100, score-0.432]
</p><p>58 2 Early Source-Side Terminal Matching When a rule is being applied while parsing a sentence, terminals in the rule have less chance of being matched. [sent-102, score-0.41]
</p><p>59 We can exploit this fact by taking terminals into account during binarization and placing terminals lower in the binarization tree. [sent-103, score-1.742]
</p><p>60 Consider the following SCFG rule:  VP →  prPoPpo 提se出 a J J J N NNN P,P  The synchronous binarization algorithm of Zhang et al. [sent-104, score-0.915]
</p><p>61 (2006) binarizes the rule1 by finding the rightmost binarizable points on the source side:  1We follow Wu (1997) and use square brackets for straight rules and pointed brackets for inverted rules. [sent-105, score-0.373]
</p><p>62 We also mark brackets with indices to represent virtual nonterminals. [sent-106, score-0.205]
</p><p>63 403 by defining a cost function e which estimates the probability of a hyperedge hi, k, ji being built. [sent-107, score-0.398]
</p><p>64 We use a simple fm ao hdyepl:e assume eka,cjhi t bereminign balu or nonterminal in γ is matched independently with a fixed probability, then a hyperedge hi, k, ji is derived if apnrodb only tyif, a tlhl symbols eirne dthgee source span (i, j) are matched. [sent-108, score-0.562]
</p>
<br/>
<h2>similar papers computed by tfidf model</h2><h3>tfidf for this paper:</h3><p>wordName wordTfidf (topN-words)</p>
<p>[('binarization', 0.732), ('scfg', 0.188), ('binarizable', 0.173), ('nonterminal', 0.17), ('cost', 0.168), ('binarized', 0.167), ('synchronous', 0.16), ('synchronously', 0.152), ('virtual', 0.151), ('terminals', 0.139), ('hyperedge', 0.12), ('rule', 0.118), ('semiring', 0.096), ('span', 0.093), ('terminal', 0.084), ('nonterminals', 0.081), ('hi', 0.081), ('permissible', 0.079), ('jj', 0.074), ('pprpop', 0.069), ('tree', 0.067), ('scope', 0.064), ('nnn', 0.061), ('early', 0.061), ('ji', 0.059), ('binarizations', 0.056), ('unbinarized', 0.056), ('brackets', 0.054), ('side', 0.051), ('hyperedges', 0.05), ('decoding', 0.049), ('earley', 0.048), ('cubic', 0.046), ('tuple', 0.046), ('monotonic', 0.043), ('vp', 0.039), ('operators', 0.039), ('enables', 0.039), ('spans', 0.038), ('decoder', 0.038), ('parsing', 0.035), ('strategies', 0.035), ('nn', 0.035), ('min', 0.034), ('integrates', 0.034), ('denero', 0.034), ('sharing', 0.034), ('source', 0.033), ('rt', 0.033), ('sides', 0.032), ('rochester', 0.031), ('tt', 0.031), ('se', 0.031), ('translation', 0.031), ('feorr', 0.03), ('thhyep', 0.03), ('adl', 0.03), ('mhei', 0.03), ('arity', 0.03), ('orne', 0.03), ('gtoe', 0.03), ('tlhl', 0.03), ('apnrodb', 0.03), ('binarizes', 0.03), ('nofa', 0.03), ('sor', 0.03), ('atnhe', 0.03), ('rules', 0.029), ('targetside', 0.028), ('accommodating', 0.028), ('licheng', 0.028), ('nnnn', 0.028), ('anchoring', 0.028), ('langmead', 0.028), ('fioorn', 0.028), ('function', 0.028), ('complexity', 0.027), ('criterion', 0.027), ('matched', 0.027), ('cin', 0.026), ('conflicts', 0.026), ('diversify', 0.026), ('piecewise', 0.026), ('consecutive', 0.026), ('pruning', 0.025), ('cyk', 0.025), ('binarizing', 0.025), ('tagyoung', 0.024), ('ain', 0.024), ('anchors', 0.024), ('competition', 0.024), ('optimal', 0.024), ('split', 0.024), ('zhang', 0.023), ('formalized', 0.023), ('hine', 0.023), ('rf', 0.023), ('estimates', 0.023), ('algorithm', 0.023), ('built', 0.023)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 1.0000001 <a title="296-tfidf-1" href="./acl-2011-Terminal-Aware_Synchronous_Binarization.html">296 acl-2011-Terminal-Aware Synchronous Binarization</a></p>
<p>Author: Licheng Fang ; Tagyoung Chung ; Daniel Gildea</p><p>Abstract: We present an SCFG binarization algorithm that combines the strengths of early terminal matching on the source language side and early language model integration on the target language side. We also examine how different strategies of target-side terminal attachment during binarization can significantly affect translation quality.</p><p>2 0.59763145 <a title="296-tfidf-2" href="./acl-2011-Binarized_Forest_to_String_Translation.html">61 acl-2011-Binarized Forest to String Translation</a></p>
<p>Author: Hao Zhang ; Licheng Fang ; Peng Xu ; Xiaoyun Wu</p><p>Abstract: Tree-to-string translation is syntax-aware and efficient but sensitive to parsing errors. Forestto-string translation approaches mitigate the risk of propagating parser errors into translation errors by considering a forest of alternative trees, as generated by a source language parser. We propose an alternative approach to generating forests that is based on combining sub-trees within the first best parse through binarization. Provably, our binarization forest can cover any non-consitituent phrases in a sentence but maintains the desirable property that for each span there is at most one nonterminal so that the grammar constant for decoding is relatively small. For the purpose of reducing search errors, we apply the synchronous binarization technique to forest-tostring decoding. Combining the two techniques, we show that using a fast shift-reduce parser we can achieve significant quality gains in NIST 2008 English-to-Chinese track (1.3 BLEU points over a phrase-based system, 0.8 BLEU points over a hierarchical phrase-based system). Consistent and significant gains are also shown in WMT 2010 in the English to German, French, Spanish and Czech tracks.</p><p>3 0.27823117 <a title="296-tfidf-3" href="./acl-2011-Issues_Concerning_Decoding_with_Synchronous_Context-free_Grammar.html">180 acl-2011-Issues Concerning Decoding with Synchronous Context-free Grammar</a></p>
<p>Author: Tagyoung Chung ; Licheng Fang ; Daniel Gildea</p><p>Abstract: We discuss some of the practical issues that arise from decoding with general synchronous context-free grammars. We examine problems caused by unary rules and we also examine how virtual nonterminals resulting from binarization can best be handled. We also investigate adding more flexibility to synchronous context-free grammars by adding glue rules and phrases.</p><p>4 0.18778372 <a title="296-tfidf-4" href="./acl-2011-Learning_to_Transform_and_Select_Elementary_Trees_for_Improved_Syntax-based_Machine_Translations.html">206 acl-2011-Learning to Transform and Select Elementary Trees for Improved Syntax-based Machine Translations</a></p>
<p>Author: Bing Zhao ; Young-Suk Lee ; Xiaoqiang Luo ; Liu Li</p><p>Abstract: We propose a novel technique of learning how to transform the source parse trees to improve the translation qualities of syntax-based translation models using synchronous context-free grammars. We transform the source tree phrasal structure into a set of simpler structures, expose such decisions to the decoding process, and find the least expensive transformation operation to better model word reordering. In particular, we integrate synchronous binarizations, verb regrouping, removal of redundant parse nodes, and incorporate a few important features such as translation boundaries. We learn the structural preferences from the data in a generative framework. The syntax-based translation system integrating the proposed techniques outperforms the best Arabic-English unconstrained system in NIST08 evaluations by 1.3 absolute BLEU, which is statistically significant.</p><p>5 0.16136278 <a title="296-tfidf-5" href="./acl-2011-Prefix_Probability_for_Probabilistic_Synchronous_Context-Free_Grammars.html">250 acl-2011-Prefix Probability for Probabilistic Synchronous Context-Free Grammars</a></p>
<p>Author: Mark-Jan Nederhof ; Giorgio Satta</p><p>Abstract: We present a method for the computation of prefix probabilities for synchronous contextfree grammars. Our framework is fairly general and relies on the combination of a simple, novel grammar transformation and standard techniques to bring grammars into normal forms.</p><p>6 0.13686644 <a title="296-tfidf-6" href="./acl-2011-Learning_Hierarchical_Translation_Structure_with_Linguistic_Annotations.html">202 acl-2011-Learning Hierarchical Translation Structure with Linguistic Annotations</a></p>
<p>7 0.13660011 <a title="296-tfidf-7" href="./acl-2011-Optimal_Head-Driven_Parsing_Complexity_for_Linear_Context-Free_Rewriting_Systems.html">234 acl-2011-Optimal Head-Driven Parsing Complexity for Linear Context-Free Rewriting Systems</a></p>
<p>8 0.11933178 <a title="296-tfidf-8" href="./acl-2011-A_Word-Class_Approach_to_Labeling_PSCFG_Rules_for_Machine_Translation.html">29 acl-2011-A Word-Class Approach to Labeling PSCFG Rules for Machine Translation</a></p>
<p>9 0.10377447 <a title="296-tfidf-9" href="./acl-2011-Rule_Markov_Models_for_Fast_Tree-to-String_Translation.html">268 acl-2011-Rule Markov Models for Fast Tree-to-String Translation</a></p>
<p>10 0.099541582 <a title="296-tfidf-10" href="./acl-2011-Prototyping_virtual_instructors_from_human-human_corpora.html">252 acl-2011-Prototyping virtual instructors from human-human corpora</a></p>
<p>11 0.096249767 <a title="296-tfidf-11" href="./acl-2011-Adjoining_Tree-to-String_Translation.html">30 acl-2011-Adjoining Tree-to-String Translation</a></p>
<p>12 0.083980165 <a title="296-tfidf-12" href="./acl-2011-Effective_Use_of_Function_Words_for_Rule_Generalization_in_Forest-Based_Translation.html">110 acl-2011-Effective Use of Function Words for Rule Generalization in Forest-Based Translation</a></p>
<p>13 0.078343861 <a title="296-tfidf-13" href="./acl-2011-Nonparametric_Bayesian_Machine_Transliteration_with_Synchronous_Adaptor_Grammars.html">232 acl-2011-Nonparametric Bayesian Machine Transliteration with Synchronous Adaptor Grammars</a></p>
<p>14 0.070573181 <a title="296-tfidf-14" href="./acl-2011-An_exponential_translation_model_for_target_language_morphology.html">44 acl-2011-An exponential translation model for target language morphology</a></p>
<p>15 0.068822443 <a title="296-tfidf-15" href="./acl-2011-Insertion_Operator_for_Bayesian_Tree_Substitution_Grammars.html">173 acl-2011-Insertion Operator for Bayesian Tree Substitution Grammars</a></p>
<p>16 0.064922817 <a title="296-tfidf-16" href="./acl-2011-Hypothesis_Mixture_Decoding_for_Statistical_Machine_Translation.html">155 acl-2011-Hypothesis Mixture Decoding for Statistical Machine Translation</a></p>
<p>17 0.063290998 <a title="296-tfidf-17" href="./acl-2011-How_to_train_your_multi_bottom-up_tree_transducer.html">154 acl-2011-How to train your multi bottom-up tree transducer</a></p>
<p>18 0.058350511 <a title="296-tfidf-18" href="./acl-2011-Incremental_Syntactic_Language_Models_for_Phrase-based_Translation.html">171 acl-2011-Incremental Syntactic Language Models for Phrase-based Translation</a></p>
<p>19 0.058023352 <a title="296-tfidf-19" href="./acl-2011-Lexicographic_Semirings_for_Exact_Automata_Encoding_of_Sequence_Models.html">210 acl-2011-Lexicographic Semirings for Exact Automata Encoding of Sequence Models</a></p>
<p>20 0.055947497 <a title="296-tfidf-20" href="./acl-2011-Automatic_Extraction_of_Lexico-Syntactic_Patterns_for_Detection_of_Negation_and_Speculation_Scopes.html">50 acl-2011-Automatic Extraction of Lexico-Syntactic Patterns for Detection of Negation and Speculation Scopes</a></p>
<br/>
<h2>similar papers computed by <a title="lsi-model" href="../home/acl2011_lsi.html">lsi model</a></h2><h3>lsi for this paper:</h3><p>topicId topicWeight</p>
<p>[(0, 0.131), (1, -0.17), (2, 0.084), (3, -0.099), (4, 0.022), (5, 0.02), (6, -0.286), (7, -0.071), (8, -0.093), (9, -0.105), (10, -0.107), (11, -0.053), (12, -0.009), (13, 0.115), (14, 0.103), (15, -0.102), (16, 0.005), (17, 0.08), (18, 0.041), (19, 0.024), (20, -0.037), (21, -0.067), (22, -0.081), (23, 0.035), (24, 0.014), (25, -0.051), (26, -0.068), (27, -0.019), (28, 0.083), (29, 0.006), (30, 0.021), (31, 0.074), (32, 0.013), (33, 0.135), (34, 0.033), (35, 0.174), (36, 0.131), (37, 0.369), (38, 0.115), (39, 0.149), (40, 0.004), (41, -0.035), (42, 0.054), (43, 0.04), (44, -0.005), (45, 0.034), (46, -0.052), (47, 0.02), (48, -0.269), (49, -0.079)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 0.97331524 <a title="296-lsi-1" href="./acl-2011-Terminal-Aware_Synchronous_Binarization.html">296 acl-2011-Terminal-Aware Synchronous Binarization</a></p>
<p>Author: Licheng Fang ; Tagyoung Chung ; Daniel Gildea</p><p>Abstract: We present an SCFG binarization algorithm that combines the strengths of early terminal matching on the source language side and early language model integration on the target language side. We also examine how different strategies of target-side terminal attachment during binarization can significantly affect translation quality.</p><p>2 0.73370987 <a title="296-lsi-2" href="./acl-2011-Issues_Concerning_Decoding_with_Synchronous_Context-free_Grammar.html">180 acl-2011-Issues Concerning Decoding with Synchronous Context-free Grammar</a></p>
<p>Author: Tagyoung Chung ; Licheng Fang ; Daniel Gildea</p><p>Abstract: We discuss some of the practical issues that arise from decoding with general synchronous context-free grammars. We examine problems caused by unary rules and we also examine how virtual nonterminals resulting from binarization can best be handled. We also investigate adding more flexibility to synchronous context-free grammars by adding glue rules and phrases.</p><p>3 0.68227506 <a title="296-lsi-3" href="./acl-2011-Binarized_Forest_to_String_Translation.html">61 acl-2011-Binarized Forest to String Translation</a></p>
<p>Author: Hao Zhang ; Licheng Fang ; Peng Xu ; Xiaoyun Wu</p><p>Abstract: Tree-to-string translation is syntax-aware and efficient but sensitive to parsing errors. Forestto-string translation approaches mitigate the risk of propagating parser errors into translation errors by considering a forest of alternative trees, as generated by a source language parser. We propose an alternative approach to generating forests that is based on combining sub-trees within the first best parse through binarization. Provably, our binarization forest can cover any non-consitituent phrases in a sentence but maintains the desirable property that for each span there is at most one nonterminal so that the grammar constant for decoding is relatively small. For the purpose of reducing search errors, we apply the synchronous binarization technique to forest-tostring decoding. Combining the two techniques, we show that using a fast shift-reduce parser we can achieve significant quality gains in NIST 2008 English-to-Chinese track (1.3 BLEU points over a phrase-based system, 0.8 BLEU points over a hierarchical phrase-based system). Consistent and significant gains are also shown in WMT 2010 in the English to German, French, Spanish and Czech tracks.</p><p>4 0.61174947 <a title="296-lsi-4" href="./acl-2011-Prefix_Probability_for_Probabilistic_Synchronous_Context-Free_Grammars.html">250 acl-2011-Prefix Probability for Probabilistic Synchronous Context-Free Grammars</a></p>
<p>Author: Mark-Jan Nederhof ; Giorgio Satta</p><p>Abstract: We present a method for the computation of prefix probabilities for synchronous contextfree grammars. Our framework is fairly general and relies on the combination of a simple, novel grammar transformation and standard techniques to bring grammars into normal forms.</p><p>5 0.59427094 <a title="296-lsi-5" href="./acl-2011-Optimal_Head-Driven_Parsing_Complexity_for_Linear_Context-Free_Rewriting_Systems.html">234 acl-2011-Optimal Head-Driven Parsing Complexity for Linear Context-Free Rewriting Systems</a></p>
<p>Author: Pierluigi Crescenzi ; Daniel Gildea ; Andrea Marino ; Gianluca Rossi ; Giorgio Satta</p><p>Abstract: We study the problem offinding the best headdriven parsing strategy for Linear ContextFree Rewriting System productions. A headdriven strategy must begin with a specified righthand-side nonterminal (the head) and add the remaining nonterminals one at a time in any order. We show that it is NP-hard to find the best head-driven strategy in terms of either the time or space complexity of parsing.</p><p>6 0.4581998 <a title="296-lsi-6" href="./acl-2011-How_to_train_your_multi_bottom-up_tree_transducer.html">154 acl-2011-How to train your multi bottom-up tree transducer</a></p>
<p>7 0.40379483 <a title="296-lsi-7" href="./acl-2011-Prototyping_virtual_instructors_from_human-human_corpora.html">252 acl-2011-Prototyping virtual instructors from human-human corpora</a></p>
<p>8 0.39462265 <a title="296-lsi-8" href="./acl-2011-Rule_Markov_Models_for_Fast_Tree-to-String_Translation.html">268 acl-2011-Rule Markov Models for Fast Tree-to-String Translation</a></p>
<p>9 0.37641746 <a title="296-lsi-9" href="./acl-2011-Learning_to_Transform_and_Select_Elementary_Trees_for_Improved_Syntax-based_Machine_Translations.html">206 acl-2011-Learning to Transform and Select Elementary Trees for Improved Syntax-based Machine Translations</a></p>
<p>10 0.32022813 <a title="296-lsi-10" href="./acl-2011-Effective_Use_of_Function_Words_for_Rule_Generalization_in_Forest-Based_Translation.html">110 acl-2011-Effective Use of Function Words for Rule Generalization in Forest-Based Translation</a></p>
<p>11 0.3129909 <a title="296-lsi-11" href="./acl-2011-Learning_Hierarchical_Translation_Structure_with_Linguistic_Annotations.html">202 acl-2011-Learning Hierarchical Translation Structure with Linguistic Annotations</a></p>
<p>12 0.3109926 <a title="296-lsi-12" href="./acl-2011-Nonparametric_Bayesian_Machine_Transliteration_with_Synchronous_Adaptor_Grammars.html">232 acl-2011-Nonparametric Bayesian Machine Transliteration with Synchronous Adaptor Grammars</a></p>
<p>13 0.31081659 <a title="296-lsi-13" href="./acl-2011-Adjoining_Tree-to-String_Translation.html">30 acl-2011-Adjoining Tree-to-String Translation</a></p>
<p>14 0.28978923 <a title="296-lsi-14" href="./acl-2011-A_Word-Class_Approach_to_Labeling_PSCFG_Rules_for_Machine_Translation.html">29 acl-2011-A Word-Class Approach to Labeling PSCFG Rules for Machine Translation</a></p>
<p>15 0.26531357 <a title="296-lsi-15" href="./acl-2011-Syntax-based_Statistical_Machine_Translation_using_Tree_Automata_and_Tree_Transducers.html">290 acl-2011-Syntax-based Statistical Machine Translation using Tree Automata and Tree Transducers</a></p>
<p>16 0.26506278 <a title="296-lsi-16" href="./acl-2011-A_Fast_and_Accurate_Method_for_Approximate_String_Search.html">11 acl-2011-A Fast and Accurate Method for Approximate String Search</a></p>
<p>17 0.24295303 <a title="296-lsi-17" href="./acl-2011-SystemT%3A_A_Declarative_Information_Extraction_System.html">291 acl-2011-SystemT: A Declarative Information Extraction System</a></p>
<p>18 0.23753038 <a title="296-lsi-18" href="./acl-2011-Automatic_Extraction_of_Lexico-Syntactic_Patterns_for_Detection_of_Negation_and_Speculation_Scopes.html">50 acl-2011-Automatic Extraction of Lexico-Syntactic Patterns for Detection of Negation and Speculation Scopes</a></p>
<p>19 0.23382917 <a title="296-lsi-19" href="./acl-2011-Dynamic_Programming_Algorithms_for_Transition-Based_Dependency_Parsers.html">107 acl-2011-Dynamic Programming Algorithms for Transition-Based Dependency Parsers</a></p>
<p>20 0.2335171 <a title="296-lsi-20" href="./acl-2011-Machine_Translation_System_Combination_by_Confusion_Forest.html">217 acl-2011-Machine Translation System Combination by Confusion Forest</a></p>
<br/>
<h2>similar papers computed by <a title="lda-model" href="../home/acl2011_lda.html">lda model</a></h2><h3>lda for this paper:</h3><p>topicId topicWeight</p>
<p>[(5, 0.029), (8, 0.289), (17, 0.079), (37, 0.118), (39, 0.078), (41, 0.05), (55, 0.026), (59, 0.048), (62, 0.016), (72, 0.011), (91, 0.03), (96, 0.11)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 0.78689945 <a title="296-lda-1" href="./acl-2011-Terminal-Aware_Synchronous_Binarization.html">296 acl-2011-Terminal-Aware Synchronous Binarization</a></p>
<p>Author: Licheng Fang ; Tagyoung Chung ; Daniel Gildea</p><p>Abstract: We present an SCFG binarization algorithm that combines the strengths of early terminal matching on the source language side and early language model integration on the target language side. We also examine how different strategies of target-side terminal attachment during binarization can significantly affect translation quality.</p><p>2 0.65639496 <a title="296-lda-2" href="./acl-2011-Exploring_Entity_Relations_for_Named_Entity_Disambiguation.html">128 acl-2011-Exploring Entity Relations for Named Entity Disambiguation</a></p>
<p>Author: Danuta Ploch</p><p>Abstract: Named entity disambiguation is the task of linking an entity mention in a text to the correct real-world referent predefined in a knowledge base, and is a crucial subtask in many areas like information retrieval or topic detection and tracking. Named entity disambiguation is challenging because entity mentions can be ambiguous and an entity can be referenced by different surface forms. We present an approach that exploits Wikipedia relations between entities co-occurring with the ambiguous form to derive a range of novel features for classifying candidate referents. We find that our features improve disambiguation results significantly over a strong popularity baseline, and are especially suitable for recognizing entities not contained in the knowledge base. Our system achieves state-of-the-art results on the TAC-KBP 2009 dataset.</p><p>3 0.62215436 <a title="296-lda-3" href="./acl-2011-A_Bayesian_Model_for_Unsupervised_Semantic_Parsing.html">3 acl-2011-A Bayesian Model for Unsupervised Semantic Parsing</a></p>
<p>Author: Ivan Titov ; Alexandre Klementiev</p><p>Abstract: We propose a non-parametric Bayesian model for unsupervised semantic parsing. Following Poon and Domingos (2009), we consider a semantic parsing setting where the goal is to (1) decompose the syntactic dependency tree of a sentence into fragments, (2) assign each of these fragments to a cluster of semantically equivalent syntactic structures, and (3) predict predicate-argument relations between the fragments. We use hierarchical PitmanYor processes to model statistical dependencies between meaning representations of predicates and those of their arguments, as well as the clusters of their syntactic realizations. We develop a modification of the MetropolisHastings split-merge sampler, resulting in an efficient inference algorithm for the model. The method is experimentally evaluated by us- ing the induced semantic representation for the question answering task in the biomedical domain.</p><p>4 0.55687296 <a title="296-lda-4" href="./acl-2011-Exploiting_Syntactico-Semantic_Structures_for_Relation_Extraction.html">126 acl-2011-Exploiting Syntactico-Semantic Structures for Relation Extraction</a></p>
<p>Author: Yee Seng Chan ; Dan Roth</p><p>Abstract: In this paper, we observe that there exists a second dimension to the relation extraction (RE) problem that is orthogonal to the relation type dimension. We show that most of these second dimensional structures are relatively constrained and not difficult to identify. We propose a novel algorithmic approach to RE that starts by first identifying these structures and then, within these, identifying the semantic type of the relation. In the real RE problem where relation arguments need to be identified, exploiting these structures also allows reducing pipelined propagated errors. We show that this RE framework provides significant improvement in RE performance.</p><p>5 0.55250019 <a title="296-lda-5" href="./acl-2011-Semi-supervised_Relation_Extraction_with_Large-scale_Word_Clustering.html">277 acl-2011-Semi-supervised Relation Extraction with Large-scale Word Clustering</a></p>
<p>Author: Ang Sun ; Ralph Grishman ; Satoshi Sekine</p><p>Abstract: We present a simple semi-supervised relation extraction system with large-scale word clustering. We focus on systematically exploring the effectiveness of different cluster-based features. We also propose several statistical methods for selecting clusters at an appropriate level of granularity. When training on different sizes of data, our semi-supervised approach consistently outperformed a state-of-the-art supervised baseline system. 1</p><p>6 0.55178732 <a title="296-lda-6" href="./acl-2011-Learning_Hierarchical_Translation_Structure_with_Linguistic_Annotations.html">202 acl-2011-Learning Hierarchical Translation Structure with Linguistic Annotations</a></p>
<p>7 0.55152035 <a title="296-lda-7" href="./acl-2011-Effects_of_Noun_Phrase_Bracketing_in_Dependency_Parsing_and_Machine_Translation.html">111 acl-2011-Effects of Noun Phrase Bracketing in Dependency Parsing and Machine Translation</a></p>
<p>8 0.55139118 <a title="296-lda-8" href="./acl-2011-Joint_Training_of_Dependency_Parsing_Filters_through_Latent_Support_Vector_Machines.html">186 acl-2011-Joint Training of Dependency Parsing Filters through Latent Support Vector Machines</a></p>
<p>9 0.55032486 <a title="296-lda-9" href="./acl-2011-Transition-based_Dependency_Parsing_with_Rich_Non-local_Features.html">309 acl-2011-Transition-based Dependency Parsing with Rich Non-local Features</a></p>
<p>10 0.54631346 <a title="296-lda-10" href="./acl-2011-Unsupervised_Semantic_Role_Induction_via_Split-Merge_Clustering.html">324 acl-2011-Unsupervised Semantic Role Induction via Split-Merge Clustering</a></p>
<p>11 0.54591179 <a title="296-lda-11" href="./acl-2011-Coreference_Resolution_with_World_Knowledge.html">85 acl-2011-Coreference Resolution with World Knowledge</a></p>
<p>12 0.54587406 <a title="296-lda-12" href="./acl-2011-A_Comparison_of_Loopy_Belief_Propagation_and_Dual_Decomposition_for_Integrated_CCG_Supertagging_and_Parsing.html">5 acl-2011-A Comparison of Loopy Belief Propagation and Dual Decomposition for Integrated CCG Supertagging and Parsing</a></p>
<p>13 0.54479754 <a title="296-lda-13" href="./acl-2011-Beam-Width_Prediction_for_Efficient_Context-Free_Parsing.html">58 acl-2011-Beam-Width Prediction for Efficient Context-Free Parsing</a></p>
<p>14 0.54476947 <a title="296-lda-14" href="./acl-2011-Domain_Adaptation_by_Constraining_Inter-Domain_Variability_of_Latent_Feature_Representation.html">103 acl-2011-Domain Adaptation by Constraining Inter-Domain Variability of Latent Feature Representation</a></p>
<p>15 0.54328966 <a title="296-lda-15" href="./acl-2011-Data_point_selection_for_cross-language_adaptation_of_dependency_parsers.html">92 acl-2011-Data point selection for cross-language adaptation of dependency parsers</a></p>
<p>16 0.54261714 <a title="296-lda-16" href="./acl-2011-Using_Large_Monolingual_and_Bilingual_Corpora_to_Improve_Coordination_Disambiguation.html">331 acl-2011-Using Large Monolingual and Bilingual Corpora to Improve Coordination Disambiguation</a></p>
<p>17 0.54166597 <a title="296-lda-17" href="./acl-2011-Parsing_the_Internal_Structure_of_Words%3A_A_New_Paradigm_for_Chinese_Word_Segmentation.html">241 acl-2011-Parsing the Internal Structure of Words: A New Paradigm for Chinese Word Segmentation</a></p>
<p>18 0.54061091 <a title="296-lda-18" href="./acl-2011-Simple_Unsupervised_Grammar_Induction_from_Raw_Text_with_Cascaded_Finite_State_Models.html">284 acl-2011-Simple Unsupervised Grammar Induction from Raw Text with Cascaded Finite State Models</a></p>
<p>19 0.54048198 <a title="296-lda-19" href="./acl-2011-Improving_Arabic_Dependency_Parsing_with_Form-based_and_Functional_Morphological_Features.html">164 acl-2011-Improving Arabic Dependency Parsing with Form-based and Functional Morphological Features</a></p>
<p>20 0.54043591 <a title="296-lda-20" href="./acl-2011-A_Statistical_Tree_Annotator_and_Its_Applications.html">28 acl-2011-A Statistical Tree Annotator and Its Applications</a></p>
<br/><br/><br/>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-48522588-1', 'makerhacker.github.io');
ga('send', 'pageview');
</script>

</body>
</html>
