<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>11 acl-2011-A Fast and Accurate Method for Approximate String Search</title>
</head>

<body>
<p><a title="acl" href="../acl_home.html">acl</a> <a title="acl-2011" href="../home/acl2011_home.html">acl2011</a> <a title="acl-2011-11" href="#">acl2011-11</a> knowledge-graph by maker-knowledge-mining</p><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- maker adsense -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-5027806277543591"
     data-ad-slot="4192012269"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>11 acl-2011-A Fast and Accurate Method for Approximate String Search</h1>
<br/><p>Source: <a title="acl-2011-11-pdf" href="http://aclweb.org/anthology//P/P11/P11-1006.pdf">pdf</a></p><p>Author: Ziqi Wang ; Gu Xu ; Hang Li ; Ming Zhang</p><p>Abstract: This paper proposes a new method for approximate string search, specifically candidate generation in spelling error correction, which is a task as follows. Given a misspelled word, the system finds words in a dictionary, which are most “similar” to the misspelled word. The paper proposes a probabilistic approach to the task, which is both accurate and efficient. The approach includes the use of a log linear model, a method for training the model, and an algorithm for finding the top k candidates. The log linear model is defined as a conditional probability distribution of a corrected word and a rule set for the correction conditioned on the misspelled word. The learning method employs the criterion in candidate generation as loss function. The retrieval algorithm is efficient and is guaranteed to find the optimal k candidates. Experimental results on large scale data show that the proposed approach improves upon existing methods in terms of accuracy in different settings.</p><p>Reference: <a title="acl-2011-11-reference" href="../acl2011_reference/acl-2011-A_Fast_and_Accurate_Method_for_Approximate_String_Search_reference.html">text</a></p><br/><h2>Summary: the most important sentenses genereted by tfidf model</h2><p>sentIndex sentText sentNum sentScore</p><p>1 com  Abstract This paper proposes a new method for approximate string search, specifically candidate generation in spelling error correction, which is a task as follows. [sent-5, score-0.767]
</p><p>2 Given a misspelled word, the system finds words in a dictionary, which are most “similar” to the misspelled word. [sent-6, score-0.588]
</p><p>3 The log linear model is defined as a conditional probability distribution of a corrected word and a rule set for the correction conditioned on the misspelled word. [sent-9, score-0.702]
</p><p>4 The learning method employs the criterion in candidate generation as loss function. [sent-10, score-0.403]
</p><p>5 Given a query string, a dictionary of strings (vocabulary), and a set of operators, the system returns the top k strings in the dictionary that can be transformed from the query string by applying several operators in the operator set. [sent-14, score-0.621]
</p><p>6 Here each operator is a rule that can replace a substring in the query string with another substring. [sent-15, score-0.392]
</p><p>7 Approximate string search is useful in many applications including spelling error correction, similar terminology retrieval, duplicate detection, etc. [sent-24, score-0.459]
</p><p>8 Without loss of generality, in this paper we address candidate generation in spelling error correction. [sent-26, score-0.557]
</p><p>9 Candidate generation is to find the most possible corrections of a misspelled word. [sent-27, score-0.46]
</p><p>10 a single word; after candidate generation, the words surrounding it in the text can be further leveraged to make the final candidate selection, e. [sent-30, score-0.353]
</p><p>11 In spelling error correction, Brill and Moore (2000) proposed employing a generative model for candidate generation and a hierarchy of trie structures for fast candidate retrieval. [sent-34, score-0.865]
</p><p>12 c A2s0s1o1ci Aatsiosonc fioartio Cno fmorpu Ctoamtiopnuatalt Lioin gauli Lsitnicgsu,i psatgices 52–61, assumes that there is only one rule applicable each time in candidate generation. [sent-41, score-0.363]
</p><p>13 There are two fundamental problems in research on approximate string search: (1) how to build a model that can archive both high accuracy and efficiency, and (2) how to develop a data structure and algorithm that can facilitate efficient retrieval of the top k candidates. [sent-43, score-0.461]
</p><p>14 It employs (a) a log-linear (discriminative) model for candidate generation, (b) an effective algorithm for model learning, and (c) an efficient algorithm for candidate retrieval. [sent-46, score-0.479]
</p><p>15 The log linear model is defined as a conditional probability distribution of a corrected word and a rule set for the correction given the misspelled word. [sent-47, score-0.702]
</p><p>16 The retrieval algorithm uses special data structures and efficiently performs the top k candidates finding. [sent-50, score-0.318]
</p><p>17 We empirically evaluated the proposed method in spelling error correction of web search queries. [sent-52, score-0.628]
</p><p>18 The experimental results have verified that the accuracy of the top candidates given by our method is significantly higher than those given by the baseline methods. [sent-53, score-0.375]
</p><p>19 Our method is more accurate than the baseline methods in different settings such as large rule sets and large vocabulary sizes. [sent-54, score-0.301]
</p><p>20 The efficiency of our method is also very high in different experimental settings. [sent-55, score-0.269]
</p><p>21 Instead of finding all the candidates in a fixed range, methods for finding the top k candidates have also been developed. [sent-64, score-0.374]
</p><p>22 Spelling error correction normally consists of candidate generation and candidate final selection. [sent-69, score-0.674]
</p><p>23 Note that candidate generation is only concerned with a single word. [sent-71, score-0.259]
</p><p>24 Some methods generate candidates within a fixed range of edit distance or different ranges for strings with different lengths (Li et al. [sent-74, score-0.315]
</p><p>25 Schaback and Li (2007) proposed a multi-level feature-based framework for spelling error correction including a modification of Brill and Moore’s model (2000). [sent-83, score-0.474]
</p><p>26 (2008) uti-  lized substring substitution rules and incorporated the rules into a L1-regularized logistic regression model. [sent-85, score-0.495]
</p><p>27 Their model is a binary classification model and it is assumed that only a single rule is applied in candidate generation. [sent-88, score-0.28]
</p><p>28 Since users’ behavior of misspelling and correction can be frequently observed in web search log data, it has been proposed to mine spelling-error and correction pairs by using search log data. [sent-89, score-0.739]
</p><p>29 The mined pairs can be directly used in spelling error correction. [sent-90, score-0.347]
</p><p>30 Methods of selecting spelling and correction pairs with maximum entropy model (Chen et al. [sent-91, score-0.461]
</p><p>31 The mined pairs can only be used in candidate generation of high frequency typos, however. [sent-94, score-0.34]
</p><p>32 In this paper, we work on candidate generation at the character level, which can be applied to spelling error correction for both high and low frequency words. [sent-95, score-0.733]
</p><p>33 3  Model for Candidate Generation  As an example of approximate string search, we consider candidate generation in spelling correction. [sent-96, score-0.684]
</p><p>34 Suppose that there is a vocabulary V and a misspelled word, tthhee objective ocafb cualandryida Vte generation is to select the best corrections from the vocabulary V. [sent-97, score-0.75]
</p><p>35 We care about both accuracy and efficiency of the process. [sent-98, score-0.247]
</p><p>36 rTeh aeb problem aisc very challenging nwcyhe onf tthhee size of vocabulary is large, because there are a large number of potential candidates to be verified. [sent-99, score-0.3]
</p><p>37 In our approach, it is assumed that a large number of misspelled words and their best corrections are given as training data. [sent-101, score-0.36]
</p><p>38 The best candidates for correction of a misspelled word are thus defined as those candidates having the highest probabilistic scores with respect to the training data and the operators. [sent-103, score-0.812]
</p><p>39 54 Edit-distance based aligment  ^ mn i c o r o s s o o f t $  Derived rules  Expended rules with context  Figure 1: Example of rule extraction from word pair 3. [sent-105, score-0.439]
</p><p>40 An operator is formally represented a rule α → β that replaces a substring α in a misspelled ew αord → w βit hth β, ewplhaecrees α, β ∈ {s|s = t, s = ˆt, or s = t$} aβn,d w th ∈ Σ α,∗ βis ∈the { ss|est o=f  at,lls possible strings over atnhed alphabet. [sent-108, score-0.553]
</p><p>41 If we can apply a set of rules to transform the misspelled word wm to a correct word wc in the vocabulary, then we call the rule set a “transformation” for the word pair wm and wc. [sent-115, score-1.498]
</p><p>42 Without loss of generality, we set the maximum number of rules applicable to a word pair to be a fixed number. [sent-119, score-0.274]
</p><p>43 Given word pair (wm, wc), let R(wm, wc) denote one transformation (a set of rules) that can rewrite wm to wc. [sent-122, score-0.433]
</p><p>44 We consider that there is a probabilistic mapping between the misspelled word wm and correct word wc plus transformation R(wm, wc). [sent-123, score-0.973]
</p><p>45 To improve efficiency in retrieval, we fur-  ther assume that all the weights are non-positive, i. [sent-128, score-0.248]
</p><p>46 It introduces monotonicity in rule applicat∀ioλn a≤nd 0 implies dthucate applying naidcdityiti oinna rul l reu laepsp cannot lead to generation of better candidates. [sent-131, score-0.261]
</p><p>47 Our experimental results have shown that the change in accuracy by making the assumption is negligible, but the gain in efficiency is very large. [sent-135, score-0.282]
</p><p>48 2 Training of Model Training data is given as a set of pairs T  =  {(wmi,wci)}iN=1, where wmiis a misspelled word and {wic ∈ V is a} correction of wmi. [sent-137, score-0.537]
</p><p>49 This is not a triv)ia|wl problem, however, because the “true” transformation R∗(wmi, wci) for each word pair wmi and wci is not given in the training data. [sent-139, score-0.502]
</p><p>50 (It is relatively easy to automatically 55 find the pairs wmi and wci as explained in Section 5. [sent-141, score-0.443]
</p><p>51 In this paper, we assume that the transformation that actually generates the correction among all the possible transformations is the one that can give the maximum conditional probability; the exactly same criterion is also used for fast prediction. [sent-143, score-0.429]
</p><p>52 Therefore we have the following objective function  λ∗=argmλaxL(λ)  (2)  =argmλax∑iR(mwmiax,wcil)ogP(wci,R(wmi,wci)|wmi) where λ denotes the weight parameters and the max is taken over the set of transformations that can transform wmi to wci. [sent-144, score-0.285]
</p><p>53 3 Candidate Generation In candidate generation, given a misspelled word wm, we find the k candidates from the vocabulary, that can be transformed from wm and have the largest probabilities assigned by the learned model. [sent-150, score-0.947]
</p><p>54 We only need to utilize the following ranking function to rank a candidate wc given a misspelled word wm, by taking into account Equs. [sent-151, score-0.773]
</p><p>55 We then choose the sum as a ranking score, which is equivalent to ranking candidates based on their largest conditional probabilities. [sent-153, score-0.337]
</p><p>56 Our retrieval algorithm is guaranteed to find the optimal k candidates with some “pruning” techniques. [sent-162, score-0.295]
</p><p>57 One is a trie for storing and matching words in the vocabulary, referred to as vocabulary trie, and the other based on what we call an Aho-Corasick tree (AC tree) (Aho and Corasick, 1975), which is used for storing and applying correction rules, referred to as rule index. [sent-166, score-0.685]
</p><p>58 The vocabulary trie is the same as that used in existing work and it will be traversed when searching the top k candidates. [sent-167, score-0.35]
</p><p>59 Our rule index is unique because it indexes all the rules based on an AC tree. [sent-168, score-0.332]
</p><p>60 The AC tree is a trie with “failure links”, on which the Aho-Corasick string matching algorithm can be executed. [sent-169, score-0.293]
</p><p>61 1 1One may further improve the index structure by using a trie  rather than a ranking list to store βs associated with the same α. [sent-175, score-0.267]
</p><p>62 Our algorithm first employs the Aho-Corasick algorithm to locate all the applicable α’s within the input word wm, from the rule index. [sent-181, score-0.353]
</p><p>63 Our algorithm next traverses the vocabulary trie and searches the top k candidates with some pruning techniques. [sent-184, score-0.626]
</p><p>64 1) If the current sum of weights of applied rules is smaller than the smallest weight in the top k list, the search branch is pruned. [sent-189, score-0.351]
</p><p>65 2) If two search branches merge at the same node in the vocabulary trie as well as the same position on wm, the search branches with smaller sum of weights will be pruned. [sent-192, score-0.493]
</p><p>66 It is not difficult to prove that our algorithm is guaranteed to find the best k candidates in terms of the ranking scores, because we only prune those candidates that cannot give better scores than the ones in the current top k list. [sent-195, score-0.527]
</p><p>67 Due to the limitation of space,  we omit the proof of the theorem that if the weights of rules λ are non-positive and the ranking function is defined as in Equ. [sent-196, score-0.282]
</p><p>68 5, then the top k candidates obtained with the pruning criteria are the same as the top k candidates obtained without pruning. [sent-197, score-0.521]
</p><p>69 5 Experimental Results We have experimentally evaluated our approach in spelling error correction of queries in web search. [sent-198, score-0.621]
</p><p>70 (1) The vocabulary of queries in web search is extremely large due to the scale, diversity, and dynamics of the Internet. [sent-200, score-0.335]
</p><p>71 (2) Efficiency is critically important, because the response time of top k candidate retrieval for web search must be kept very low. [sent-201, score-0.403]
</p><p>72 Our approach for candidate generation is in fact motivated by the application. [sent-202, score-0.259]
</p><p>73 It is easy to observe from search session data that there are many spelling errors and their corrections occurring in the same sessions. [sent-205, score-0.414]
</p><p>74 We employed heuristics to automatically mine training pairs from  search session data at a commercial search engine. [sent-206, score-0.277]
</p><p>75 We used short sessions here because we found that search users usually correct their misspelled queries very quickly after they find the misspellings. [sent-209, score-0.444]
</p><p>76 Then the following heuristics were employed to identify pairs of misspelled words and their corrections from two consecutive queries within a session: 1) Two queries have the same number of words. [sent-210, score-0.57]
</p><p>77 3) For the two distinct words, the word in the first query is considered as misspelled and the second one as its correction. [sent-212, score-0.372]
</p><p>78 (2008)’s model is not particularly for spelling error correction, but it can be employed in the task. [sent-219, score-0.299]
</p><p>79 We compared our method with the two baselines in terms of top k accuracy, which is ratio of the true corrections among the top k candidates generated by a method. [sent-221, score-0.435]
</p><p>80 All the methods shared the same settings:  973,902 words in the vocabulary, 10,597 rules for correction, and up to two rules used in one transformation. [sent-222, score-0.318]
</p><p>81 Next, we conducted experiments to investigate how the top k accuracy changes with different sizes of vocabularies, maximum numbers of applicable rules and sizes of rule set for the three methods. [sent-232, score-0.475]
</p><p>82 However, the drop of accuracy by our method is much smaller than that by generative, which  means our method is more powerful when the vocabulary is large, e. [sent-240, score-0.263]
</p><p>83 5, we changed the maximum number of rules that can be applied to a transformation from 2 to 3. [sent-244, score-0.253]
</p><p>84 When there are more applicable rules, more candidates can be generated and thus ranking of them becomes more challenging. [sent-246, score-0.312]
</p><p>85 The performance of our method and those of the two baselines did not change so much, and our method still visibly outperform the baselines when more rules are exploited. [sent-251, score-0.331]
</p><p>86 Instead of making comparison with the existing methods in terms of efficiency, we evaluated the efficiency of our method by looking at how efficient it becomes with its data structure and pruning technique. [sent-257, score-0.36]
</p><p>87 Figure 6: Accuracy Comparison between Baselines and Our Method with Different Numbers of Rules First, we tested the efficiency of using AhoCorasick algorithm (the rule index). [sent-272, score-0.358]
</p><p>88 Number of Rules time complexity of Aho-Corasick algorithm is determined by the lengths of query strings and the number of matches, we examined how the number of matches on query strings with different lengths changes when the number of rules increases. [sent-278, score-0.471]
</p><p>89 We can see that the number of matches is not largely affected by the number of rules in the rule index. [sent-281, score-0.28]
</p><p>90 Next, since the running time of our method is proportional to the number of visited nodes on the vocabulary trie, we evaluated the efficiency of our method in terms of number of visited nodes. [sent-283, score-0.57]
</p><p>91 Specifically, we tested how the number of visited nodes changes according to three factors: maximum number of applicable rules in a transformation, vocabulary size and rule set size. [sent-285, score-0.586]
</p><p>92 8, with increasing maximum number of applicable rules in a transformation, number of visited nodes increases first and then stabilizes, especially when the words are long. [sent-291, score-0.32]
</p><p>93 Figure 9: Efficiency Evaluation with Different Sizes of Vocabulary we have seen that using up to two rules in a transformation can bring a very high accuracy. [sent-299, score-0.253]
</p><p>94 9, we can conclude that the numbers of visited nodes are stable and thus the efficiency of our method keeps high with larger vocabulary size and number of rules. [sent-302, score-0.457]
</p><p>95 6  Conclusion  In this paper, we have proposed a new method for approximate string search, including spelling error correction, which is both accurate and efficient. [sent-324, score-0.508]
</p><p>96 Learning a spelling error model from search query logs. [sent-331, score-0.423]
</p><p>97 An improved error model for noisy channel spelling correction. [sent-349, score-0.266]
</p><p>98 Exploring distributional similarity based models for query spelling correction. [sent-375, score-0.296]
</p><p>99 Vgram: improving performance of approximate queries on  string collections using variable-length grams. [sent-380, score-0.278]
</p><p>100 Costbased variable-length-gram selection for string collections to support approximate queries efficiently. [sent-441, score-0.278]
</p>
<br/>
<h2>similar papers computed by tfidf model</h2><h3>tfidf for this paper:</h3><p>wordName wordTfidf (topN-words)</p>
<p>[('wm', 0.339), ('misspelled', 0.294), ('wc', 0.246), ('wmi', 0.227), ('spelling', 0.218), ('correction', 0.208), ('efficiency', 0.199), ('wci', 0.181), ('candidate', 0.159), ('rules', 0.159), ('candidates', 0.155), ('vocabulary', 0.145), ('trie', 0.141), ('okazaki', 0.131), ('rule', 0.121), ('string', 0.114), ('brill', 0.114), ('moore', 0.109), ('generation', 0.1), ('transformation', 0.094), ('approximate', 0.093), ('pruning', 0.083), ('applicable', 0.083), ('search', 0.079), ('query', 0.078), ('visited', 0.078), ('bounded', 0.076), ('ranking', 0.074), ('queries', 0.071), ('behm', 0.068), ('corrections', 0.066), ('top', 0.064), ('logistic', 0.063), ('edit', 0.062), ('retrieval', 0.061), ('unbounded', 0.06), ('strings', 0.059), ('transformations', 0.058), ('li', 0.058), ('aho', 0.055), ('morristown', 0.055), ('index', 0.052), ('baselines', 0.051), ('session', 0.051), ('operators', 0.051), ('weights', 0.049), ('nj', 0.049), ('accuracy', 0.048), ('error', 0.048), ('mined', 0.046), ('corasick', 0.045), ('danling', 0.045), ('jiaheng', 0.045), ('mihov', 0.045), ('vernica', 0.045), ('wic', 0.045), ('xiaochun', 0.045), ('log', 0.045), ('efficient', 0.043), ('employs', 0.042), ('substitution', 0.042), ('chen', 0.042), ('guaranteed', 0.041), ('generative', 0.04), ('generality', 0.04), ('operator', 0.04), ('web', 0.04), ('officer', 0.04), ('oncina', 0.04), ('rul', 0.04), ('schaback', 0.04), ('dictionary', 0.039), ('substring', 0.039), ('distance', 0.039), ('verified', 0.038), ('algorithm', 0.038), ('enlarged', 0.037), ('golding', 0.037), ('islam', 0.037), ('ristad', 0.037), ('sigmod', 0.037), ('wim', 0.037), ('experimentally', 0.036), ('referred', 0.035), ('criterion', 0.035), ('surrounding', 0.035), ('pairs', 0.035), ('method', 0.035), ('whitelaw', 0.035), ('experimental', 0.035), ('ming', 0.034), ('conditional', 0.034), ('yang', 0.033), ('regression', 0.033), ('employed', 0.033), ('vldb', 0.033), ('deletion', 0.033), ('loss', 0.032), ('locate', 0.031), ('peking', 0.031)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 0.99999952 <a title="11-tfidf-1" href="./acl-2011-A_Fast_and_Accurate_Method_for_Approximate_String_Search.html">11 acl-2011-A Fast and Accurate Method for Approximate String Search</a></p>
<p>Author: Ziqi Wang ; Gu Xu ; Hang Li ; Ming Zhang</p><p>Abstract: This paper proposes a new method for approximate string search, specifically candidate generation in spelling error correction, which is a task as follows. Given a misspelled word, the system finds words in a dictionary, which are most “similar” to the misspelled word. The paper proposes a probabilistic approach to the task, which is both accurate and efficient. The approach includes the use of a log linear model, a method for training the model, and an algorithm for finding the top k candidates. The log linear model is defined as a conditional probability distribution of a corrected word and a rule set for the correction conditioned on the misspelled word. The learning method employs the criterion in candidate generation as loss function. The retrieval algorithm is efficient and is guaranteed to find the optimal k candidates. Experimental results on large scale data show that the proposed approach improves upon existing methods in terms of accuracy in different settings.</p><p>2 0.21571964 <a title="11-tfidf-2" href="./acl-2011-A_Graph_Approach_to_Spelling_Correction_in_Domain-Centric_Search.html">13 acl-2011-A Graph Approach to Spelling Correction in Domain-Centric Search</a></p>
<p>Author: Zhuowei Bao ; Benny Kimelfeld ; Yunyao Li</p><p>Abstract: Spelling correction for keyword-search queries is challenging in restricted domains such as personal email (or desktop) search, due to the scarcity of query logs, and due to the specialized nature of the domain. For that task, this paper presents an algorithm that is based on statistics from the corpus data (rather than the query log). This algorithm, which employs a simple graph-based approach, can incorporate different types of data sources with different levels of reliability (e.g., email subject vs. email body), and can handle complex spelling errors like splitting and merging of words. An experimental study shows the superiority of the algorithm over existing alternatives in the email domain.</p><p>3 0.17498326 <a title="11-tfidf-3" href="./acl-2011-Automated_Whole_Sentence_Grammar_Correction_Using_a_Noisy_Channel_Model.html">46 acl-2011-Automated Whole Sentence Grammar Correction Using a Noisy Channel Model</a></p>
<p>Author: Y. Albert Park ; Roger Levy</p><p>Abstract: Automated grammar correction techniques have seen improvement over the years, but there is still much room for increased performance. Current correction techniques mainly focus on identifying and correcting a specific type of error, such as verb form misuse or preposition misuse, which restricts the corrections to a limited scope. We introduce a novel technique, based on a noisy channel model, which can utilize the whole sentence context to determine proper corrections. We show how to use the EM algorithm to learn the parameters of the noise model, using only a data set of erroneous sentences, given the proper language model. This frees us from the burden of acquiring a large corpora of corrected sentences. We also present a cheap and efficient way to provide automated evaluation re- sults for grammar corrections by using BLEU and METEOR, in contrast to the commonly used manual evaluations.</p><p>4 0.11930981 <a title="11-tfidf-4" href="./acl-2011-Why_Press_Backspace%3F_Understanding_User_Input_Behaviors_in_Chinese_Pinyin_Input_Method.html">336 acl-2011-Why Press Backspace? Understanding User Input Behaviors in Chinese Pinyin Input Method</a></p>
<p>Author: Yabin Zheng ; Lixing Xie ; Zhiyuan Liu ; Maosong Sun ; Yang Zhang ; Liyun Ru</p><p>Abstract: Chinese Pinyin input method is very important for Chinese language information processing. Users may make errors when they are typing in Chinese words. In this paper, we are concerned with the reasons that cause the errors. Inspired by the observation that pressing backspace is one of the most common user behaviors to modify the errors, we collect 54, 309, 334 error-correction pairs from a realworld data set that contains 2, 277, 786 users via backspace operations. In addition, we present a comparative analysis of the data to achieve a better understanding of users’ input behaviors. Comparisons with English typos suggest that some language-specific properties result in a part of Chinese input errors. 1</p><p>5 0.10948297 <a title="11-tfidf-5" href="./acl-2011-Rule_Markov_Models_for_Fast_Tree-to-String_Translation.html">268 acl-2011-Rule Markov Models for Fast Tree-to-String Translation</a></p>
<p>Author: Ashish Vaswani ; Haitao Mi ; Liang Huang ; David Chiang</p><p>Abstract: Most statistical machine translation systems rely on composed rules (rules that can be formed out of smaller rules in the grammar). Though this practice improves translation by weakening independence assumptions in the translation model, it nevertheless results in huge, redundant grammars, making both training and decoding inefficient. Here, we take the opposite approach, where we only use minimal rules (those that cannot be formed out of other rules), and instead rely on a rule Markov model of the derivation history to capture dependencies between minimal rules. Large-scale experiments on a state-of-the-art tree-to-string translation system show that our approach leads to a slimmer model, a faster decoder, yet the same translation quality (measured using B ) as composed rules.</p><p>6 0.10208789 <a title="11-tfidf-6" href="./acl-2011-Joint_Annotation_of_Search_Queries.html">182 acl-2011-Joint Annotation of Search Queries</a></p>
<p>7 0.098695017 <a title="11-tfidf-7" href="./acl-2011-EdIt%3A_A_Broad-Coverage_Grammar_Checker_Using_Pattern_Grammar.html">108 acl-2011-EdIt: A Broad-Coverage Grammar Checker Using Pattern Grammar</a></p>
<p>8 0.098384947 <a title="11-tfidf-8" href="./acl-2011-Ranking_Class_Labels_Using_Query_Sessions.html">258 acl-2011-Ranking Class Labels Using Query Sessions</a></p>
<p>9 0.096057385 <a title="11-tfidf-9" href="./acl-2011-Search_in_the_Lost_Sense_of_%22Query%22%3A_Question_Formulation_in_Web_Search_Queries_and_its_Temporal_Changes.html">271 acl-2011-Search in the Lost Sense of "Query": Question Formulation in Web Search Queries and its Temporal Changes</a></p>
<p>10 0.095500186 <a title="11-tfidf-10" href="./acl-2011-Prefix_Probability_for_Probabilistic_Synchronous_Context-Free_Grammars.html">250 acl-2011-Prefix Probability for Probabilistic Synchronous Context-Free Grammars</a></p>
<p>11 0.094963059 <a title="11-tfidf-11" href="./acl-2011-Query_Weighting_for_Ranking_Model_Adaptation.html">256 acl-2011-Query Weighting for Ranking Model Adaptation</a></p>
<p>12 0.090945832 <a title="11-tfidf-12" href="./acl-2011-Algorithm_Selection_and_Model_Adaptation_for_ESL_Correction_Tasks.html">32 acl-2011-Algorithm Selection and Model Adaptation for ESL Correction Tasks</a></p>
<p>13 0.088590249 <a title="11-tfidf-13" href="./acl-2011-Automatic_Labelling_of_Topic_Models.html">52 acl-2011-Automatic Labelling of Topic Models</a></p>
<p>14 0.087667078 <a title="11-tfidf-14" href="./acl-2011-Effective_Use_of_Function_Words_for_Rule_Generalization_in_Forest-Based_Translation.html">110 acl-2011-Effective Use of Function Words for Rule Generalization in Forest-Based Translation</a></p>
<p>15 0.08615949 <a title="11-tfidf-15" href="./acl-2011-Latent_Class_Transliteration_based_on_Source_Language_Origin.html">197 acl-2011-Latent Class Transliteration based on Source Language Origin</a></p>
<p>16 0.084638953 <a title="11-tfidf-16" href="./acl-2011-Fine-Grained_Class_Label_Markup_of_Search_Queries.html">137 acl-2011-Fine-Grained Class Label Markup of Search Queries</a></p>
<p>17 0.082629666 <a title="11-tfidf-17" href="./acl-2011-Jigs_and_Lures%3A_Associating_Web_Queries_with_Structured_Entities.html">181 acl-2011-Jigs and Lures: Associating Web Queries with Structured Entities</a></p>
<p>18 0.081418775 <a title="11-tfidf-18" href="./acl-2011-Learning_to_Transform_and_Select_Elementary_Trees_for_Improved_Syntax-based_Machine_Translations.html">206 acl-2011-Learning to Transform and Select Elementary Trees for Improved Syntax-based Machine Translations</a></p>
<p>19 0.080927536 <a title="11-tfidf-19" href="./acl-2011-A_Word-Class_Approach_to_Labeling_PSCFG_Rules_for_Machine_Translation.html">29 acl-2011-A Word-Class Approach to Labeling PSCFG Rules for Machine Translation</a></p>
<p>20 0.075152807 <a title="11-tfidf-20" href="./acl-2011-Binarized_Forest_to_String_Translation.html">61 acl-2011-Binarized Forest to String Translation</a></p>
<br/>
<h2>similar papers computed by <a title="lsi-model" href="../home/acl2011_lsi.html">lsi model</a></h2><h3>lsi for this paper:</h3><p>topicId topicWeight</p>
<p>[(0, 0.213), (1, -0.03), (2, -0.026), (3, 0.028), (4, -0.093), (5, -0.12), (6, -0.087), (7, -0.141), (8, 0.001), (9, -0.041), (10, -0.081), (11, -0.013), (12, 0.001), (13, 0.114), (14, 0.02), (15, 0.126), (16, 0.04), (17, -0.012), (18, 0.039), (19, -0.011), (20, -0.042), (21, -0.009), (22, 0.032), (23, -0.054), (24, -0.015), (25, -0.04), (26, -0.01), (27, 0.014), (28, 0.044), (29, 0.059), (30, 0.038), (31, 0.009), (32, 0.038), (33, -0.003), (34, -0.123), (35, -0.039), (36, -0.039), (37, 0.102), (38, 0.024), (39, 0.004), (40, 0.043), (41, 0.018), (42, -0.041), (43, 0.132), (44, 0.026), (45, 0.007), (46, -0.01), (47, -0.043), (48, 0.079), (49, 0.103)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 0.93902588 <a title="11-lsi-1" href="./acl-2011-A_Fast_and_Accurate_Method_for_Approximate_String_Search.html">11 acl-2011-A Fast and Accurate Method for Approximate String Search</a></p>
<p>Author: Ziqi Wang ; Gu Xu ; Hang Li ; Ming Zhang</p><p>Abstract: This paper proposes a new method for approximate string search, specifically candidate generation in spelling error correction, which is a task as follows. Given a misspelled word, the system finds words in a dictionary, which are most “similar” to the misspelled word. The paper proposes a probabilistic approach to the task, which is both accurate and efficient. The approach includes the use of a log linear model, a method for training the model, and an algorithm for finding the top k candidates. The log linear model is defined as a conditional probability distribution of a corrected word and a rule set for the correction conditioned on the misspelled word. The learning method employs the criterion in candidate generation as loss function. The retrieval algorithm is efficient and is guaranteed to find the optimal k candidates. Experimental results on large scale data show that the proposed approach improves upon existing methods in terms of accuracy in different settings.</p><p>2 0.80255812 <a title="11-lsi-2" href="./acl-2011-A_Graph_Approach_to_Spelling_Correction_in_Domain-Centric_Search.html">13 acl-2011-A Graph Approach to Spelling Correction in Domain-Centric Search</a></p>
<p>Author: Zhuowei Bao ; Benny Kimelfeld ; Yunyao Li</p><p>Abstract: Spelling correction for keyword-search queries is challenging in restricted domains such as personal email (or desktop) search, due to the scarcity of query logs, and due to the specialized nature of the domain. For that task, this paper presents an algorithm that is based on statistics from the corpus data (rather than the query log). This algorithm, which employs a simple graph-based approach, can incorporate different types of data sources with different levels of reliability (e.g., email subject vs. email body), and can handle complex spelling errors like splitting and merging of words. An experimental study shows the superiority of the algorithm over existing alternatives in the email domain.</p><p>3 0.64643914 <a title="11-lsi-3" href="./acl-2011-EdIt%3A_A_Broad-Coverage_Grammar_Checker_Using_Pattern_Grammar.html">108 acl-2011-EdIt: A Broad-Coverage Grammar Checker Using Pattern Grammar</a></p>
<p>Author: Chung-chi Huang ; Mei-hua Chen ; Shih-ting Huang ; Jason S. Chang</p><p>Abstract: We introduce a new method for learning to detect grammatical errors in learner’s writing and provide suggestions. The method involves parsing a reference corpus and inferring grammar patterns in the form of a sequence of content words, function words, and parts-of-speech (e.g., “play ~ role in Ving” and “look forward to Ving”). At runtime, the given passage submitted by the learner is matched using an extended Levenshtein algorithm against the set of pattern rules in order to detect errors and provide suggestions. We present a prototype implementation of the proposed method, EdIt, that can handle a broad range of errors. Promising results are illustrated with three common types of errors in nonnative writing. 1</p><p>4 0.61670178 <a title="11-lsi-4" href="./acl-2011-Automated_Whole_Sentence_Grammar_Correction_Using_a_Noisy_Channel_Model.html">46 acl-2011-Automated Whole Sentence Grammar Correction Using a Noisy Channel Model</a></p>
<p>Author: Y. Albert Park ; Roger Levy</p><p>Abstract: Automated grammar correction techniques have seen improvement over the years, but there is still much room for increased performance. Current correction techniques mainly focus on identifying and correcting a specific type of error, such as verb form misuse or preposition misuse, which restricts the corrections to a limited scope. We introduce a novel technique, based on a noisy channel model, which can utilize the whole sentence context to determine proper corrections. We show how to use the EM algorithm to learn the parameters of the noise model, using only a data set of erroneous sentences, given the proper language model. This frees us from the burden of acquiring a large corpora of corrected sentences. We also present a cheap and efficient way to provide automated evaluation re- sults for grammar corrections by using BLEU and METEOR, in contrast to the commonly used manual evaluations.</p><p>5 0.58676642 <a title="11-lsi-5" href="./acl-2011-Why_Press_Backspace%3F_Understanding_User_Input_Behaviors_in_Chinese_Pinyin_Input_Method.html">336 acl-2011-Why Press Backspace? Understanding User Input Behaviors in Chinese Pinyin Input Method</a></p>
<p>Author: Yabin Zheng ; Lixing Xie ; Zhiyuan Liu ; Maosong Sun ; Yang Zhang ; Liyun Ru</p><p>Abstract: Chinese Pinyin input method is very important for Chinese language information processing. Users may make errors when they are typing in Chinese words. In this paper, we are concerned with the reasons that cause the errors. Inspired by the observation that pressing backspace is one of the most common user behaviors to modify the errors, we collect 54, 309, 334 error-correction pairs from a realworld data set that contains 2, 277, 786 users via backspace operations. In addition, we present a comparative analysis of the data to achieve a better understanding of users’ input behaviors. Comparisons with English typos suggest that some language-specific properties result in a part of Chinese input errors. 1</p><p>6 0.55544895 <a title="11-lsi-6" href="./acl-2011-An_Efficient_Indexer_for_Large_N-Gram_Corpora.html">36 acl-2011-An Efficient Indexer for Large N-Gram Corpora</a></p>
<p>7 0.5492152 <a title="11-lsi-7" href="./acl-2011-SystemT%3A_A_Declarative_Information_Extraction_System.html">291 acl-2011-SystemT: A Declarative Information Extraction System</a></p>
<p>8 0.5353753 <a title="11-lsi-8" href="./acl-2011-Prefix_Probability_for_Probabilistic_Synchronous_Context-Free_Grammars.html">250 acl-2011-Prefix Probability for Probabilistic Synchronous Context-Free Grammars</a></p>
<p>9 0.50643891 <a title="11-lsi-9" href="./acl-2011-Algorithm_Selection_and_Model_Adaptation_for_ESL_Correction_Tasks.html">32 acl-2011-Algorithm Selection and Model Adaptation for ESL Correction Tasks</a></p>
<p>10 0.5064109 <a title="11-lsi-10" href="./acl-2011-Insertion%2C_Deletion%2C_or_Substitution%3F_Normalizing_Text_Messages_without_Pre-categorization_nor_Supervision.html">172 acl-2011-Insertion, Deletion, or Substitution? Normalizing Text Messages without Pre-categorization nor Supervision</a></p>
<p>11 0.4985204 <a title="11-lsi-11" href="./acl-2011-An_ERP-based_Brain-Computer_Interface_for_text_entry_using_Rapid_Serial_Visual_Presentation_and_Language_Modeling.html">35 acl-2011-An ERP-based Brain-Computer Interface for text entry using Rapid Serial Visual Presentation and Language Modeling</a></p>
<p>12 0.49581647 <a title="11-lsi-12" href="./acl-2011-A_Speech-based_Just-in-Time_Retrieval_System_using_Semantic_Search.html">26 acl-2011-A Speech-based Just-in-Time Retrieval System using Semantic Search</a></p>
<p>13 0.49366021 <a title="11-lsi-13" href="./acl-2011-Grammatical_Error_Correction_with_Alternating_Structure_Optimization.html">147 acl-2011-Grammatical Error Correction with Alternating Structure Optimization</a></p>
<p>14 0.48039982 <a title="11-lsi-14" href="./acl-2011-Jigs_and_Lures%3A_Associating_Web_Queries_with_Structured_Entities.html">181 acl-2011-Jigs and Lures: Associating Web Queries with Structured Entities</a></p>
<p>15 0.47878703 <a title="11-lsi-15" href="./acl-2011-Engkoo%3A_Mining_the_Web_for_Language_Learning.html">115 acl-2011-Engkoo: Mining the Web for Language Learning</a></p>
<p>16 0.47605073 <a title="11-lsi-16" href="./acl-2011-Lexical_Normalisation_of_Short_Text_Messages%3A_Makn_Sens_a_%23twitter.html">208 acl-2011-Lexical Normalisation of Short Text Messages: Makn Sens a #twitter</a></p>
<p>17 0.46157834 <a title="11-lsi-17" href="./acl-2011-The_impact_of_language_models_and_loss_functions_on_repair_disfluency_detection.html">301 acl-2011-The impact of language models and loss functions on repair disfluency detection</a></p>
<p>18 0.46120363 <a title="11-lsi-18" href="./acl-2011-Search_in_the_Lost_Sense_of_%22Query%22%3A_Question_Formulation_in_Web_Search_Queries_and_its_Temporal_Changes.html">271 acl-2011-Search in the Lost Sense of "Query": Question Formulation in Web Search Queries and its Temporal Changes</a></p>
<p>19 0.45714194 <a title="11-lsi-19" href="./acl-2011-Faster_and_Smaller_N-Gram_Language_Models.html">135 acl-2011-Faster and Smaller N-Gram Language Models</a></p>
<p>20 0.45026329 <a title="11-lsi-20" href="./acl-2011-Creative_Language_Retrieval%3A_A_Robust_Hybrid_of_Information_Retrieval_and_Linguistic_Creativity.html">89 acl-2011-Creative Language Retrieval: A Robust Hybrid of Information Retrieval and Linguistic Creativity</a></p>
<br/>
<h2>similar papers computed by <a title="lda-model" href="../home/acl2011_lda.html">lda model</a></h2><h3>lda for this paper:</h3><p>topicId topicWeight</p>
<p>[(5, 0.029), (13, 0.169), (17, 0.066), (26, 0.038), (37, 0.076), (39, 0.064), (41, 0.117), (55, 0.032), (59, 0.032), (72, 0.025), (91, 0.036), (96, 0.164), (97, 0.046)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>1 0.95563495 <a title="11-lda-1" href="./acl-2011-An_Interface_for_Rapid_Natural_Language_Processing_Development_in_UIMA.html">42 acl-2011-An Interface for Rapid Natural Language Processing Development in UIMA</a></p>
<p>Author: Balaji Soundrarajan ; Thomas Ginter ; Scott DuVall</p><p>Abstract: This demonstration presents the Annotation Librarian, an application programming interface that supports rapid development of natural language processing (NLP) projects built in Apache Unstructured Information Management Architecture (UIMA). The flexibility of UIMA to support all types of unstructured data – images, audio, and text – increases the complexity of some of the most common NLP development tasks. The Annotation Librarian interface handles these common functions and allows the creation and management of annotations by mirroring Java methods used to manipulate Strings. The familiar syntax and NLP-centric design allows developers to adopt and rapidly develop NLP algorithms in UIMA. The general functionality of the interface is described in relation to the use cases that necessitated its creation. 1</p><p>same-paper 2 0.86126047 <a title="11-lda-2" href="./acl-2011-A_Fast_and_Accurate_Method_for_Approximate_String_Search.html">11 acl-2011-A Fast and Accurate Method for Approximate String Search</a></p>
<p>Author: Ziqi Wang ; Gu Xu ; Hang Li ; Ming Zhang</p><p>Abstract: This paper proposes a new method for approximate string search, specifically candidate generation in spelling error correction, which is a task as follows. Given a misspelled word, the system finds words in a dictionary, which are most “similar” to the misspelled word. The paper proposes a probabilistic approach to the task, which is both accurate and efficient. The approach includes the use of a log linear model, a method for training the model, and an algorithm for finding the top k candidates. The log linear model is defined as a conditional probability distribution of a corrected word and a rule set for the correction conditioned on the misspelled word. The learning method employs the criterion in candidate generation as loss function. The retrieval algorithm is efficient and is guaranteed to find the optimal k candidates. Experimental results on large scale data show that the proposed approach improves upon existing methods in terms of accuracy in different settings.</p><p>3 0.83130592 <a title="11-lda-3" href="./acl-2011-Bootstrapping_coreference_resolution_using_word_associations.html">63 acl-2011-Bootstrapping coreference resolution using word associations</a></p>
<p>Author: Hamidreza Kobdani ; Hinrich Schuetze ; Michael Schiehlen ; Hans Kamp</p><p>Abstract: In this paper, we present an unsupervised framework that bootstraps a complete coreference resolution (CoRe) system from word associations mined from a large unlabeled corpus. We show that word associations are useful for CoRe – e.g., the strong association between Obama and President is an indicator of likely coreference. Association information has so far not been used in CoRe because it is sparse and difficult to learn from small labeled corpora. Since unlabeled text is readily available, our unsupervised approach addresses the sparseness problem. In a self-training framework, we train a decision tree on a corpus that is automatically labeled using word associations. We show that this unsupervised system has better CoRe performance than other learning approaches that do not use manually labeled data. .</p><p>4 0.8018955 <a title="11-lda-4" href="./acl-2011-Fine-Grained_Class_Label_Markup_of_Search_Queries.html">137 acl-2011-Fine-Grained Class Label Markup of Search Queries</a></p>
<p>Author: Joseph Reisinger ; Marius Pasca</p><p>Abstract: We develop a novel approach to the semantic analysis of short text segments and demonstrate its utility on a large corpus of Web search queries. Extracting meaning from short text segments is difficult as there is little semantic redundancy between terms; hence methods based on shallow semantic analysis may fail to accurately estimate meaning. Furthermore search queries lack explicit syntax often used to determine intent in question answering. In this paper we propose a hybrid model of semantic analysis combining explicit class-label extraction with a latent class PCFG. This class-label correlation (CLC) model admits a robust parallel approximation, allowing it to scale to large amounts of query data. We demonstrate its performance in terms of (1) its predicted label accuracy on polysemous queries and (2) its ability to accurately chunk queries into base constituents.</p><p>5 0.79336041 <a title="11-lda-5" href="./acl-2011-Monolingual_Alignment_by_Edit_Rate_Computation_on_Sentential_Paraphrase_Pairs.html">225 acl-2011-Monolingual Alignment by Edit Rate Computation on Sentential Paraphrase Pairs</a></p>
<p>Author: Houda Bouamor ; Aurelien Max ; Anne Vilnat</p><p>Abstract: In this paper, we present a novel way of tackling the monolingual alignment problem on pairs of sentential paraphrases by means of edit rate computation. In order to inform the edit rate, information in the form of subsentential paraphrases is provided by a range of techniques built for different purposes. We show that the tunable TER-PLUS metric from Machine Translation evaluation can achieve good performance on this task and that it can effectively exploit information coming from complementary sources.</p><p>6 0.79160815 <a title="11-lda-6" href="./acl-2011-Large-Scale_Cross-Document_Coreference_Using_Distributed_Inference_and_Hierarchical_Models.html">196 acl-2011-Large-Scale Cross-Document Coreference Using Distributed Inference and Hierarchical Models</a></p>
<p>7 0.78486133 <a title="11-lda-7" href="./acl-2011-A_Hierarchical_Model_of_Web_Summaries.html">14 acl-2011-A Hierarchical Model of Web Summaries</a></p>
<p>8 0.7840687 <a title="11-lda-8" href="./acl-2011-Can_Document_Selection_Help_Semi-supervised_Learning%3F_A_Case_Study_On_Event_Extraction.html">65 acl-2011-Can Document Selection Help Semi-supervised Learning? A Case Study On Event Extraction</a></p>
<p>9 0.78070736 <a title="11-lda-9" href="./acl-2011-Beam-Width_Prediction_for_Efficient_Context-Free_Parsing.html">58 acl-2011-Beam-Width Prediction for Efficient Context-Free Parsing</a></p>
<p>10 0.77845645 <a title="11-lda-10" href="./acl-2011-A_Hierarchical_Pitman-Yor_Process_HMM_for_Unsupervised_Part_of_Speech_Induction.html">15 acl-2011-A Hierarchical Pitman-Yor Process HMM for Unsupervised Part of Speech Induction</a></p>
<p>11 0.7764805 <a title="11-lda-11" href="./acl-2011-Unsupervised_Semantic_Role_Induction_via_Split-Merge_Clustering.html">324 acl-2011-Unsupervised Semantic Role Induction via Split-Merge Clustering</a></p>
<p>12 0.7762633 <a title="11-lda-12" href="./acl-2011-Deciphering_Foreign_Language.html">94 acl-2011-Deciphering Foreign Language</a></p>
<p>13 0.7746172 <a title="11-lda-13" href="./acl-2011-Joint_Identification_and_Segmentation_of_Domain-Specific_Dialogue_Acts_for_Conversational_Dialogue_Systems.html">185 acl-2011-Joint Identification and Segmentation of Domain-Specific Dialogue Acts for Conversational Dialogue Systems</a></p>
<p>14 0.77285862 <a title="11-lda-14" href="./acl-2011-Using_Bilingual_Parallel_Corpora_for_Cross-Lingual_Textual_Entailment.html">327 acl-2011-Using Bilingual Parallel Corpora for Cross-Lingual Textual Entailment</a></p>
<p>15 0.7721867 <a title="11-lda-15" href="./acl-2011-Learning_Hierarchical_Translation_Structure_with_Linguistic_Annotations.html">202 acl-2011-Learning Hierarchical Translation Structure with Linguistic Annotations</a></p>
<p>16 0.77201355 <a title="11-lda-16" href="./acl-2011-Exploiting_Syntactico-Semantic_Structures_for_Relation_Extraction.html">126 acl-2011-Exploiting Syntactico-Semantic Structures for Relation Extraction</a></p>
<p>17 0.77166921 <a title="11-lda-17" href="./acl-2011-Peeling_Back_the_Layers%3A_Detecting_Event_Role_Fillers_in_Secondary_Contexts.html">244 acl-2011-Peeling Back the Layers: Detecting Event Role Fillers in Secondary Contexts</a></p>
<p>18 0.77156985 <a title="11-lda-18" href="./acl-2011-Faster_and_Smaller_N-Gram_Language_Models.html">135 acl-2011-Faster and Smaller N-Gram Language Models</a></p>
<p>19 0.77075982 <a title="11-lda-19" href="./acl-2011-Lexically-Triggered_Hidden_Markov_Models_for_Clinical_Document_Coding.html">209 acl-2011-Lexically-Triggered Hidden Markov Models for Clinical Document Coding</a></p>
<p>20 0.77069294 <a title="11-lda-20" href="./acl-2011-Interactive_Topic_Modeling.html">178 acl-2011-Interactive Topic Modeling</a></p>
<br/><br/><br/>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-48522588-1', 'makerhacker.github.io');
ga('send', 'pageview');
</script>

</body>
</html>
