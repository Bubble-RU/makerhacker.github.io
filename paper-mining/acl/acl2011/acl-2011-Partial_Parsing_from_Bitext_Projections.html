<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>243 acl-2011-Partial Parsing from Bitext Projections</title>
</head>

<body>
<p><a title="acl" href="../acl_home.html">acl</a> <a title="acl-2011" href="../home/acl2011_home.html">acl2011</a> <a title="acl-2011-243" href="#">acl2011-243</a> knowledge-graph by maker-knowledge-mining</p><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- maker adsense -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-5027806277543591"
     data-ad-slot="4192012269"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>243 acl-2011-Partial Parsing from Bitext Projections</h1>
<br/><p>Source: <a title="acl-2011-243-pdf" href="http://aclweb.org/anthology//P/P11/P11-1160.pdf">pdf</a></p><p>Author: Prashanth Mannem ; Aswarth Dara</p><p>Abstract: Recent work has shown how a parallel corpus can be leveraged to build syntactic parser for a target language by projecting automatic source parse onto the target sentence using word alignments. The projected target dependency parses are not always fully connected to be useful for training traditional dependency parsers. In this paper, we present a greedy non-directional parsing algorithm which doesn’t need a fully connected parse and can learn from partial parses by utilizing available structural and syntactic information in them. Our parser achieved statistically significant improvements over a baseline system that trains on only fully connected parses for Bulgarian, Spanish and Hindi. It also gave a significant improvement over previously reported results for Bulgarian and set a benchmark for Hindi.</p><p>Reference: <a title="acl-2011-243-reference" href="../acl2011_reference/acl-2011-Partial_Parsing_from_Bitext_Projections_reference.html">text</a></p><br/><h2>Summary: the most important sentenses genereted by tfidf model</h2><p>sentIndex sentText sentNum sentScore</p><p>1 a  Abstract Recent work has shown how a parallel corpus can be leveraged to build syntactic parser for a target language by projecting automatic source parse onto the target sentence using word alignments. [sent-2, score-0.258]
</p><p>2 The projected target dependency parses are not always fully connected to be useful for training traditional dependency parsers. [sent-3, score-0.923]
</p><p>3 In this paper, we present a greedy non-directional parsing algorithm which doesn’t need a fully connected parse and can learn from partial parses by utilizing available structural and syntactic information in them. [sent-4, score-0.866]
</p><p>4 Our parser achieved statistically significant improvements over a baseline system  that trains on only fully connected parses for Bulgarian, Spanish and Hindi. [sent-5, score-0.463]
</p><p>5 The parse trees given by the parser on the source sentences in the parallel data are projected onto the target sentence using the word alignments from the alignment tool. [sent-13, score-0.523]
</p><p>6 in i target languages, the projected parses are not always fully connected and can have edges missing (Hwa et al. [sent-18, score-0.695]
</p><p>7 Nonliteral translations and divergences in the syntax of the two languages also lead to incomplete projected parse trees. [sent-21, score-0.384]
</p><p>8 For the same sentence, Figure 2 is a sample partial dependency parse projected using an automatic source parser on aligned text. [sent-23, score-0.849]
</p><p>9 This parse is not fully connected with the words banaa, kottaige and dikhataa left without any parents. [sent-24, score-0.361]
</p><p>10 But these parsers can not directly be used to learn from partially connected parses (Hwa et al. [sent-28, score-0.451]
</p><p>11 In the projected Hindi treebank (section 4) that was extracted from English-Hindi parallel text, only 5. [sent-31, score-0.371]
</p><p>12 c s 2o0ci1a1ti Aons fo cria Ctio mnp fourta Ctio mnaplu Ltaintigouniaslti Lcisn,g puaigsetsic 1s597–1606,  Spanish and Bulgarian projected data extracted by Ganchev et al. [sent-35, score-0.301]
</p><p>13 Learning from data with such high proportions of partially connected dependency parses requires special parsing algorithms which are not bound by connectedness. [sent-39, score-0.56]
</p><p>14 during inference), the parser should output fully connected dependency tree. [sent-43, score-0.313]
</p><p>15 cottage banaa  huaa  kottaige  very  beautiful  look  Be. [sent-45, score-0.32]
</p><p>16 bahuta  sundara  dikhataa  hai  Figure 2: A sample dependency parse with partial parses In this paper, we present a dependency parsing algorithm which can train on partial projected parses and can take rich syntactic information as features for learning. [sent-47, score-1.99]
</p><p>17 The parsing algorithm con-  structs the partial parses in a bottom-up manner by performing a greedy search over all possible relations and choosing the best one at each step without following either left-to-right or right-to-left traversal. [sent-48, score-0.707]
</p><p>18 We also propose an extended partial parsing algorithm that can learn from partial parses whose yields are partially contiguous. [sent-50, score-0.908]
</p><p>19 Apart from bitext projections, this work can be extended to other cases where learning from partial structures is required. [sent-51, score-0.296]
</p><p>20 For example, while bootstrapping parsers high confidence parses are extracted and trained upon (Steedman et al. [sent-52, score-0.321]
</p><p>21 In cases where these parses are few, learning from partial parses might be beneficial. [sent-54, score-0.783]
</p><p>22 We train our parser on projected Hindi, Bulgarian and Spanish treebanks and show statistically significant improvements in accuracies between training on fully connected trees and learning from partial parses. [sent-55, score-0.795]
</p><p>23 2  Related Work  Learning from partial parses has been dealt in different ways in the literature. [sent-56, score-0.519]
</p><p>24 (2009) handle partial projected parses by avoiding committing to entire projected tree during training. [sent-60, score-1.121]
</p><p>25 The posterior regularization based framework constrains the projected syntactic relations to hold approximately and only in expectation. [sent-61, score-0.355]
</p><p>26 Jiang and Liu (2010) refer to alignment matrix and a dynamic programming search algorithm to obtain better projected dependency trees. [sent-62, score-0.449]
</p><p>27 They deal with partial projections by breaking down the projected parse into a set of edges and training on the set of projected relations rather than on trees. [sent-63, score-1.055]
</p><p>28 (2005) requires full projected parses to train their parser, Ganchev et al. [sent-65, score-0.565]
</p><p>29 (2009) and Jiang and Liu (2010) can learn from partially  projected trees. [sent-66, score-0.349]
</p><p>30 , 2009) doesn’t allow for richer syntactic context and it doesn’t learn from all the relations in the partial dependency parse. [sent-68, score-0.423]
</p><p>31 By treating each relation in the projected dependency data independently as a classification instance for parsing, Jiang and Liu (2010) sacrifice the context of the relations such as global structural context, neighboring relations that are crucial for dependency analysis. [sent-69, score-0.637]
</p><p>32 The parser proposed in this work (section 3) learns from partial trees by using the available structural information in it and also in neighboring partial parses. [sent-71, score-0.579]
</p><p>33 We evaluated our system (section 5) on Bulgarian and Spanish projected dependency data used in (Ganchev et al. [sent-72, score-0.415]
</p><p>34 The same could not be carried out for Chinese (which was the language (Jiang and Liu, 2010) worked on) due to the unavailability of projected data used in their work. [sent-74, score-0.301]
</p><p>35 Given a sentence W=w0 · · · wn with a set of directed arcs A on the words ·i·n· W, wi → wj denotes a dependency arc from wi to wj, (wi,wj) ? [sent-81, score-0.754]
</p><p>36 wi is the parent in the arc and wj is the child in the arc. [sent-83, score-0.421]
</p><p>37 A node wi is unconnected if it does not have an incoming arc. [sent-88, score-0.314]
</p><p>38 R is the set of all such unconnected nodes in the dependency graph. [sent-89, score-0.353]
</p><p>39 gAu partial parse nraoaot,ed k oatt ntoadieg wi ddeinkohteadt by ρ(wi) pisa trhtiea set orfs arcs ttehadt can obdee traversed from node wi. [sent-91, score-0.576]
</p><p>40 The yield of a partial parse ρ(wi) is the set of nodes dominated by it. [sent-92, score-0.397]
</p><p>41 The span of the partial tree is the first and last words in its yield. [sent-94, score-0.255]
</p><p>42 A fully connected dependency graph would have only one element w0 in R and the dependency graph rooted at w0 as the only (fully connected) parse in %(R). [sent-97, score-0.441]
</p><p>43 We assume the combined yield of %(R) spans the entire sentence and each of the partial parses in %(R) to be contiguous and non-overlapping with one another. [sent-98, score-0.623]
</p><p>44 A partial parse is contiguous if its yield is contiguous i. [sent-99, score-0.518]
</p><p>45 A partial parse ρ(wi) is non-overlapping if the intersection of its yield π(wi) with yields of all other partial parses is empty. [sent-103, score-0.885]
</p><p>46 1  Greedy Non-directional Partial Parsing Algorithm (GNPPA) Given the sentence W and the set of unconnected nodes R, the parser follows a non-directional greedy approach to establish relations in a bottom up manner. [sent-105, score-0.41]
</p><p>47 Algorithm 1 lists the outline of the greedy nondirectional partial parsing algorithm (GNPPA). [sent-108, score-0.419]
</p><p>48 builtPPs maintains a list of all the partial parses that have been built. [sent-109, score-0.519]
</p><p>49 It is initialized in line 1 by considering each word as a separate partial parse with just one node. [sent-110, score-0.338]
</p><p>50 add(bestArc) updateCandidateArcs(bestArc, candidateArcs, builtPPs, unConn) 9: end while 10: return builtPPs  Once initialized, the candidate arc with the highest score (line 4) is chosen and accepted into builtPPs. [sent-122, score-0.255]
</p><p>51 This involves replacing the best arc’s child partial parse ρ(arc. [sent-123, score-0.376]
</p><p>52 parent) over which the arc has been formed with the arc ρ(arc. [sent-125, score-0.444]
</p><p>53 aIrne Figure  3f, to accept the best candidate arc ρ(banaa) → ρ(pahaada), hthee b parser wdioduatled remove athnea nao)d →es ρ(banaa) and ρ(pahaada) in builtPPs and add ρ(banaa) → ρ(pahaada) to builtPPs (see Figure 3g). [sent-128, score-0.324]
</p><p>54 After the best arc is accepted, the candidateArcs has to be updated (line 8) to remove the arcs that are no longer valid and add new arcs in the context of the updated builtPPs. [sent-129, score-0.54]
</p><p>55 First, all the arcs that end on the child are removed (lines 3-7) along with the arc from child to parent. [sent-131, score-0.43]
</p><p>56 Then, the immedi1600 ately previous and next partial parses of the best arc in builtPPs are retrieved (lines 8-9) to add possible candidate arcs between them and the partial parse representing the best arc (lines 10-23). [sent-132, score-1.466]
</p><p>57 In the example, between Figures 3b and 3c, the arcs ρ(kott aige) → ρ(bahut a) and ρ(bahuta) → ρ(sundara) are bfiarhstu tream)ov aendd a ρn(db thheu arc ρ(kott aige) → ρ(sundara) vise dad adnedd to canρd(idkaotetAtracsi. [sent-133, score-0.354]
</p><p>58 g Cea)r e→ →is ρta(skeunn to arvao)id i adding arcs ctahnatend on unconnected nodes listed in R. [sent-134, score-0.371]
</p><p>59 child = baParent) then 5: remove arc 6: end if 7: end for 8: prevPP = builtPPs. [sent-142, score-0.26]
</p><p>60 2  Learning  The algorithm described in the previous section uses a weight vector →w to compute the best arc from the list of candidate arcs. [sent-153, score-0.289]
</p><p>61 For a training sample with sentence w0 · · · wn, projected partial parses projectedPPs={ρ(ri) · · · ρ(rm)}, d u pncarotninalec ptaerds wso prrdosj ucnteCdoPnPns =an{ρd( weight vecto)r} →,w u, ntcheo nbnueilcttPedPs w aonrdd sca unndCidoantneA arncds are i gnhi-t tiated as in algorithm 1. [sent-156, score-0.854]
</p><p>62 If this arc belongs to the parses in projectedPPs, builtPPs and candidateArcs are updated similar to the operations in  arcs that are added to candidateArcs algorithm 1. [sent-158, score-0.679]
</p><p>63 If it doesn’t, it is treated as a negative sample and a corresponding positive candidate arc which is present both projectedPPs and candidateArcs is selected (lines 11-12). [sent-159, score-0.255]
</p><p>64 We call such non-  contiguous partial parses whose yields encompass the yield of an other partial parse as partially con-  tiguous. [sent-177, score-1.009]
</p><p>65 Partially contiguous parses are common in the projected data and would not be parsable by the algorithm 1(ρ(dikhataa) → ρ(kott aige) twheou alldg nooritt h bme identified). [sent-178, score-0.675]
</p><p>66 cottage banaa huaa kottaige  very bahuta  beautiful look Be. [sent-180, score-0.379]
</p><p>67 sundara dikhataa hai  Figure 5: Dependency parse with a partially contiguous partial parse In order to identify and learn from relations which are part of partially contiguous partial parses, we propose an extension to GNPPA. [sent-182, score-1.173]
</p><p>68 If the immediate previous or the next partial parses over which arcs are to be formed are designated unconnected nodes, the parser looks further for a partial parse over which it can form arcs. [sent-184, score-1.266]
</p><p>69 For example, in Figure 4b, the  arc ρ(para)  →  ρ(banaa)  can not be added to  tahrec ρc(apndaridaa)teA →rcs ρ bsinancea baa) cnaana ios a designated unconnected node in unConn. [sent-185, score-0.462]
</p><p>70 The E-GNPPA looks over the unconnected node and adds the arc ρ(para) → ρ(huaa) to the candidate arcs list ρc(apndairdaa)teA →rcs ρ. [sent-186, score-0.627]
</p><p>71 previousPP() and nextPP() return the immediate previous and next partial parses of the arc in builtPPs at Table  the state. [sent-207, score-0.741]
</p><p>72 Information from the partial parses (structural info) such as left and right most children of the parent node in the relation, left and right siblings of the child node in the relation are also used. [sent-222, score-0.649]
</p><p>73 4  Hindi Projected Dependency Treebank  We conducted experiments on English-Hindi parallel data by transferring syntactic information from English to Hindi to build a projected dependency treebank for Hindi. [sent-227, score-0.485]
</p><p>74 , 2007) was used to POS tag the source sentences and the parses were obtained using the first order MST parser (McDonald et al. [sent-232, score-0.36]
</p><p>75 The source dependencies are projected using an approach similar to (Hwa et al. [sent-237, score-0.328]
</p><p>76 While they use post-projection transformations on the projected parse to account for annotation differences, we use pre-projection transformations on the source parse. [sent-239, score-0.411]
</p><p>77 duces acyclic parses which could be unconnected and non-projective. [sent-243, score-0.472]
</p><p>78 1 Annotation Differences in Hindi and English Before projecting the source parses onto the target sentence, the parses are transformed to reflect the annotation scheme differences in English and Hindi. [sent-245, score-0.591]
</p><p>79 While English dependency parses reflect the PTB annotation style (Marcus et al. [sent-246, score-0.378]
</p><p>80 While the Hindi projected treebank was obtained using the method described in section 4, Bulgarian and Spanish projected datasets were obtained using the approach in (Ganchev et al. [sent-260, score-0.629]
</p><p>81 (2009) 1603  Table 2: Statistics of the Hindi, Bulgarian and Spanish projected treebanks used for experiments. [sent-263, score-0.301]
</p><p>82 N(Full trees) is the number of parses which are fully connected. [sent-268, score-0.312]
</p><p>83 The Hindi, Bulgarian and Spanish projected dependency treebanks have 44760, 39516 and 76958 sentences respectively. [sent-272, score-0.415]
</p><p>84 of contiguous partial trees that can be learned by GNPPA parser etc. [sent-279, score-0.4]
</p><p>85 The errors introduced in the projected parses by errors in word alignment, source parser and projection are not consistent enough to be exploited to select the better parses from the entire projected data. [sent-282, score-1.269]
</p><p>86 Traditional dependency parsers which only train from fully connected trees would not be able to learn from these sentences. [sent-285, score-0.301]
</p><p>87 P(GNPPA) is the percentage of relations in the data that are learned by the GNPPA parser satisfying the contiguous partial tree constraint and P(E-GNPPA) is the per2Exactly 10K sentences were selected in order to compare our results with those of (Ganchev et al. [sent-286, score-0.454]
</p><p>88 97u60n1*c†t Table 3: UAS for Hindi, Bulgarian and Spanish with the baseline, GNPPA and E-GNPPA parsers trained on 10k parses selected randomly. [sent-295, score-0.321]
</p><p>89 A baseline parser was built to compare learning from partial parses with learning from fully connected parses. [sent-309, score-0.718]
</p><p>90 Full parses are constructed from partial parses in the projected data by randomly assigning parents to unconnected parents, similar to the work in (Hwa et al. [sent-310, score-1.378]
</p><p>91 The unconnected words in the parse are selected randomly one by one and are assigned parents randomly to complete the parse. [sent-312, score-0.377]
</p><p>92 The parser is then trained with the GNPPA algorithm on these fully connected parses to be used as the baseline. [sent-314, score-0.497]
</p><p>93 In our work, while creating the data for the baseline by assigning random parents to unconnected words, acyclicity and projectivity con1604  GancBhPaeasvre-BlseinraeselineBu57lg52. [sent-322, score-0.413]
</p><p>94 Though their training data size is also 10K, the training data is different in both our works due to the difference in the method of choosing 10K sentences from the large projected treebanks. [sent-338, score-0.301]
</p><p>95 This shows that learning from partial parses is effective when compared to imposing the connected constraint on the partially projected dependency parse. [sent-340, score-1.064]
</p><p>96 The E-GNPPA which also learns from partially contiguous partial parses achieved statistically significant gains for all the three languages. [sent-342, score-0.643]
</p><p>97 6  Conclusion  We presented a non-directional parsing algorithm that can learn from partial parses using syntactic and contextual information as features. [sent-349, score-0.605]
</p><p>98 A Hindi projected dependency treebank was developed from English-Hindi bilingual data and experiments were conducted for three languages Hindi, Bulgarian and Spanish. [sent-350, score-0.442]
</p><p>99 Statistically significant improvements were achieved by our partial parsers over the baseline system. [sent-351, score-0.312]
</p><p>100 The partial parsing algorithms presented in this paper are not specific to bitext projections and can be used for learning from partial parses in any setting. [sent-352, score-0.928]
</p>
<br/>
<h2>similar papers computed by tfidf model</h2><h3>tfidf for this paper:</h3><p>wordName wordTfidf (topN-words)</p>
<p>[('gnppa', 0.312), ('projected', 0.301), ('parses', 0.264), ('partial', 0.255), ('candidatearcs', 0.252), ('builtpps', 0.223), ('arc', 0.222), ('unconnected', 0.208), ('bestarc', 0.193), ('bulgarian', 0.192), ('hindi', 0.175), ('ganchev', 0.149), ('unconn', 0.149), ('banaa', 0.134), ('arcs', 0.132), ('dependency', 0.114), ('pahaada', 0.104), ('dikhataa', 0.089), ('hwa', 0.089), ('parents', 0.086), ('parse', 0.083), ('connected', 0.082), ('contiguous', 0.076), ('spanish', 0.074), ('nextpp', 0.074), ('projectedpps', 0.074), ('sundara', 0.074), ('wi', 0.074), ('parser', 0.069), ('para', 0.068), ('projections', 0.061), ('projectivity', 0.06), ('acyclicity', 0.059), ('aige', 0.059), ('bahuta', 0.059), ('huaa', 0.059), ('kott', 0.059), ('kottaige', 0.059), ('wj', 0.059), ('parsers', 0.057), ('relations', 0.054), ('parsing', 0.052), ('wn', 0.052), ('ci', 0.051), ('coordination', 0.05), ('fully', 0.048), ('partially', 0.048), ('greedy', 0.048), ('nivre', 0.045), ('bachild', 0.045), ('husain', 0.045), ('prashanth', 0.045), ('prevpp', 0.045), ('updatecandidatearcs', 0.045), ('parallel', 0.043), ('projection', 0.043), ('bitext', 0.041), ('morristown', 0.041), ('accuracies', 0.04), ('hill', 0.04), ('cottage', 0.039), ('lines', 0.038), ('doesn', 0.038), ('child', 0.038), ('nj', 0.036), ('kuhlmann', 0.036), ('projecting', 0.036), ('jiang', 0.035), ('icon', 0.034), ('rm', 0.034), ('joakim', 0.034), ('algorithm', 0.034), ('candidate', 0.033), ('head', 0.032), ('node', 0.032), ('hai', 0.032), ('nodes', 0.031), ('yamada', 0.031), ('allowedarcs', 0.03), ('bahut', 0.03), ('baparent', 0.03), ('begum', 0.03), ('cbuainltdpidpaste', 0.03), ('egnppa', 0.03), ('initcandidatearcs', 0.03), ('mannem', 0.03), ('nondirectional', 0.03), ('rida', 0.03), ('updatecandidatearcsextended', 0.03), ('wwn', 0.03), ('beautiful', 0.029), ('parent', 0.028), ('argmax', 0.028), ('bidirectional', 0.028), ('yield', 0.028), ('denotes', 0.027), ('source', 0.027), ('treebank', 0.027), ('updated', 0.027), ('rcs', 0.026)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 1.0000002 <a title="243-tfidf-1" href="./acl-2011-Partial_Parsing_from_Bitext_Projections.html">243 acl-2011-Partial Parsing from Bitext Projections</a></p>
<p>Author: Prashanth Mannem ; Aswarth Dara</p><p>Abstract: Recent work has shown how a parallel corpus can be leveraged to build syntactic parser for a target language by projecting automatic source parse onto the target sentence using word alignments. The projected target dependency parses are not always fully connected to be useful for training traditional dependency parsers. In this paper, we present a greedy non-directional parsing algorithm which doesn’t need a fully connected parse and can learn from partial parses by utilizing available structural and syntactic information in them. Our parser achieved statistically significant improvements over a baseline system that trains on only fully connected parses for Bulgarian, Spanish and Hindi. It also gave a significant improvement over previously reported results for Bulgarian and set a benchmark for Hindi.</p><p>2 0.15633591 <a title="243-tfidf-2" href="./acl-2011-Data_point_selection_for_cross-language_adaptation_of_dependency_parsers.html">92 acl-2011-Data point selection for cross-language adaptation of dependency parsers</a></p>
<p>Author: Anders Sgaard</p><p>Abstract: We consider a very simple, yet effective, approach to cross language adaptation of dependency parsers. We first remove lexical items from the treebanks and map part-of-speech tags into a common tagset. We then train a language model on tag sequences in otherwise unlabeled target data and rank labeled source data by perplexity per word of tag sequences from less similar to most similar to the target. We then train our target language parser on the most similar data points in the source labeled data. The strategy achieves much better results than a non-adapted baseline and stateof-the-art unsupervised dependency parsing, and results are comparable to more complex projection-based cross language adaptation algorithms.</p><p>3 0.1481013 <a title="243-tfidf-3" href="./acl-2011-Joint_Training_of_Dependency_Parsing_Filters_through_Latent_Support_Vector_Machines.html">186 acl-2011-Joint Training of Dependency Parsing Filters through Latent Support Vector Machines</a></p>
<p>Author: Colin Cherry ; Shane Bergsma</p><p>Abstract: Graph-based dependency parsing can be sped up significantly if implausible arcs are eliminated from the search-space before parsing begins. State-of-the-art methods for arc filtering use separate classifiers to make pointwise decisions about the tree; they label tokens with roles such as root, leaf, or attaches-tothe-left, and then filter arcs accordingly. Because these classifiers overlap substantially in their filtering consequences, we propose to train them jointly, so that each classifier can focus on the gaps of the others. We integrate the various pointwise decisions as latent variables in a single arc-level SVM classifier. This novel framework allows us to combine nine pointwise filters, and adjust their sensitivity using a shared threshold based on arc length. Our system filters 32% more arcs than the independently-trained classifiers, without reducing filtering speed. This leads to faster parsing with no reduction in accuracy.</p><p>4 0.11821541 <a title="243-tfidf-4" href="./acl-2011-Getting_the_Most_out_of_Transition-based_Dependency_Parsing.html">143 acl-2011-Getting the Most out of Transition-based Dependency Parsing</a></p>
<p>Author: Jinho D. Choi ; Martha Palmer</p><p>Abstract: This paper suggests two ways of improving transition-based, non-projective dependency parsing. First, we add a transition to an existing non-projective parsing algorithm, so it can perform either projective or non-projective parsing as needed. Second, we present a bootstrapping technique that narrows down discrepancies between gold-standard and automatic parses used as features. The new addition to the algorithm shows a clear advantage in parsing speed. The bootstrapping technique gives a significant improvement to parsing accuracy, showing near state-of-theart performance with respect to other parsing approaches evaluated on the same data set.</p><p>5 0.11659877 <a title="243-tfidf-5" href="./acl-2011-Transition-based_Dependency_Parsing_with_Rich_Non-local_Features.html">309 acl-2011-Transition-based Dependency Parsing with Rich Non-local Features</a></p>
<p>Author: Yue Zhang ; Joakim Nivre</p><p>Abstract: Transition-based dependency parsers generally use heuristic decoding algorithms but can accommodate arbitrarily rich feature representations. In this paper, we show that we can improve the accuracy of such parsers by considering even richer feature sets than those employed in previous systems. In the standard Penn Treebank setup, our novel features improve attachment score form 91.4% to 92.9%, giving the best results so far for transitionbased parsing and rivaling the best results overall. For the Chinese Treebank, they give a signficant improvement of the state of the art. An open source release of our parser is freely available.</p><p>6 0.10313942 <a title="243-tfidf-6" href="./acl-2011-An_Ensemble_Model_that_Combines_Syntactic_and_Semantic_Clustering_for_Discriminative_Dependency_Parsing.html">39 acl-2011-An Ensemble Model that Combines Syntactic and Semantic Clustering for Discriminative Dependency Parsing</a></p>
<p>7 0.099330693 <a title="243-tfidf-7" href="./acl-2011-Shift-Reduce_CCG_Parsing.html">282 acl-2011-Shift-Reduce CCG Parsing</a></p>
<p>8 0.098024912 <a title="243-tfidf-8" href="./acl-2011-Lexicographic_Semirings_for_Exact_Automata_Encoding_of_Sequence_Models.html">210 acl-2011-Lexicographic Semirings for Exact Automata Encoding of Sequence Models</a></p>
<p>9 0.094983377 <a title="243-tfidf-9" href="./acl-2011-Exploiting_Web-Derived_Selectional_Preference_to_Improve_Statistical_Dependency_Parsing.html">127 acl-2011-Exploiting Web-Derived Selectional Preference to Improve Statistical Dependency Parsing</a></p>
<p>10 0.087805398 <a title="243-tfidf-10" href="./acl-2011-Dynamic_Programming_Algorithms_for_Transition-Based_Dependency_Parsers.html">107 acl-2011-Dynamic Programming Algorithms for Transition-Based Dependency Parsers</a></p>
<p>11 0.087486617 <a title="243-tfidf-11" href="./acl-2011-full-for-print.html">342 acl-2011-full-for-print</a></p>
<p>12 0.087434255 <a title="243-tfidf-12" href="./acl-2011-Better_Automatic_Treebank_Conversion_Using_A_Feature-Based_Approach.html">59 acl-2011-Better Automatic Treebank Conversion Using A Feature-Based Approach</a></p>
<p>13 0.086610943 <a title="243-tfidf-13" href="./acl-2011-Effects_of_Noun_Phrase_Bracketing_in_Dependency_Parsing_and_Machine_Translation.html">111 acl-2011-Effects of Noun Phrase Bracketing in Dependency Parsing and Machine Translation</a></p>
<p>14 0.086559683 <a title="243-tfidf-14" href="./acl-2011-Together_We_Can%3A_Bilingual_Bootstrapping_for_WSD.html">304 acl-2011-Together We Can: Bilingual Bootstrapping for WSD</a></p>
<p>15 0.080939367 <a title="243-tfidf-15" href="./acl-2011-Automatic_Detection_and_Correction_of_Errors_in_Dependency_Treebanks.html">48 acl-2011-Automatic Detection and Correction of Errors in Dependency Treebanks</a></p>
<p>16 0.079217747 <a title="243-tfidf-16" href="./acl-2011-Improving_Dependency_Parsing_with_Semantic_Classes.html">167 acl-2011-Improving Dependency Parsing with Semantic Classes</a></p>
<p>17 0.077423245 <a title="243-tfidf-17" href="./acl-2011-Web-Scale_Features_for_Full-Scale_Parsing.html">333 acl-2011-Web-Scale Features for Full-Scale Parsing</a></p>
<p>18 0.075263575 <a title="243-tfidf-18" href="./acl-2011-Hindi_to_Punjabi_Machine_Translation_System.html">151 acl-2011-Hindi to Punjabi Machine Translation System</a></p>
<p>19 0.074437924 <a title="243-tfidf-19" href="./acl-2011-Learning_to_Transform_and_Select_Elementary_Trees_for_Improved_Syntax-based_Machine_Translations.html">206 acl-2011-Learning to Transform and Select Elementary Trees for Improved Syntax-based Machine Translations</a></p>
<p>20 0.07117524 <a title="243-tfidf-20" href="./acl-2011-Unsupervised_Part-of-Speech_Tagging_with_Bilingual_Graph-Based_Projections.html">323 acl-2011-Unsupervised Part-of-Speech Tagging with Bilingual Graph-Based Projections</a></p>
<br/>
<h2>similar papers computed by <a title="lsi-model" href="../home/acl2011_lsi.html">lsi model</a></h2><h3>lsi for this paper:</h3><p>topicId topicWeight</p>
<p>[(0, 0.171), (1, -0.062), (2, -0.035), (3, -0.169), (4, -0.009), (5, -0.038), (6, 0.045), (7, 0.062), (8, 0.05), (9, 0.004), (10, 0.03), (11, 0.028), (12, 0.044), (13, -0.057), (14, -0.003), (15, 0.034), (16, 0.032), (17, -0.032), (18, 0.025), (19, -0.05), (20, -0.092), (21, -0.035), (22, 0.023), (23, 0.041), (24, 0.037), (25, -0.082), (26, -0.013), (27, 0.073), (28, 0.014), (29, -0.034), (30, 0.04), (31, 0.006), (32, 0.057), (33, -0.016), (34, 0.055), (35, -0.059), (36, -0.005), (37, 0.074), (38, -0.036), (39, -0.029), (40, -0.034), (41, -0.107), (42, 0.056), (43, -0.026), (44, -0.066), (45, -0.096), (46, -0.071), (47, -0.036), (48, 0.006), (49, 0.043)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 0.92999214 <a title="243-lsi-1" href="./acl-2011-Partial_Parsing_from_Bitext_Projections.html">243 acl-2011-Partial Parsing from Bitext Projections</a></p>
<p>Author: Prashanth Mannem ; Aswarth Dara</p><p>Abstract: Recent work has shown how a parallel corpus can be leveraged to build syntactic parser for a target language by projecting automatic source parse onto the target sentence using word alignments. The projected target dependency parses are not always fully connected to be useful for training traditional dependency parsers. In this paper, we present a greedy non-directional parsing algorithm which doesn’t need a fully connected parse and can learn from partial parses by utilizing available structural and syntactic information in them. Our parser achieved statistically significant improvements over a baseline system that trains on only fully connected parses for Bulgarian, Spanish and Hindi. It also gave a significant improvement over previously reported results for Bulgarian and set a benchmark for Hindi.</p><p>2 0.82375759 <a title="243-lsi-2" href="./acl-2011-Dynamic_Programming_Algorithms_for_Transition-Based_Dependency_Parsers.html">107 acl-2011-Dynamic Programming Algorithms for Transition-Based Dependency Parsers</a></p>
<p>Author: Marco Kuhlmann ; Carlos Gomez-Rodriguez ; Giorgio Satta</p><p>Abstract: We develop a general dynamic programming technique for the tabulation of transition-based dependency parsers, and apply it to obtain novel, polynomial-time algorithms for parsing with the arc-standard and arc-eager models. We also show how to reverse our technique to obtain new transition-based dependency parsers from existing tabular methods. Additionally, we provide a detailed discussion of the conditions under which the feature models commonly used in transition-based parsing can be integrated into our algorithms.</p><p>3 0.74112684 <a title="243-lsi-3" href="./acl-2011-Getting_the_Most_out_of_Transition-based_Dependency_Parsing.html">143 acl-2011-Getting the Most out of Transition-based Dependency Parsing</a></p>
<p>Author: Jinho D. Choi ; Martha Palmer</p><p>Abstract: This paper suggests two ways of improving transition-based, non-projective dependency parsing. First, we add a transition to an existing non-projective parsing algorithm, so it can perform either projective or non-projective parsing as needed. Second, we present a bootstrapping technique that narrows down discrepancies between gold-standard and automatic parses used as features. The new addition to the algorithm shows a clear advantage in parsing speed. The bootstrapping technique gives a significant improvement to parsing accuracy, showing near state-of-theart performance with respect to other parsing approaches evaluated on the same data set.</p><p>4 0.67845714 <a title="243-lsi-4" href="./acl-2011-Joint_Training_of_Dependency_Parsing_Filters_through_Latent_Support_Vector_Machines.html">186 acl-2011-Joint Training of Dependency Parsing Filters through Latent Support Vector Machines</a></p>
<p>Author: Colin Cherry ; Shane Bergsma</p><p>Abstract: Graph-based dependency parsing can be sped up significantly if implausible arcs are eliminated from the search-space before parsing begins. State-of-the-art methods for arc filtering use separate classifiers to make pointwise decisions about the tree; they label tokens with roles such as root, leaf, or attaches-tothe-left, and then filter arcs accordingly. Because these classifiers overlap substantially in their filtering consequences, we propose to train them jointly, so that each classifier can focus on the gaps of the others. We integrate the various pointwise decisions as latent variables in a single arc-level SVM classifier. This novel framework allows us to combine nine pointwise filters, and adjust their sensitivity using a shared threshold based on arc length. Our system filters 32% more arcs than the independently-trained classifiers, without reducing filtering speed. This leads to faster parsing with no reduction in accuracy.</p><p>5 0.64760947 <a title="243-lsi-5" href="./acl-2011-Data_point_selection_for_cross-language_adaptation_of_dependency_parsers.html">92 acl-2011-Data point selection for cross-language adaptation of dependency parsers</a></p>
<p>Author: Anders Sgaard</p><p>Abstract: We consider a very simple, yet effective, approach to cross language adaptation of dependency parsers. We first remove lexical items from the treebanks and map part-of-speech tags into a common tagset. We then train a language model on tag sequences in otherwise unlabeled target data and rank labeled source data by perplexity per word of tag sequences from less similar to most similar to the target. We then train our target language parser on the most similar data points in the source labeled data. The strategy achieves much better results than a non-adapted baseline and stateof-the-art unsupervised dependency parsing, and results are comparable to more complex projection-based cross language adaptation algorithms.</p><p>6 0.64734757 <a title="243-lsi-6" href="./acl-2011-Transition-based_Dependency_Parsing_with_Rich_Non-local_Features.html">309 acl-2011-Transition-based Dependency Parsing with Rich Non-local Features</a></p>
<p>7 0.64250267 <a title="243-lsi-7" href="./acl-2011-Optimistic_Backtracking_-_A_Backtracking_Overlay_for_Deterministic_Incremental_Parsing.html">236 acl-2011-Optimistic Backtracking - A Backtracking Overlay for Deterministic Incremental Parsing</a></p>
<p>8 0.63868618 <a title="243-lsi-8" href="./acl-2011-Neutralizing_Linguistically_Problematic_Annotations_in_Unsupervised_Dependency_Parsing_Evaluation.html">230 acl-2011-Neutralizing Linguistically Problematic Annotations in Unsupervised Dependency Parsing Evaluation</a></p>
<p>9 0.63842821 <a title="243-lsi-9" href="./acl-2011-Temporal_Restricted_Boltzmann_Machines_for_Dependency_Parsing.html">295 acl-2011-Temporal Restricted Boltzmann Machines for Dependency Parsing</a></p>
<p>10 0.63762122 <a title="243-lsi-10" href="./acl-2011-Exploiting_Web-Derived_Selectional_Preference_to_Improve_Statistical_Dependency_Parsing.html">127 acl-2011-Exploiting Web-Derived Selectional Preference to Improve Statistical Dependency Parsing</a></p>
<p>11 0.60627627 <a title="243-lsi-11" href="./acl-2011-An_Ensemble_Model_that_Combines_Syntactic_and_Semantic_Clustering_for_Discriminative_Dependency_Parsing.html">39 acl-2011-An Ensemble Model that Combines Syntactic and Semantic Clustering for Discriminative Dependency Parsing</a></p>
<p>12 0.60019928 <a title="243-lsi-12" href="./acl-2011-full-for-print.html">342 acl-2011-full-for-print</a></p>
<p>13 0.60014254 <a title="243-lsi-13" href="./acl-2011-Automatic_Detection_and_Correction_of_Errors_in_Dependency_Treebanks.html">48 acl-2011-Automatic Detection and Correction of Errors in Dependency Treebanks</a></p>
<p>14 0.58242631 <a title="243-lsi-14" href="./acl-2011-Lexicographic_Semirings_for_Exact_Automata_Encoding_of_Sequence_Models.html">210 acl-2011-Lexicographic Semirings for Exact Automata Encoding of Sequence Models</a></p>
<p>15 0.56602591 <a title="243-lsi-15" href="./acl-2011-Better_Automatic_Treebank_Conversion_Using_A_Feature-Based_Approach.html">59 acl-2011-Better Automatic Treebank Conversion Using A Feature-Based Approach</a></p>
<p>16 0.55422068 <a title="243-lsi-16" href="./acl-2011-Optimal_Head-Driven_Parsing_Complexity_for_Linear_Context-Free_Rewriting_Systems.html">234 acl-2011-Optimal Head-Driven Parsing Complexity for Linear Context-Free Rewriting Systems</a></p>
<p>17 0.5358355 <a title="243-lsi-17" href="./acl-2011-Effects_of_Noun_Phrase_Bracketing_in_Dependency_Parsing_and_Machine_Translation.html">111 acl-2011-Effects of Noun Phrase Bracketing in Dependency Parsing and Machine Translation</a></p>
<p>18 0.52013415 <a title="243-lsi-18" href="./acl-2011-Joint_Hebrew_Segmentation_and_Parsing_using_a_PCFGLA_Lattice_Parser.html">184 acl-2011-Joint Hebrew Segmentation and Parsing using a PCFGLA Lattice Parser</a></p>
<p>19 0.5153529 <a title="243-lsi-19" href="./acl-2011-Web-Scale_Features_for_Full-Scale_Parsing.html">333 acl-2011-Web-Scale Features for Full-Scale Parsing</a></p>
<p>20 0.51094979 <a title="243-lsi-20" href="./acl-2011-Simple_Unsupervised_Grammar_Induction_from_Raw_Text_with_Cascaded_Finite_State_Models.html">284 acl-2011-Simple Unsupervised Grammar Induction from Raw Text with Cascaded Finite State Models</a></p>
<br/>
<h2>similar papers computed by <a title="lda-model" href="../home/acl2011_lda.html">lda model</a></h2><h3>lda for this paper:</h3><p>topicId topicWeight</p>
<p>[(5, 0.012), (17, 0.066), (26, 0.016), (37, 0.106), (39, 0.064), (41, 0.062), (55, 0.022), (57, 0.353), (59, 0.043), (72, 0.031), (91, 0.026), (96, 0.101), (97, 0.011)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 0.72147799 <a title="243-lda-1" href="./acl-2011-Partial_Parsing_from_Bitext_Projections.html">243 acl-2011-Partial Parsing from Bitext Projections</a></p>
<p>Author: Prashanth Mannem ; Aswarth Dara</p><p>Abstract: Recent work has shown how a parallel corpus can be leveraged to build syntactic parser for a target language by projecting automatic source parse onto the target sentence using word alignments. The projected target dependency parses are not always fully connected to be useful for training traditional dependency parsers. In this paper, we present a greedy non-directional parsing algorithm which doesn’t need a fully connected parse and can learn from partial parses by utilizing available structural and syntactic information in them. Our parser achieved statistically significant improvements over a baseline system that trains on only fully connected parses for Bulgarian, Spanish and Hindi. It also gave a significant improvement over previously reported results for Bulgarian and set a benchmark for Hindi.</p><p>2 0.67126441 <a title="243-lda-2" href="./acl-2011-Simple_supervised_document_geolocation_with_geodesic_grids.html">285 acl-2011-Simple supervised document geolocation with geodesic grids</a></p>
<p>Author: Benjamin Wing ; Jason Baldridge</p><p>Abstract: We investigate automatic geolocation (i.e. identification of the location, expressed as latitude/longitude coordinates) of documents. Geolocation can be an effective means of summarizing large document collections and it is an important component of geographic information retrieval. We describe several simple supervised methods for document geolocation using only the document’s raw text as evidence. All of our methods predict locations in the context of geodesic grids of varying degrees of resolution. We evaluate the methods on geotagged Wikipedia articles and Twitter feeds. For Wikipedia, our best method obtains a median prediction error of just 11.8 kilometers. Twitter geolocation is more challenging: we obtain a median error of 479 km, an improvement on previous results for the dataset.</p><p>3 0.647663 <a title="243-lda-3" href="./acl-2011-Topical_Keyphrase_Extraction_from_Twitter.html">305 acl-2011-Topical Keyphrase Extraction from Twitter</a></p>
<p>Author: Xin Zhao ; Jing Jiang ; Jing He ; Yang Song ; Palakorn Achanauparp ; Ee-Peng Lim ; Xiaoming Li</p><p>Abstract: Summarizing and analyzing Twitter content is an important and challenging task. In this paper, we propose to extract topical keyphrases as one way to summarize Twitter. We propose a context-sensitive topical PageRank method for keyword ranking and a probabilistic scoring function that considers both relevance and interestingness of keyphrases for keyphrase ranking. We evaluate our proposed methods on a large Twitter data set. Experiments show that these methods are very effective for topical keyphrase extraction.</p><p>4 0.64318472 <a title="243-lda-4" href="./acl-2011-Towards_Style_Transformation_from_Written-Style_to_Audio-Style.html">306 acl-2011-Towards Style Transformation from Written-Style to Audio-Style</a></p>
<p>Author: Amjad Abu-Jbara ; Barbara Rosario ; Kent Lyons</p><p>Abstract: In this paper, we address the problem of optimizing the style of textual content to make it more suitable to being listened to by a user as opposed to being read. We study the differences between the written style and the audio style by consulting the linguistics andjour- nalism literatures. Guided by this study, we suggest a number of linguistic features to distinguish between the two styles. We show the correctness of our features and the impact of style transformation on the user experience through statistical analysis, a style classification task, and a user study.</p><p>5 0.6267153 <a title="243-lda-5" href="./acl-2011-I_Thou_Thee%2C_Thou_Traitor%3A_Predicting_Formal_vs._Informal_Address_in_English_Literature.html">157 acl-2011-I Thou Thee, Thou Traitor: Predicting Formal vs. Informal Address in English Literature</a></p>
<p>Author: Manaal Faruqui ; Sebastian Pado</p><p>Abstract: In contrast to many languages (like Russian or French), modern English does not distinguish formal and informal (“T/V”) address overtly, for example by pronoun choice. We describe an ongoing study which investigates to what degree the T/V distinction is recoverable in English text, and with what textual features it correlates. Our findings are: (a) human raters can label English utterances as T or V fairly well, given sufficient context; (b), lexical cues can predict T/V almost at human level.</p><p>6 0.46504593 <a title="243-lda-6" href="./acl-2011-Exploiting_Syntactico-Semantic_Structures_for_Relation_Extraction.html">126 acl-2011-Exploiting Syntactico-Semantic Structures for Relation Extraction</a></p>
<p>7 0.45605609 <a title="243-lda-7" href="./acl-2011-Effects_of_Noun_Phrase_Bracketing_in_Dependency_Parsing_and_Machine_Translation.html">111 acl-2011-Effects of Noun Phrase Bracketing in Dependency Parsing and Machine Translation</a></p>
<p>8 0.45463556 <a title="243-lda-8" href="./acl-2011-Semi-supervised_Relation_Extraction_with_Large-scale_Word_Clustering.html">277 acl-2011-Semi-supervised Relation Extraction with Large-scale Word Clustering</a></p>
<p>9 0.4538238 <a title="243-lda-9" href="./acl-2011-Unsupervised_Semantic_Role_Induction_via_Split-Merge_Clustering.html">324 acl-2011-Unsupervised Semantic Role Induction via Split-Merge Clustering</a></p>
<p>10 0.45260698 <a title="243-lda-10" href="./acl-2011-Disentangling_Chat_with_Local_Coherence_Models.html">101 acl-2011-Disentangling Chat with Local Coherence Models</a></p>
<p>11 0.45202023 <a title="243-lda-11" href="./acl-2011-Using_Large_Monolingual_and_Bilingual_Corpora_to_Improve_Coordination_Disambiguation.html">331 acl-2011-Using Large Monolingual and Bilingual Corpora to Improve Coordination Disambiguation</a></p>
<p>12 0.45188913 <a title="243-lda-12" href="./acl-2011-Joint_Training_of_Dependency_Parsing_Filters_through_Latent_Support_Vector_Machines.html">186 acl-2011-Joint Training of Dependency Parsing Filters through Latent Support Vector Machines</a></p>
<p>13 0.45167989 <a title="243-lda-13" href="./acl-2011-Can_Document_Selection_Help_Semi-supervised_Learning%3F_A_Case_Study_On_Event_Extraction.html">65 acl-2011-Can Document Selection Help Semi-supervised Learning? A Case Study On Event Extraction</a></p>
<p>14 0.4508906 <a title="243-lda-14" href="./acl-2011-Transition-based_Dependency_Parsing_with_Rich_Non-local_Features.html">309 acl-2011-Transition-based Dependency Parsing with Rich Non-local Features</a></p>
<p>15 0.45067111 <a title="243-lda-15" href="./acl-2011-Learning_Hierarchical_Translation_Structure_with_Linguistic_Annotations.html">202 acl-2011-Learning Hierarchical Translation Structure with Linguistic Annotations</a></p>
<p>16 0.45041421 <a title="243-lda-16" href="./acl-2011-Beam-Width_Prediction_for_Efficient_Context-Free_Parsing.html">58 acl-2011-Beam-Width Prediction for Efficient Context-Free Parsing</a></p>
<p>17 0.44964772 <a title="243-lda-17" href="./acl-2011-Data_point_selection_for_cross-language_adaptation_of_dependency_parsers.html">92 acl-2011-Data point selection for cross-language adaptation of dependency parsers</a></p>
<p>18 0.44918984 <a title="243-lda-18" href="./acl-2011-Coreference_Resolution_with_World_Knowledge.html">85 acl-2011-Coreference Resolution with World Knowledge</a></p>
<p>19 0.4482314 <a title="243-lda-19" href="./acl-2011-Domain_Adaptation_by_Constraining_Inter-Domain_Variability_of_Latent_Feature_Representation.html">103 acl-2011-Domain Adaptation by Constraining Inter-Domain Variability of Latent Feature Representation</a></p>
<p>20 0.44806954 <a title="243-lda-20" href="./acl-2011-A_Comparison_of_Loopy_Belief_Propagation_and_Dual_Decomposition_for_Integrated_CCG_Supertagging_and_Parsing.html">5 acl-2011-A Comparison of Loopy Belief Propagation and Dual Decomposition for Integrated CCG Supertagging and Parsing</a></p>
<br/><br/><br/>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-48522588-1', 'makerhacker.github.io');
ga('send', 'pageview');
</script>

</body>
</html>
