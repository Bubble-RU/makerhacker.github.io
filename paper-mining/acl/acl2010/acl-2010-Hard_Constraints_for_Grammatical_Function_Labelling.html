<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>130 acl-2010-Hard Constraints for Grammatical Function Labelling</title>
</head>

<body>
<p><a title="acl" href="../acl_home.html">acl</a> <a title="acl-2010" href="../home/acl2010_home.html">acl2010</a> <a title="acl-2010-130" href="#">acl2010-130</a> knowledge-graph by maker-knowledge-mining</p><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- maker adsense -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-5027806277543591"
     data-ad-slot="4192012269"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<h1>130 acl-2010-Hard Constraints for Grammatical Function Labelling</h1>
<br/><p>Source: <a title="acl-2010-130-pdf" href="http://aclweb.org/anthology//P/P10/P10-1111.pdf">pdf</a></p><p>Author: Wolfgang Seeker ; Ines Rehbein ; Jonas Kuhn ; Josef Van Genabith</p><p>Abstract: For languages with (semi-) free word order (such as German), labelling grammatical functions on top of phrase-structural constituent analyses is crucial for making them interpretable. Unfortunately, most statistical classifiers consider only local information for function labelling and fail to capture important restrictions on the distribution of core argument functions such as subject, object etc., namely that there is at most one subject (etc.) per clause. We augment a statistical classifier with an integer linear program imposing hard linguistic constraints on the solution space output by the classifier, capturing global distributional restrictions. We show that this improves labelling quality, in particular for argument grammatical functions, in an intrinsic evaluation, and, importantly, grammar coverage for treebankbased (Lexical-Functional) grammar acquisition and parsing, in an extrinsic evaluation.</p><p>Reference: <a title="acl-2010-130-reference" href="../acl2010_reference/acl-2010-Hard_Constraints_for_Grammatical_Function_Labelling_reference.html">text</a></p><br/><h2>Summary: the most important sentenses genereted by tfidf model</h2><p>sentIndex sentText sentNum sentScore</p><p>1 de Abstract For languages with (semi-) free word order (such as German), labelling grammatical functions on top of phrase-structural constituent analyses is crucial for making them interpretable. [sent-7, score-0.427]
</p><p>2 Unfortunately, most statistical classifiers consider only local information for function labelling and fail to capture important restrictions on the distribution of core argument functions such as subject, object etc. [sent-8, score-0.507]
</p><p>3 We augment a statistical classifier  with an integer linear program imposing hard linguistic constraints on the solution space output by the classifier, capturing global distributional restrictions. [sent-11, score-0.487]
</p><p>4 We show that this improves labelling quality, in particular for argument grammatical functions, in an intrinsic evaluation, and, importantly, grammar coverage for treebankbased (Lexical-Functional) grammar acquisition and parsing, in an extrinsic evaluation. [sent-12, score-0.6]
</p><p>5 1 Introduction Phrase or constituent structure is often regarded as an analysis step guiding semantic interpretation, while grammatical functions (i. [sent-13, score-0.252]
</p><p>6 English), core grammatical functions can often be recovered from configurational information in constituent structure analyses. [sent-19, score-0.329]
</p><p>7 By contrast, simple constituent structures are not sufficient for less  configurational languages, which tend to encode grammatical functions by morphological means rehbein@coli. [sent-20, score-0.387]
</p><p>8 Statistical classifiers have been successfully used to label constituent structure parser output with grammatical function information (Blaheta and Charniak, 2000; Chrupała and Van Genabith, 2006). [sent-27, score-0.444]
</p><p>9 We present a system that adds grammatical function labels to constituent parser output for German in a postprocessing step. [sent-37, score-0.48]
</p><p>10 We combine a statistical classifier with an integer linear program (ILP) to model non-violable global linguistic constraints, restricting the solution space of the classifier to those labellings that comply with our set of global constraints. [sent-38, score-0.387]
</p><p>11 Klein and Manning (2003) show that merging some linguistically motivated function labels with specific syntactic categories can improve the performance of a PCFG model on Penn-II En-  1Coordinate subjects/objects form a constituent that functions as a joint subject/object. [sent-40, score-0.323]
</p><p>12 2 Tsarfaty and Sim’aan (2008) present a statistical model (Relational-Realizational Parsing) that alternates between functional and configurational information for constituency tree parsing and Hebrew data. [sent-44, score-0.205]
</p><p>13 Dependency parsers like the MST parser (McDonald and Pereira, 2006) and Malt parser (Nivre et al. [sent-45, score-0.226]
</p><p>14 In this paper, we focus on phrase structure parsing with function labelling as a post-processing step. [sent-47, score-0.339]
</p><p>15 Integer linear programs have already been successfully used in related fields including semantic role labelling (Punyakanok et al. [sent-48, score-0.226]
</p><p>16 Early work on function labelling for German (Brants et al. [sent-51, score-0.246]
</p><p>17 His research focusses on the correct selection of predefined subcategorisation frames for a verb (see also Klenner (2005)). [sent-56, score-0.2]
</p><p>18 Klenner’s system was evaluated on gold treebank data and used a small set of 7 dependency labels. [sent-58, score-0.216]
</p><p>19 In both cases, the ILPbased approach improves the quality of argument function labelling when compared with a non-ILPapproach. [sent-63, score-0.385]
</p><p>20 Section 3 de2Table 6 shows that for our data a model with merged category and function labels (but without hard constraints! [sent-68, score-0.232]
</p><p>21 scribes the labeller including the feature model of the classifier and the integer linear program used to pick the correct labelling. [sent-70, score-0.483]
</p><p>22 The evaluation part (Section 4) is split into an intrinsic evaluation measuring the quality of the labelling directly using the German TiGer Treebank (Brants et al. [sent-71, score-0.252]
</p><p>23 , 2002), and an extrinsic evaluation where we test the impact of the constraint-based labelling on treebankbased automatic LFG grammar acquisition. [sent-72, score-0.254]
</p><p>24 The grammatical function of a noun phrase is marked morphologically on its constituting parts. [sent-76, score-0.269]
</p><p>25 (1)  Der L¨ owe gibt dem Wolf NOM DAT the lion gives the wolf The lion gives a broom to the  einen Besen. [sent-81, score-0.37]
</p><p>26 Here, the subject is unambiguously marked with nominative case (NOM), the indirect object with dative case (DAT) and the direct object with ac-  cusative case (ACC). [sent-84, score-0.365]
</p><p>27 Since all permutations of arguments are possible, there is no chance for a statistical classifier to decide on the correct function of a noun phrase by its position alone. [sent-91, score-0.263]
</p><p>28 1088  Case information for a given noun phrase can give a classifier some clue about the correct argument function, since functions are strongly related to case values. [sent-94, score-0.433]
</p><p>29 (3) shows a sentence where both argument NPs are ambiguous between nominative or accusative case. [sent-96, score-0.221]
</p><p>30 A statistical classifier (with access to local information only) runs a high risk of incorrectly classifying both NPs as subjects, or both as direct objects or even as nominal predicates (which are also required to carry nominative case). [sent-98, score-0.196]
</p><p>31 Grammatical Function Labelling  Our function labeller was developed and tested on the TiGer Treebank (Brants et al. [sent-103, score-0.264]
</p><p>32 TiGer uses 25 syntactic categories and a set of 42 function labels to annotate the grammatical function of a phrase. [sent-110, score-0.348]
</p><p>33 The function labeller consists of two main components, a maximum entropy classifier and an integer linear program. [sent-111, score-0.507]
</p><p>34 In our case, its input is a bare tree 4Although the classifier may, of course, still identify the wrong phrase as subject or object. [sent-114, score-0.23]
</p><p>35 structure (as obtained by a standard phrase structure parser) and it outputs a tree structure where every node is labelled with the grammatical relation it bears to its mother node. [sent-115, score-0.432]
</p><p>36 For each possible label and for each node, the classifier assigns a probability that this node is labelled by this label. [sent-116, score-0.358]
</p><p>37 An integer linear program then tries to find the optimal overall tree labelling by picking for each node the label with the highest probability without violating any ofits constraints. [sent-118, score-0.593]
</p><p>38 2 Constrained Optimisation In the second step, a binary integer linear program is used to select those labels that optimise the whole tree labelling. [sent-140, score-0.331]
</p><p>39 A linear program consists of  ×  a linear objective function that is to be maximised (or minimised) and a set of constraints which impose conditions on the variables of the objective function (see (Clarke and Lapata, 2008) for a short but readable introduction). [sent-141, score-0.444]
</p><p>40 Setting a variable xn,l to 1 means that node n is labelled by label l. [sent-145, score-0.261]
</p><p>41 html) for opensource implementations label, we add a constraint that for every node n, exactly one of its variables is set to 1. [sent-156, score-0.199]
</p><p>42 7  The first and most important constraint restricts the number of each argument function (as opposed to modifier functions) to at most one per clause. [sent-159, score-0.249]
</p><p>43 cFeo rre every node n with category S (sentence) or VP (verb phrase), at most one of its daughters is allowed to be labelled SB (subject). [sent-161, score-0.314]
</p><p>44 The single-subjectfunction condition is defined as: cat(n) ∈ {S,V P}  −→  X  xm,SB  ≤  1 (6)  hnX,mi ∈D  Identical constraints are added for labels OA, OA2, DA, OG, OP, PD, OC, EP. [sent-162, score-0.256]
</p><p>45 8 We add further constraints to capture the following linguistic restrictions: • Of all daughters of a phrase, only one is allowed to f b ael l a dbaeulglhedte rHsD o (head). [sent-163, score-0.215]
</p><p>46 X hnX,mi  ∈D  •  xm,HD  ≤1  (7)  If a noun phrase carries no case feature for nomiInfa atni voeu case, aits cea cnanrroite sb e n ola cbaesllee fde SB, eP fDor or oEmP. [sent-164, score-0.238]
</p><p>47 case(n)  = nom  −→  X  xn,l  =0  l∈{SBX,PD,EP}  (8)  •  •  •  If a noun phrase carries no case feature for acIcfu saant ivoeu case, iste ec cananrrioet sb en ola cbaesllee dfe aOtuAr or oOrA ac2-. [sent-165, score-0.275]
</p><p>48 Furthermore, the constraints are treebank specific to a certain degree in that they use a TiGer-specific set of labels and are conditioned on TiGer-specific configurations and categories. [sent-169, score-0.343]
</p><p>49 Therefore we add an extension of the constraint in (6) to the constraint set in order to also include the daughters of an embedded VP node in such a case. [sent-172, score-0.337]
</p><p>50 Due to the constraints imposed on the classification, the function labeller can no longer assign two subjects to the same S node. [sent-180, score-0.465]
</p><p>51 We use the manually labelled TiGer trees corresponding to the sentences in the TiGerDB for assessing the labelling quality in the intrinsic evaluation, and the dependencies from TiGerDB for assessing the quality and coverage of the automatically acquired  LFG resources in the extrinsic evaluation. [sent-187, score-0.512]
</p><p>52 97 Table 1: evalb unlabelled parsing scores on test set for Berkeley Parser trained on 48,000 sentences (sentence length ≤ 40) The maximum entropy classifier of the function labeller was trained on 46,473 sentences of the TiGer Treebank (excluding the test set) which yields about 1. [sent-196, score-0.442]
</p><p>53 10 The integer linear  program was solved with the simplex algorithm in combination with a branch-and-bound method using the freely available GLPK. [sent-200, score-0.193]
</p><p>54 1 Intrinsic Evaluation In the intrinsic evaluation, we measured the quality of the labelling itself. [sent-202, score-0.252]
</p><p>55 We used the node span evaluation method of (Blaheta and Charniak, 2000) which takes only those nodes into account which have been recognised correctly by the parser, i. [sent-203, score-0.21]
</p><p>56 The labeller achieves close to 98% label accuracy on gold treebank trees which shows that the feature model captures the differences between the individual labels well. [sent-208, score-0.582]
</p><p>57 Results on parser output are about 4 percentage points (absolute) lower as parsing errors can distort local context features for the classifier even ifthe node itselfhas been parsed  10http://www-tsujii. [sent-209, score-0.418]
</p><p>58 The addition of the ILP constraints improves results only slightly since the constraints affect only (a small number of) argument labels while the evaluation considers all 40 labels occurring in the test set. [sent-224, score-0.614]
</p><p>59 Since the constraints restrict the selection ofcertain labels, a less probable label has to be picked by the labeller if the most probable is not available. [sent-225, score-0.413]
</p><p>60 If the classifier is ranking labels sensibly, the correct label should emerge. [sent-226, score-0.267]
</p><p>61 68% Table 2: label  accuracy  and  error  reduction (all labels) for  node span evaluation, * statistically significant, sign test, 0. [sent-235, score-0.238]
</p><p>62 01 (Koo and Collins, 2005)  α  =  As the main target of the constraint set are argument functions, we also tested the quality of argument labels. [sent-236, score-0.317]
</p><p>63 Table 3 shows the node span evaluation in terms of precision, recall and f-score for argument functions only, with clear statistically significant improvements. [sent-237, score-0.376]
</p><p>64 09* Table 3: node span results for the test set, argument functions only (SB, EP, PD, OA, OA2, DA, OG, OP, OC), * statistically significant, sign test, α = 0. [sent-252, score-0.376]
</p><p>65 The node span evaluation defines a correct labelling by taking only those nodes (in parser output) into account that have a corresponding node in the reference tree. [sent-260, score-0.621]
</p><p>66 The considerable drop in quality between gold trees and parser output clearly shows that a good parse tree is an important prerequisite for reasonable function labelling. [sent-266, score-0.432]
</p><p>67 Klenner (2007), we did not include predefined subcategorisation frames into the constraint set, but rather let the joint statistical and ILP models decide on the correct type of arguments assigned to a verb. [sent-287, score-0.232]
</p><p>68 The assumption is that if one uses predefined subcategorisation frames which fix the number and type of arguments for a verb, one runs the risk of excluding correct labellings due to missing subcat frames, unless a very comprehensive and high quality subcat lexicon resource is available. [sent-288, score-0.469]
</p><p>69 Following Klenner (2007), for each verb and for each subcat frame for this verb attested at least once in the training data, we introduce a new binary variable fn to the ILP model representing the n-th frame (for the verb) weighted by its frequency. [sent-290, score-0.34]
</p><p>70 We add an ILP constraint requiring exactly one ofthe frames to be set to one (each verb has to have a subcat frame) and replace the ILP constraint in (6) by: 13Function labels were merged with the category symbols. [sent-291, score-0.574]
</p><p>71 1092  X hn,Xmi∈D  xm,SB −  X fi = 0 SXB∈fi  (10)  This constraint requires the number of subjects in a phrase to be equal to the number of selected14 verb frames that require a subject. [sent-292, score-0.299]
</p><p>72 As each verb is constrained to “select” exactly one subcat frame (see additional ILP constraint above), there is at most one subject per phrase, if the frame in ques-  tion requires a subject. [sent-293, score-0.418]
</p><p>73 The same was done for the other argument functions and as before we included an extension ofthis constraint to cover embedded VPs. [sent-295, score-0.281]
</p><p>74 49 Table 5: node span results for the test set using constraints with automatically extracted subcat frames Table 5 shows the results of the test set node span evaluation when using the ILP system enhanced with subcat frames. [sent-315, score-0.85]
</p><p>75 Compared to Tables 2 and 3, the results are clearly inferior, and particularly so for argument grammatical functions. [sent-316, score-0.205]
</p><p>76 This seems to confirm our assumption that, given our  data, letting the joint statistical and ILP model decide argument functions is superior to an approach that involves subcat frames. [sent-317, score-0.343]
</p><p>77 However, and importantly, our results do not rule out that a more comprehensive subcat frame resource may in fact result in improvements. [sent-318, score-0.195]
</p><p>78 , 2008) and is based on an f-structure annotation algorithm that annotates c-structure trees (from a treebank or parser output) with f-structure equations, which are read off of the tree and passed on to a constraint solver producing an f-structure for the given sentence. [sent-330, score-0.4]
</p><p>79 The English annotation algorithm (for Penn-II treebank-style trees) relies heavily on configurational and categorial information, translating this into grammatical functional information (subject, object etc. [sent-331, score-0.327]
</p><p>80 LFG is “functional” in the  mathematical sense, in that argument grammatical functions have to be single valued (there cannot be two or more subjects etc. [sent-333, score-0.356]
</p><p>81 In fact, if two or more values are assigned to a single argument grammatical function in a local tree, the LFG constraint solver will produce a clash (i. [sent-335, score-0.352]
</p><p>82 Unlike the English annotation algorithm and because of the language-particular properties of German (see Section 2), the German annotation algorithm cannot rely on c-structure configurational information, but instead heavily uses TiGer function labels in the treebank. [sent-339, score-0.329]
</p><p>83 Learning function labels is therefore crucial to the German LFG annotation algorithm, in particular when parsing raw text. [sent-340, score-0.254]
</p><p>84 Because of the strong case syncretism in German, traditional classification models using local  1093  information only run the risk of predicting multiple occurences of the same function (subject, object etc. [sent-341, score-0.216]
</p><p>85 Below we test whether the coverage problems caused by incorrect multiple assignments of grammatical functions can be addressed using the combination of classifier with ILP constraints developed in this paper. [sent-345, score-0.518]
</p><p>86 07% f-score upper-bound results for the f-structure annotation algorithm on the original TiGer treebank trees with hand-annotated function labels. [sent-377, score-0.247]
</p><p>87 Using the function labeller without ILP constraints results in drastic drops in coverage (between 4. [sent-378, score-0.479]
</p><p>88 5%) for both gold trees and parser output (compared to upper bounds). [sent-382, score-0.289]
</p><p>89 Rehbein trains the Berkeley Parser to learn an extended category set, merging TiGer function labels with syntactic categories, where the parser outputs fully-labelled trees. [sent-387, score-0.345]
</p><p>90 The results show that this approach suffers from the same drop in coverage as the classifier without ILP constraints, with recall about 7% and f-score about 4% (absolute) lower than for the classifier with ILP constraints. [sent-388, score-0.256]
</p><p>91 Table 7 shows the dramatic effect of the ILP constraints on the number of sentences in the test set that have multiple argument functions of the same type within the same clause. [sent-389, score-0.358]
</p><p>92 79  Table 8: f-structure evaluation results for cluding sentences without f-structures  parser  output  ex-  Early work on automatic LFG acquisition and parsing for German is presented in Cahill et al. [sent-409, score-0.198]
</p><p>93 (2003) and Cahill (2004), adapting the English Annotation Algorithm to an earlier and smaller version of the TiGer treebank (without morphological information) and training a parser to learn merged Tiger function-category labels, and reporting 95. [sent-410, score-0.258]
</p><p>94 56% f-structure quality against 2,000 gold treebank trees automatically converted into f-structures. [sent-412, score-0.256]
</p><p>95 23 Table 9: f-structure evaluation results for the test set against automatically generated goldstandard (1,850 sentences) 5  Conclusion  In this paper, we addressed the problem of assigning grammatical functions to constituent structures. [sent-447, score-0.252]
</p><p>96 We have proposed an approach to grammatical function labelling that combines the flexibility of a statistical classifier with linguistic expert knowledge in the form of hard constraints implemented by an integer linear program. [sent-448, score-0.745]
</p><p>97 These constraints restrict the solution space of the classifier by blocking those solutions that cannot be correct. [sent-449, score-0.25]
</p><p>98 We evaluated our system on the TiGer corpus and the TiGerDB and gave results on gold standard trees and parser output. [sent-453, score-0.245]
</p><p>99 We found that by using the constraint set, the function labeller ensures the interpretability and thus the usefulness of the syntactic structure for a subsequently applied processing step. [sent-455, score-0.34]
</p><p>100 Using machine-learning to assign function labels to parser output for Spanish. [sent-519, score-0.331]
</p>
<br/>
<h2>similar papers computed by tfidf model</h2><h3>tfidf for this paper:</h3><p>wordName wordTfidf (topN-words)</p>
<p>[('tiger', 0.399), ('ilp', 0.286), ('lfg', 0.194), ('labeller', 0.193), ('tigerdb', 0.193), ('rehbein', 0.183), ('labelling', 0.175), ('constraints', 0.153), ('german', 0.142), ('subcat', 0.138), ('node', 0.123), ('parser', 0.113), ('genabith', 0.112), ('cahill', 0.105), ('labels', 0.103), ('functions', 0.103), ('grammatical', 0.103), ('argument', 0.102), ('classifier', 0.097), ('integer', 0.095), ('einen', 0.092), ('gibt', 0.092), ('treebank', 0.087), ('dem', 0.085), ('gold', 0.082), ('klenner', 0.079), ('frames', 0.079), ('forst', 0.077), ('configurational', 0.077), ('subcategorisation', 0.077), ('constraint', 0.076), ('function', 0.071), ('labelled', 0.071), ('besen', 0.07), ('blaheta', 0.07), ('sb', 0.069), ('label', 0.067), ('wolf', 0.066), ('daughters', 0.062), ('nominative', 0.062), ('coverage', 0.062), ('category', 0.058), ('morphological', 0.058), ('van', 0.058), ('accusative', 0.057), ('frame', 0.057), ('aoife', 0.056), ('object', 0.056), ('punyakanok', 0.053), ('das', 0.053), ('chrupa', 0.053), ('grandmother', 0.053), ('syncretism', 0.053), ('der', 0.052), ('phrase', 0.052), ('functional', 0.052), ('linear', 0.051), ('brants', 0.051), ('trees', 0.05), ('span', 0.048), ('subjects', 0.048), ('josef', 0.048), ('mother', 0.048), ('program', 0.047), ('dependency', 0.047), ('schiller', 0.046), ('constituent', 0.046), ('subject', 0.046), ('verb', 0.044), ('output', 0.044), ('noun', 0.043), ('lemma', 0.042), ('ines', 0.042), ('parsing', 0.041), ('extrinsic', 0.04), ('intrinsic', 0.04), ('og', 0.04), ('evalb', 0.04), ('genitive', 0.04), ('grammar', 0.039), ('annotation', 0.039), ('nodes', 0.039), ('carries', 0.038), ('terminal', 0.038), ('morristown', 0.038), ('oc', 0.037), ('nom', 0.037), ('dublin', 0.037), ('dative', 0.037), ('quality', 0.037), ('objects', 0.037), ('ranlp', 0.036), ('sisters', 0.036), ('girl', 0.036), ('tracy', 0.036), ('ruth', 0.036), ('case', 0.036), ('tree', 0.035), ('benson', 0.035), ('broom', 0.035)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 1.0000005 <a title="130-tfidf-1" href="./acl-2010-Hard_Constraints_for_Grammatical_Function_Labelling.html">130 acl-2010-Hard Constraints for Grammatical Function Labelling</a></p>
<p>Author: Wolfgang Seeker ; Ines Rehbein ; Jonas Kuhn ; Josef Van Genabith</p><p>Abstract: For languages with (semi-) free word order (such as German), labelling grammatical functions on top of phrase-structural constituent analyses is crucial for making them interpretable. Unfortunately, most statistical classifiers consider only local information for function labelling and fail to capture important restrictions on the distribution of core argument functions such as subject, object etc., namely that there is at most one subject (etc.) per clause. We augment a statistical classifier with an integer linear program imposing hard linguistic constraints on the solution space output by the classifier, capturing global distributional restrictions. We show that this improves labelling quality, in particular for argument grammatical functions, in an intrinsic evaluation, and, importantly, grammar coverage for treebankbased (Lexical-Functional) grammar acquisition and parsing, in an extrinsic evaluation.</p><p>2 0.19150256 <a title="130-tfidf-2" href="./acl-2010-Automatic_Generation_of_Story_Highlights.html">39 acl-2010-Automatic Generation of Story Highlights</a></p>
<p>Author: Kristian Woodsend ; Mirella Lapata</p><p>Abstract: In this paper we present a joint content selection and compression model for single-document summarization. The model operates over a phrase-based representation of the source document which we obtain by merging information from PCFG parse trees and dependency graphs. Using an integer linear programming formulation, the model learns to select and combine phrases subject to length, coverage and grammar constraints. We evaluate the approach on the task of generating “story highlights”—a small number of brief, self-contained sentences that allow readers to quickly gather information on news stories. Experimental results show that the model’s output is comparable to human-written highlights in terms of both grammaticality and content.</p><p>3 0.18365477 <a title="130-tfidf-3" href="./acl-2010-Edit_Tree_Distance_Alignments_for_Semantic_Role_Labelling.html">94 acl-2010-Edit Tree Distance Alignments for Semantic Role Labelling</a></p>
<p>Author: Hector-Hugo Franco-Penya</p><p>Abstract: ―Tree SRL system‖ is a Semantic Role Labelling supervised system based on a tree-distance algorithm and a simple k-NN implementation. The novelty of the system lies in comparing the sentences as tree structures with multiple relations instead of extracting vectors of features for each relation and classifying them. The system was tested with the English CoNLL-2009 shared task data set where 79% accuracy was obtained. 1</p><p>4 0.1378202 <a title="130-tfidf-4" href="./acl-2010-Filtering_Syntactic_Constraints_for_Statistical_Machine_Translation.html">115 acl-2010-Filtering Syntactic Constraints for Statistical Machine Translation</a></p>
<p>Author: Hailong Cao ; Eiichiro Sumita</p><p>Abstract: Source language parse trees offer very useful but imperfect reordering constraints for statistical machine translation. A lot of effort has been made for soft applications of syntactic constraints. We alternatively propose the selective use of syntactic constraints. A classifier is built automatically to decide whether a node in the parse trees should be used as a reordering constraint or not. Using this information yields a 0.8 BLEU point improvement over a full constraint-based system.</p><p>5 0.13440129 <a title="130-tfidf-5" href="./acl-2010-Rebanking_CCGbank_for_Improved_NP_Interpretation.html">203 acl-2010-Rebanking CCGbank for Improved NP Interpretation</a></p>
<p>Author: Matthew Honnibal ; James R. Curran ; Johan Bos</p><p>Abstract: Once released, treebanks tend to remain unchanged despite any shortcomings in their depth of linguistic analysis or coverage of specific phenomena. Instead, separate resources are created to address such problems. In this paper we show how to improve the quality of a treebank, by integrating resources and implementing improved analyses for specific constructions. We demonstrate this rebanking process by creating an updated version of CCGbank that includes the predicate-argument structure of both verbs and nouns, baseNP brackets, verb-particle constructions, and restrictive and non-restrictive nominal modifiers; and evaluate the impact of these changes on a statistical parser.</p><p>6 0.12399004 <a title="130-tfidf-6" href="./acl-2010-Wide-Coverage_NLP_with_Linguistically_Expressive_Grammars.html">260 acl-2010-Wide-Coverage NLP with Linguistically Expressive Grammars</a></p>
<p>7 0.11736797 <a title="130-tfidf-7" href="./acl-2010-Fully_Unsupervised_Core-Adjunct_Argument_Classification.html">120 acl-2010-Fully Unsupervised Core-Adjunct Argument Classification</a></p>
<p>8 0.11707387 <a title="130-tfidf-8" href="./acl-2010-Predicate_Argument_Structure_Analysis_Using_Transformation_Based_Learning.html">198 acl-2010-Predicate Argument Structure Analysis Using Transformation Based Learning</a></p>
<p>9 0.11014483 <a title="130-tfidf-9" href="./acl-2010-Importance_of_Linguistic_Constraints_in_Statistical_Dependency_Parsing.html">143 acl-2010-Importance of Linguistic Constraints in Statistical Dependency Parsing</a></p>
<p>10 0.096357629 <a title="130-tfidf-10" href="./acl-2010-Entity-Based_Local_Coherence_Modelling_Using_Topological_Fields.html">101 acl-2010-Entity-Based Local Coherence Modelling Using Topological Fields</a></p>
<p>11 0.093764096 <a title="130-tfidf-11" href="./acl-2010-Global_Learning_of_Focused_Entailment_Graphs.html">127 acl-2010-Global Learning of Focused Entailment Graphs</a></p>
<p>12 0.092925794 <a title="130-tfidf-12" href="./acl-2010-Starting_from_Scratch_in_Semantic_Role_Labeling.html">216 acl-2010-Starting from Scratch in Semantic Role Labeling</a></p>
<p>13 0.092853136 <a title="130-tfidf-13" href="./acl-2010-Open-Domain_Semantic_Role_Labeling_by_Modeling_Word_Spans.html">184 acl-2010-Open-Domain Semantic Role Labeling by Modeling Word Spans</a></p>
<p>14 0.088251717 <a title="130-tfidf-14" href="./acl-2010-A_Structured_Model_for_Joint_Learning_of_Argument_Roles_and_Predicate_Senses.html">17 acl-2010-A Structured Model for Joint Learning of Argument Roles and Predicate Senses</a></p>
<p>15 0.088217504 <a title="130-tfidf-15" href="./acl-2010-Dependency_Parsing_and_Projection_Based_on_Word-Pair_Classification.html">83 acl-2010-Dependency Parsing and Projection Based on Word-Pair Classification</a></p>
<p>16 0.086408645 <a title="130-tfidf-16" href="./acl-2010-Efficient_Third-Order_Dependency_Parsers.html">99 acl-2010-Efficient Third-Order Dependency Parsers</a></p>
<p>17 0.085213736 <a title="130-tfidf-17" href="./acl-2010-Joint_Syntactic_and_Semantic_Parsing_of_Chinese.html">153 acl-2010-Joint Syntactic and Semantic Parsing of Chinese</a></p>
<p>18 0.082449704 <a title="130-tfidf-18" href="./acl-2010-Learning_to_Translate_with_Source_and_Target_Syntax.html">169 acl-2010-Learning to Translate with Source and Target Syntax</a></p>
<p>19 0.082338415 <a title="130-tfidf-19" href="./acl-2010-Profiting_from_Mark-Up%3A_Hyper-Text_Annotations_for_Guided_Parsing.html">200 acl-2010-Profiting from Mark-Up: Hyper-Text Annotations for Guided Parsing</a></p>
<p>20 0.080598615 <a title="130-tfidf-20" href="./acl-2010-Beyond_NomBank%3A_A_Study_of_Implicit_Arguments_for_Nominal_Predicates.html">49 acl-2010-Beyond NomBank: A Study of Implicit Arguments for Nominal Predicates</a></p>
<br/>
<h2>similar papers computed by <a title="lsi-model" href="../home/acl2010_lsi.html">lsi model</a></h2><h3>lsi for this paper:</h3><p>topicId topicWeight</p>
<p>[(0, -0.258), (1, 0.021), (2, 0.147), (3, 0.025), (4, -0.05), (5, -0.033), (6, 0.07), (7, -0.0), (8, 0.004), (9, 0.018), (10, 0.019), (11, 0.034), (12, -0.124), (13, 0.085), (14, 0.068), (15, -0.028), (16, 0.051), (17, 0.052), (18, 0.067), (19, 0.002), (20, -0.015), (21, 0.075), (22, 0.068), (23, -0.08), (24, 0.1), (25, -0.021), (26, 0.047), (27, -0.008), (28, 0.055), (29, 0.004), (30, -0.041), (31, -0.08), (32, -0.081), (33, 0.01), (34, 0.026), (35, -0.002), (36, -0.081), (37, -0.044), (38, -0.106), (39, -0.062), (40, -0.008), (41, -0.073), (42, 0.111), (43, -0.077), (44, -0.02), (45, -0.096), (46, -0.004), (47, 0.018), (48, 0.063), (49, 0.015)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>same-paper 1 0.94159418 <a title="130-lsi-1" href="./acl-2010-Hard_Constraints_for_Grammatical_Function_Labelling.html">130 acl-2010-Hard Constraints for Grammatical Function Labelling</a></p>
<p>Author: Wolfgang Seeker ; Ines Rehbein ; Jonas Kuhn ; Josef Van Genabith</p><p>Abstract: For languages with (semi-) free word order (such as German), labelling grammatical functions on top of phrase-structural constituent analyses is crucial for making them interpretable. Unfortunately, most statistical classifiers consider only local information for function labelling and fail to capture important restrictions on the distribution of core argument functions such as subject, object etc., namely that there is at most one subject (etc.) per clause. We augment a statistical classifier with an integer linear program imposing hard linguistic constraints on the solution space output by the classifier, capturing global distributional restrictions. We show that this improves labelling quality, in particular for argument grammatical functions, in an intrinsic evaluation, and, importantly, grammar coverage for treebankbased (Lexical-Functional) grammar acquisition and parsing, in an extrinsic evaluation.</p><p>2 0.65598106 <a title="130-lsi-2" href="./acl-2010-Importance_of_Linguistic_Constraints_in_Statistical_Dependency_Parsing.html">143 acl-2010-Importance of Linguistic Constraints in Statistical Dependency Parsing</a></p>
<p>Author: Bharat Ram Ambati</p><p>Abstract: Statistical systems with high accuracy are very useful in real-world applications. If these systems can capture basic linguistic information, then the usefulness of these statistical systems improve a lot. This paper is an attempt at incorporating linguistic constraints in statistical dependency parsing. We consider a simple linguistic constraint that a verb should not have multiple subjects/objects as its children in the dependency tree. We first describe the importance of this constraint considering Machine Translation systems which use dependency parser output, as an example application. We then show how the current state-ofthe-art dependency parsers violate this constraint. We present two new methods to handle this constraint. We evaluate our methods on the state-of-the-art dependency parsers for Hindi and Czech. 1</p><p>3 0.65015727 <a title="130-lsi-3" href="./acl-2010-Profiting_from_Mark-Up%3A_Hyper-Text_Annotations_for_Guided_Parsing.html">200 acl-2010-Profiting from Mark-Up: Hyper-Text Annotations for Guided Parsing</a></p>
<p>Author: Valentin I. Spitkovsky ; Daniel Jurafsky ; Hiyan Alshawi</p><p>Abstract: We show how web mark-up can be used to improve unsupervised dependency parsing. Starting from raw bracketings of four common HTML tags (anchors, bold, italics and underlines), we refine approximate partial phrase boundaries to yield accurate parsing constraints. Conversion procedures fall out of our linguistic analysis of a newly available million-word hyper-text corpus. We demonstrate that derived constraints aid grammar induction by training Klein and Manning’s Dependency Model with Valence (DMV) on this data set: parsing accuracy on Section 23 (all sentences) of the Wall Street Journal corpus jumps to 50.4%, beating previous state-of-the- art by more than 5%. Web-scale experiments show that the DMV, perhaps because it is unlexicalized, does not benefit from orders of magnitude more annotated but noisier data. Our model, trained on a single blog, generalizes to 53.3% accuracy out-of-domain, against the Brown corpus nearly 10% higher than the previous published best. The fact that web mark-up strongly correlates with syntactic structure may have broad applicability in NLP.</p><p>4 0.64062327 <a title="130-lsi-4" href="./acl-2010-Rebanking_CCGbank_for_Improved_NP_Interpretation.html">203 acl-2010-Rebanking CCGbank for Improved NP Interpretation</a></p>
<p>Author: Matthew Honnibal ; James R. Curran ; Johan Bos</p><p>Abstract: Once released, treebanks tend to remain unchanged despite any shortcomings in their depth of linguistic analysis or coverage of specific phenomena. Instead, separate resources are created to address such problems. In this paper we show how to improve the quality of a treebank, by integrating resources and implementing improved analyses for specific constructions. We demonstrate this rebanking process by creating an updated version of CCGbank that includes the predicate-argument structure of both verbs and nouns, baseNP brackets, verb-particle constructions, and restrictive and non-restrictive nominal modifiers; and evaluate the impact of these changes on a statistical parser.</p><p>5 0.62690312 <a title="130-lsi-5" href="./acl-2010-Predicate_Argument_Structure_Analysis_Using_Transformation_Based_Learning.html">198 acl-2010-Predicate Argument Structure Analysis Using Transformation Based Learning</a></p>
<p>Author: Hirotoshi Taira ; Sanae Fujita ; Masaaki Nagata</p><p>Abstract: Maintaining high annotation consistency in large corpora is crucial for statistical learning; however, such work is hard, especially for tasks containing semantic elements. This paper describes predicate argument structure analysis using transformation-based learning. An advantage of transformation-based learning is the readability of learned rules. A disadvantage is that the rule extraction procedure is time-consuming. We present incremental-based, transformation-based learning for semantic processing tasks. As an example, we deal with Japanese predicate argument analysis and show some tendencies of annotators for constructing a corpus with our method.</p><p>6 0.61178422 <a title="130-lsi-6" href="./acl-2010-Edit_Tree_Distance_Alignments_for_Semantic_Role_Labelling.html">94 acl-2010-Edit Tree Distance Alignments for Semantic Role Labelling</a></p>
<p>7 0.60218239 <a title="130-lsi-7" href="./acl-2010-Automatic_Generation_of_Story_Highlights.html">39 acl-2010-Automatic Generation of Story Highlights</a></p>
<p>8 0.54698533 <a title="130-lsi-8" href="./acl-2010-Filtering_Syntactic_Constraints_for_Statistical_Machine_Translation.html">115 acl-2010-Filtering Syntactic Constraints for Statistical Machine Translation</a></p>
<p>9 0.5464046 <a title="130-lsi-9" href="./acl-2010-Fully_Unsupervised_Core-Adjunct_Argument_Classification.html">120 acl-2010-Fully Unsupervised Core-Adjunct Argument Classification</a></p>
<p>10 0.53779817 <a title="130-lsi-10" href="./acl-2010-A_Generalized-Zero-Preserving_Method_for_Compact_Encoding_of_Concept_Lattices.html">7 acl-2010-A Generalized-Zero-Preserving Method for Compact Encoding of Concept Lattices</a></p>
<p>11 0.51540899 <a title="130-lsi-11" href="./acl-2010-Using_Parse_Features_for_Preposition_Selection_and_Error_Detection.html">252 acl-2010-Using Parse Features for Preposition Selection and Error Detection</a></p>
<p>12 0.5016548 <a title="130-lsi-12" href="./acl-2010-Dependency_Parsing_and_Projection_Based_on_Word-Pair_Classification.html">83 acl-2010-Dependency Parsing and Projection Based on Word-Pair Classification</a></p>
<p>13 0.49992231 <a title="130-lsi-13" href="./acl-2010-A_Probabilistic_Generative_Model_for_an_Intermediate_Constituency-Dependency_Representation.html">12 acl-2010-A Probabilistic Generative Model for an Intermediate Constituency-Dependency Representation</a></p>
<p>14 0.49253374 <a title="130-lsi-14" href="./acl-2010-Plot_Induction_and_Evolutionary_Search_for_Story_Generation.html">196 acl-2010-Plot Induction and Evolutionary Search for Story Generation</a></p>
<p>15 0.49041417 <a title="130-lsi-15" href="./acl-2010-Grammar_Prototyping_and_Testing_with_the_LinGO_Grammar_Matrix_Customization_System.html">128 acl-2010-Grammar Prototyping and Testing with the LinGO Grammar Matrix Customization System</a></p>
<p>16 0.49023277 <a title="130-lsi-16" href="./acl-2010-Efficient_Third-Order_Dependency_Parsers.html">99 acl-2010-Efficient Third-Order Dependency Parsers</a></p>
<p>17 0.48931134 <a title="130-lsi-17" href="./acl-2010-Starting_from_Scratch_in_Semantic_Role_Labeling.html">216 acl-2010-Starting from Scratch in Semantic Role Labeling</a></p>
<p>18 0.48514974 <a title="130-lsi-18" href="./acl-2010-Identifying_Generic_Noun_Phrases.html">139 acl-2010-Identifying Generic Noun Phrases</a></p>
<p>19 0.48334768 <a title="130-lsi-19" href="./acl-2010-Simple%2C_Accurate_Parsing_with_an_All-Fragments_Grammar.html">211 acl-2010-Simple, Accurate Parsing with an All-Fragments Grammar</a></p>
<p>20 0.47964987 <a title="130-lsi-20" href="./acl-2010-Computing_Weakest_Readings.html">67 acl-2010-Computing Weakest Readings</a></p>
<br/>
<h2>similar papers computed by <a title="lda-model" href="../home/acl2010_lda.html">lda model</a></h2><h3>lda for this paper:</h3><p>topicId topicWeight</p>
<p>[(7, 0.012), (14, 0.014), (25, 0.089), (35, 0.251), (39, 0.026), (42, 0.017), (47, 0.028), (59, 0.084), (73, 0.043), (76, 0.03), (78, 0.077), (80, 0.011), (83, 0.076), (84, 0.033), (98, 0.11)]</p>
<h3>similar papers list:</h3><p>simIndex simValue paperId paperTitle</p>
<p>1 0.85267037 <a title="130-lda-1" href="./acl-2010-Classification_of_Feedback_Expressions_in_Multimodal_Data.html">58 acl-2010-Classification of Feedback Expressions in Multimodal Data</a></p>
<p>Author: Costanza Navarretta ; Patrizia Paggio</p><p>Abstract: This paper addresses the issue of how linguistic feedback expressions, prosody and head gestures, i.e. head movements and face expressions, relate to one another in a collection of eight video-recorded Danish map-task dialogues. The study shows that in these data, prosodic features and head gestures significantly improve automatic classification of dialogue act labels for linguistic expressions of feedback.</p><p>2 0.83003795 <a title="130-lda-2" href="./acl-2010-Automatic_Sanskrit_Segmentizer_Using_Finite_State_Transducers.html">40 acl-2010-Automatic Sanskrit Segmentizer Using Finite State Transducers</a></p>
<p>Author: Vipul Mittal</p><p>Abstract: In this paper, we propose a novel method for automatic segmentation of a Sanskrit string into different words. The input for our segmentizer is a Sanskrit string either encoded as a Unicode string or as a Roman transliterated string and the output is a set of possible splits with weights associated with each of them. We followed two different approaches to segment a Sanskrit text using sandhi1 rules extracted from a parallel corpus of manually sandhi split text. While the first approach augments the finite state transducer used to analyze Sanskrit morphology and traverse it to segment a word, the second approach generates all possible segmentations and validates each constituent using a morph an- alyzer.</p><p>same-paper 3 0.78318042 <a title="130-lda-3" href="./acl-2010-Hard_Constraints_for_Grammatical_Function_Labelling.html">130 acl-2010-Hard Constraints for Grammatical Function Labelling</a></p>
<p>Author: Wolfgang Seeker ; Ines Rehbein ; Jonas Kuhn ; Josef Van Genabith</p><p>Abstract: For languages with (semi-) free word order (such as German), labelling grammatical functions on top of phrase-structural constituent analyses is crucial for making them interpretable. Unfortunately, most statistical classifiers consider only local information for function labelling and fail to capture important restrictions on the distribution of core argument functions such as subject, object etc., namely that there is at most one subject (etc.) per clause. We augment a statistical classifier with an integer linear program imposing hard linguistic constraints on the solution space output by the classifier, capturing global distributional restrictions. We show that this improves labelling quality, in particular for argument grammatical functions, in an intrinsic evaluation, and, importantly, grammar coverage for treebankbased (Lexical-Functional) grammar acquisition and parsing, in an extrinsic evaluation.</p><p>4 0.72768748 <a title="130-lda-4" href="./acl-2010-Word_Representations%3A_A_Simple_and_General_Method_for_Semi-Supervised_Learning.html">263 acl-2010-Word Representations: A Simple and General Method for Semi-Supervised Learning</a></p>
<p>Author: Joseph Turian ; Lev-Arie Ratinov ; Yoshua Bengio</p><p>Abstract: If we take an existing supervised NLP system, a simple and general way to improve accuracy is to use unsupervised word representations as extra word features. We evaluate Brown clusters, Collobert and Weston (2008) embeddings, and HLBL (Mnih & Hinton, 2009) embeddings of words on both NER and chunking. We use near state-of-the-art supervised baselines, and find that each of the three word representations improves the accuracy of these baselines. We find further improvements by combining different word representations. You can download our word features, for off-the-shelf use in existing NLP systems, as well as our code, here: http ://metaoptimize com/proj ects/wordreprs/ .</p><p>5 0.60516101 <a title="130-lda-5" href="./acl-2010-Convolution_Kernel_over_Packed_Parse_Forest.html">71 acl-2010-Convolution Kernel over Packed Parse Forest</a></p>
<p>Author: Min Zhang ; Hui Zhang ; Haizhou Li</p><p>Abstract: This paper proposes a convolution forest kernel to effectively explore rich structured features embedded in a packed parse forest. As opposed to the convolution tree kernel, the proposed forest kernel does not have to commit to a single best parse tree, is thus able to explore very large object spaces and much more structured features embedded in a forest. This makes the proposed kernel more robust against parsing errors and data sparseness issues than the convolution tree kernel. The paper presents the formal definition of convolution forest kernel and also illustrates the computing algorithm to fast compute the proposed convolution forest kernel. Experimental results on two NLP applications, relation extraction and semantic role labeling, show that the proposed forest kernel significantly outperforms the baseline of the convolution tree kernel. 1</p><p>6 0.60508209 <a title="130-lda-6" href="./acl-2010-Simple%2C_Accurate_Parsing_with_an_All-Fragments_Grammar.html">211 acl-2010-Simple, Accurate Parsing with an All-Fragments Grammar</a></p>
<p>7 0.60457873 <a title="130-lda-7" href="./acl-2010-Contextualizing_Semantic_Representations_Using_Syntactically_Enriched_Vector_Models.html">70 acl-2010-Contextualizing Semantic Representations Using Syntactically Enriched Vector Models</a></p>
<p>8 0.60373116 <a title="130-lda-8" href="./acl-2010-A_Structured_Model_for_Joint_Learning_of_Argument_Roles_and_Predicate_Senses.html">17 acl-2010-A Structured Model for Joint Learning of Argument Roles and Predicate Senses</a></p>
<p>9 0.59951401 <a title="130-lda-9" href="./acl-2010-Accurate_Context-Free_Parsing_with_Combinatory_Categorial_Grammar.html">23 acl-2010-Accurate Context-Free Parsing with Combinatory Categorial Grammar</a></p>
<p>10 0.59619737 <a title="130-lda-10" href="./acl-2010-Learning_to_Translate_with_Source_and_Target_Syntax.html">169 acl-2010-Learning to Translate with Source and Target Syntax</a></p>
<p>11 0.59582347 <a title="130-lda-11" href="./acl-2010-Latent_Variable_Models_of_Selectional_Preference.html">158 acl-2010-Latent Variable Models of Selectional Preference</a></p>
<p>12 0.59581876 <a title="130-lda-12" href="./acl-2010-Joint_Syntactic_and_Semantic_Parsing_of_Chinese.html">153 acl-2010-Joint Syntactic and Semantic Parsing of Chinese</a></p>
<p>13 0.59565711 <a title="130-lda-13" href="./acl-2010-Fully_Unsupervised_Core-Adjunct_Argument_Classification.html">120 acl-2010-Fully Unsupervised Core-Adjunct Argument Classification</a></p>
<p>14 0.59326804 <a title="130-lda-14" href="./acl-2010-A_Latent_Dirichlet_Allocation_Method_for_Selectional_Preferences.html">10 acl-2010-A Latent Dirichlet Allocation Method for Selectional Preferences</a></p>
<p>15 0.58930033 <a title="130-lda-15" href="./acl-2010-Blocked_Inference_in_Bayesian_Tree_Substitution_Grammars.html">53 acl-2010-Blocked Inference in Bayesian Tree Substitution Grammars</a></p>
<p>16 0.58909631 <a title="130-lda-16" href="./acl-2010-Unsupervised_Ontology_Induction_from_Text.html">248 acl-2010-Unsupervised Ontology Induction from Text</a></p>
<p>17 0.58497274 <a title="130-lda-17" href="./acl-2010-Understanding_the_Semantic_Structure_of_Noun_Phrase_Queries.html">245 acl-2010-Understanding the Semantic Structure of Noun Phrase Queries</a></p>
<p>18 0.58372647 <a title="130-lda-18" href="./acl-2010-Experiments_in_Graph-Based_Semi-Supervised_Learning_Methods_for_Class-Instance_Acquisition.html">109 acl-2010-Experiments in Graph-Based Semi-Supervised Learning Methods for Class-Instance Acquisition</a></p>
<p>19 0.58318603 <a title="130-lda-19" href="./acl-2010-Minimized_Models_and_Grammar-Informed_Initialization_for_Supertagging_with_Highly_Ambiguous_Lexicons.html">172 acl-2010-Minimized Models and Grammar-Informed Initialization for Supertagging with Highly Ambiguous Lexicons</a></p>
<p>20 0.58178502 <a title="130-lda-20" href="./acl-2010-Entity-Based_Local_Coherence_Modelling_Using_Topological_Fields.html">101 acl-2010-Entity-Based Local Coherence Modelling Using Topological Fields</a></p>
<br/><br/><br/>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-48522588-1', 'makerhacker.github.io');
ga('send', 'pageview');
</script>

</body>
</html>
